<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv=content-security-policy content="default-src 'none'; script-src 'self' 'unsafe-eval' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; font-src 'self' https://fonts.gstatic.com; frame-src 'self' https:; img-src 'self' data: https:; connect-src 'self' https:; worker-src blob:;">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<script>(window.dataLayer=window.dataLayer||[]).push({event:'gtm.js','gtm.start':+new Date()})</script>
<script async src="https://www.googletagmanager.com/gtm.js?id=GTM-MVPNN2"></script>
<title>Managing TLS Identities | Couchbase Capella Staging Docs</title>
<link rel="canonical" href="https://docs.stage.nonprod-project-avengers.com/couchbase-lite/3.0/csharp/p2p-managing-tls-id.html">
<link rel="stylesheet" href="../../../_/css/site.css">
<script src="../../../_/js/vendor/jquery.js"></script>
<meta name="description" content="Couchbase Lite - this content covers how to manage TLS identities using Couchbase Lite">
<link rel="schema.dcterms" href="https://purl.org/dc/terms/">


<meta name="dcterms.subject" content="couchbase-lite">
<meta name="dcterms.identifier" content="3.0">
<meta name="page-url" content="/couchbase-lite/3.0/csharp/p2p-managing-tls-id.html">
<meta name="generator" content="Antora 3.0.1">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
</head>
<body class="article">
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MVPNN2" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<header class="header fixed-top">
  <div class="header-top-row">
      <div class="container">
          <nav class="navbar navbar-expand-md flex-nowrap justify-content-between navbar-new-top">
              <ul class="navbar-brand-list">
                <li class="brand-logo">
                  <a class="navbar-brand" href="https://www.couchbase.com">
                    <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase" />
                  </a>
                </li>
                <li>
                  <a class="navbar-brand cb-documentation" href="https://docs.stage.nonprod-project-avengers.com/cloud/index.html">
                    <img src="../../../_/img/cb-documentation.svg" alt="Couchbase Documentation" class="cb-docs" />
                    <img src="../../../_/img/cb-docs-hover.svg" alt="Couchbase Documentation" class="hide cb-hover-docs" />
                  </a>
                </li>
              </ul>
              <button class="navbar-burger" data-target="topbar-menu">
                <span></span>
                <span></span>
                <span></span>
              </button>

          </nav>
      </div>
  </div>
  <div class="header-bottom-row" id="topbar-menu">
    <div class="container">
        <nav  class="navbar navbar-new-bottom">

              <div class="navbar-collapse collapse" id="navbar2">
                <ul class="navbar-nav w-100 justify-content-start">
                  <li class="nav-item">
                    <a href="https://docs.stage.nonprod-project-avengers.com/cloud/index.html" class="nav-link">
                      <i class="fas fa-home"></i>
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/server.html">
                      Server
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/mobile.html">
                      Mobile
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../cloud/index.html">
                      Capella
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/sdk.html">
                      SDKs
                    </a>
                  </li>
                </ul>
              </div>
              <div class="primary-action">
                <a class="btn btn-primary btn-grey-reverse" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Download'});" href="https://www.couchbase.com/downloads">
                  Downloads
                  <i class="far fa-arrow-to-bottom fa-fw"></i>
                </a>
                <a href="https://cloud.couchbase.com/sign-up" class="btn btn-primary" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Free Trial'});" >
                  Start Free Trial
                  <i class="far fa-cloud fa-fw"></i>
                </a>

              </div>

        </nav>
    </div>
   </div>
</header>
<div class="body container">
<aside class="nav left-sidebar">
  <div class="nav-container">
    <a href="#" class="menu-expand-toggle"><span>Navigation</span><i class="fas fa-times-circle"></i><i class="fas fa-chevron-circle-left"></i></a>
  </div>
</aside>
<aside class="toc sidebar"
      data-title="Contents"
      data-levels="2">
  <div class="sidebar-box">
    <div class="tools" role="navigation">
<ul>
<li class="tool edit"><a href="file:///Users/hakimcassimally/couchbase/docs-couchbase-lite/modules/csharp/pages/p2p-managing-tls-id.adoc" title="Edit Page" target="_blank" rel="noopener" class="remove-ext-icon">Edit on GitHub</a></li>
</ul>
</div>
    <div class="toc-menu"></div>
    <div class="is-this-helpful-box">
      <h4> Is this page helpful?</h4>
      <div class="btn-row">
        <a href="#" class="like-btn helpful-btn" id="yesBtn" data-page-rating="like" >
                <i class="far fa-thumbs-up"></i>
            Yes

            </a>
        <a href="#" class="dislike-btn helpful-btn" id="noBtn"  data-page-rating="dislike"> <i class="far fa-thumbs-down"></i> No</a>
      </div>
      <div class="any-feedback">
        <a href="#" class="btn any-feedback-btn" id="myCustomTrigger">Leave Additional Feedback? </a>
      </div>
      <div class="dialog-box" id="dialogBox">
        <form>
            <div class="form-group " id="additionalFeedbackBox">
              <textarea class="input-control feed-back-msg" rows="8" placeholder="Any Additonal Feedback?"></textarea>

              <div class="action-btn-row ">
                <a href="#" class="skip-btn" id="skipBtnMsg">Skip</a>
                  <button class="submit-btn btn blue-btn disabled" > Submit  </button>
                  <a href="#" class="info-btn"><i class="fas fa-info-circle"></i></a>
              </div>


            </div>

        </form>

      </div>
    </div>
  </div>

</aside>

<div class="feedback-modal modal-popup">
  <div class="modal-popup-dialogue">
    <div class="popup-header">
      <a href="#" class="close-popup"><i class="fa fa-times"></i></a>
    </div>
    <div class="popup-content">
      <p>
        Please use the form below to provide your feedback. Because your feedback is valuable to us,
         the information you submit in this form is recorded in our issue tracking system (JIRA), which is publicly available.
        You can track the status of your feedback using the ticket number displayed in the dialog once you submit the form.
      </p>
    </div>
  </div>
</div>

<main class="article" data-ceiling="topbar">
<div class="article-header">
<nav class="crumbs" aria-label="breadcrumbs">
<ul>
<li class="crumb"><a href="../index.html">Couchbase Lite</a></li>
<li class="crumb"><a href="p2p-managing-tls-id.html">Managing TLS Identities</a></li>
</ul>
</nav>
</div>
<article class="doc">
<div class="page-heading-title">
<h1 class="page">Managing TLS Identities</h1>
</div>
<div class="contributor-list-box">
<span class="last-commit-date" id="commitdate">    </span>
<ul id="contributorList"></ul>
<span  id="otherContributor"> + </span>
</div><div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite - this content covers how to manage TLS identities using Couchbase Lite</em><br>
Related Content&#8201;&#8212;&#8201;<a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-net">API Reference</a>  |  <a href="p2psync-websocket-using-passive.html" class="xref page">Passive Peer</a>  |  <a href="p2psync-websocket-using-active.html" class="xref page">Active Peer</a></p>
</div>
</blockquote>
</div>
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite - this content covers how to manage TLS identities using Couchbase Lite</em><br></p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1 pane__frames">
<h2 id="overview"><a class="anchor" href="#overview"></a>Overview</h2>
<div class="sectionbody">
<div class="ulist no-color">
<div class="title"></div>
<ul>
<li>
<p>This describes the configuration and management of TLS identities</p>
</li>
</ul>
</div>
<div class="ulist narrow">
<div class="title">Key Concepts</div>
<ul>
<li>
<p>API: <a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-net/api/Couchbase.Lite.P2P.TLSIdentity.html">TLSIdentity</a></p>
</li>
<li>
<p><a href="p2psync-websocket.html" class="xref page">Peer-to-Peer</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="api-references"><a class="anchor" href="#api-references"></a>API References</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can find <a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-net">C#.Net API References</a> here.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-tls-identity"><a class="anchor" href="#creating-tls-identity"></a>Creating TLS Identity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are couple of options by which TLS Identity is created:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can use the <a href="#anonymous-cert">anonymous self-signed cert</a> auto-generated by Couchbase Lite</p>
</li>
<li>
<p>You can <a href="#importing-a-cert">import a cert</a> to be bundled with the app and-or stored in the keychain</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="use-anonymous-cert"><a class="anchor" href="#use-anonymous-cert"></a>Use Anonymous Cert</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Anonymous certification uses the self signed certificate auto-generated by Couchbase Lite when TLS is enabled, but no TLSIdentity is provided.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">listenerConfig.disableTLS  = false // Use with anonymous self signed cert
listenerConfig.tlsIdentity = nil</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="import-a-cert"><a class="anchor" href="#import-a-cert"></a>Import a Cert</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use the <a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-net/api/Couchbase.Lite.P2P.TLSIdentity.html">TLSIdentity</a> class&#8217;s  <a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-net/api/Couchbase.Lite.P2P.TLSIdentity.html#Couchbase_Lite_P2P_TLSIdentity_ImportIdentity_System_Security_Cryptography_X509Certificates_X509Store_System_Byte___System_String_System_String_System_String_">ImportIdentity()</a> method to import a certificate that can be bundled with the app and-or added to the keychain.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First check the keychain to see if the identity already exists</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">[data-source-url=https://github.com/couchbase/docs-couchbase-lite/blob/undefined/modules/csharp/examples/code_snippets/Program.cs]</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Check for an existing resource bundle</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#" data-source-url="https://github.com/couchbase/docs-couchbase-lite/blob/undefined/modules/csharp/examples/code_snippets/Program.cs">//
// Program.cs
//
// Copyright (c) 2017 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;

using Couchbase.Lite;
using Couchbase.Lite.Enterprise.Query;
using Couchbase.Lite.Logging;
using Couchbase.Lite.P2P;
using Couchbase.Lite.Query;
using Couchbase.Lite.Sync;
using Newtonsoft.Json;

using SkiaSharp;

namespace api_walkthrough
{
    class Program
    {
        private static Database _Database;
        private static Replicator _Replicator;
        private static URLEndpointListener _listener;
        private static ListenerToken _ListenerToken;
        private static bool _NeedsExtraDocs;

        #region Private Methods

        private static void GettingStarted()
        {
            // tag::getting-started[]

            // using System;
            // using Couchbase.Lite;
            // using Couchbase.Lite.Query;
            // using Couchbase.Lite.Sync;

            // Get the database (and create it if it doesn't exist)
            var database = new Database("mydb");
            // Create a new document (i.e. a record) in the database
            string id = null;
            using (var mutableDoc = new MutableDocument())
            {
                mutableDoc.SetFloat("version", 2.0f)
                    .SetString("type", "SDK");

                // Save it to the database
                database.Save(mutableDoc);
                id = mutableDoc.Id;
            }

            // Update a document
            using (var doc = database.GetDocument(id))
            using (var mutableDoc = doc.ToMutable())
            {
                mutableDoc.SetString("language", "C#");
                database.Save(mutableDoc);

                using (var docAgain = database.GetDocument(id))
                {
                    Console.WriteLine($"Document ID :: {docAgain.Id}");
                    Console.WriteLine($"Learning {docAgain.GetString("language")}");
                }
            }

            // Create a query to fetch documents of type SDK
            // i.e. SELECT * FROM database WHERE type = "SDK"
            using (var query = QueryBuilder.Select(SelectResult.All())
                .From(DataSource.Database(database))
                .Where(Expression.Property("type").EqualTo(Expression.String("SDK"))))
            {
                // Run the query
                var result = query.Execute();
                Console.WriteLine($"Number of rows :: {result.AllResults().Count}");
            }

            // Create replicator to push and pull changes to and from the cloud
            var targetEndpoint = new URLEndpoint(new Uri("ws://localhost:4984/getting-started-db"));
            var replConfig = new ReplicatorConfiguration(database, targetEndpoint);

            // Add authentication
            replConfig.Authenticator = new BasicAuthenticator("john", "pass");

            // Create replicator (make sure to add an instance or static variable
            // named _Replicator)
            var _Replicator = new Replicator(replConfig);
            _Replicator.AddChangeListener((sender, args) =&gt;
            {
                if (args.Status.Error != null)
                {
                    Console.WriteLine($"Error :: {args.Status.Error}");
                }
            });

            _Replicator.Start();

            // Later, stop and dispose the replicator *before* closing/disposing the
        }


// end::getting-started[]

        private static void TestReplicatorConflictResolver()
        {
            // tag::replication-conflict-resolver[]
            var target = new URLEndpoint(new Uri("ws://localhost:4984/mydatabase"));
            var replConfig = new ReplicatorConfiguration(database, target);
            replConfig.ConflictResolver = new LocalWinConflictResolver();

            var replicator = new Replicator(replConfig);
            replicator.Start();
            // end::replication-conflict-resolver[]
        }

        private static void TestSaveWithConflictHandler()
        {
            // tag::update-document-with-conflict-handler[]
            using (var document = database.GetDocument("xyz"))
            using (var mutableDocument = document.ToMutable()) {
                mutableDocument.SetString("name", "apples");
                database.Save(mutableDocument, (updated, current) =&gt;
                {
                    var currentDict = current.ToDictionary();
                    var newDict = updated.ToDictionary();
                    var result = newDict.Concat(currentDict)
                        .GroupBy(kv =&gt; kv.Key)
                        .ToDictionary(g =&gt; g.Key, g =&gt; g.First().Value);
                    updated.SetData(result);
                    return true;
                });
            }
            // end::update-document-with-conflict-handler[]
        }

        private static bool IsValidCredential(string name, SecureString password) { return true;  } // helper
        private static void TestInitListener()
        {
            var db = new Database("other-database");
            _Database = db;

            // tag::init-urllistener[]
            var config = new URLEndpointListenerConfiguration(_Database);
            config.TlsIdentity = null; // Use with anonymous self-signed cert
            config.Authenticator = new ListenerPasswordAuthenticator((sender, username, password) =&gt;
            {
                if(IsValidCredential(username, password)) {
                    return true;
                }

                return false;
            });

            _listener = new URLEndpointListener(config);
            // end::init-urllistener[]
        }

        private static void TestListenerStart()
        {
            // tag::start-urllistener[]
            // CouchbaseLiteException will be thrown when the listener cannot be started. The most common error
            // would be that the configured port has already been used.
            _listener.Start();
            // end::start-urllistener[]
        }

        private static void TestListenerStop()
        {
            // tag::stop-urllistener[]
            _listener.Stop();
            // end::stop-urllistener[]
        }

        private static void TestCreateSelfSignedCert()
        {
            TLSIdentity identity;
            X509Store _store =
             new X509Store(StoreName.My);
              // The identity will be stored in the secure
              // storage using the given label.
            DateTimeOffset fiveMinToExpireCert = DateTimeOffset.UtcNow.AddMinutes(5);

            // tag::create-self-signed-cert[]
            // tag::listener-config-tls-id-SelfSigned[]
            identity = TLSIdentity.CreateIdentity(true, /* isServer */
                new Dictionary&lt;string, string&gt;() { { Certificate.CommonNameAttribute, "Couchbase Inc" } },
                    // The common name attribute is required
                    // when creating a CSR. If it is not presented
                    // in the cert, an exception is thrown.
                fiveMinToExpireCert,
                    // If the expiration date is not specified,
                    // the certs expiration will be 365 days
                _store,
                "CBL-Server-Cert",
                null);  // The key label to get cert in certificate map.
                        // If null, the same default directory
                        // for a Couchbase Lite db is used for map.

            // end::listener-config-tls-id-SelfSigned[]
            // end::create-self-signed-cert[]
        }

        private static void TestImportTLSIdentity()
        {
            TLSIdentity identity;
            X509Store _store = new X509Store(StoreName.My); // The identity will be stored in the secure storage using the given label
            byte[] data = File.ReadAllBytes("C:\\client.p12"); // PKCS12 data containing private key, public key, and certificates

            // tag::import-tls-identity[]
            // tag::listener-config-tls-id-caCert[]
            identity = TLSIdentity.ImportIdentity(_store,
                data,
                "123", // The password that is needed to access the certificate data
                "CBL-Client-Cert",
                null);  // The key label to get cert in certificate map.
                        // If null, the same default directory
                        // for a Couchbase Lite db is used for map.
            // end::listener-config-tls-id-caCert[]
            // end::import-tls-identity[]
        }

          private static void TestClientCertAuthenticatorRootCerts()
        {
            var db = new Database("other-database");
            _Database = db;

            X509Store _store = new X509Store(StoreName.My);
            TLSIdentity identity;

            // tag::client-cert-authenticator-root-certs[]
            byte[] caData, clientData;
            clientData = File.ReadAllBytes("C:\\client.p12"); // PKCS12 data containing private key, public key, and certificates
            caData = File.ReadAllBytes("C:\\client-ca.der");

            // Root certs
            var rootCert = new X509Certificate2(caData);
            var auth = new ListenerCertificateAuthenticator(new X509Certificate2Collection(rootCert));

            // Create URL Endpoint Listener
            var listenerConfig = new URLEndpointListenerConfiguration(_Database);
            listenerConfig.DisableTLS = false; //The default value is false which means that the TLS will be enabled by default.
            listenerConfig.Authenticator = auth;
            _listener = new URLEndpointListener(listenerConfig);
            _listener.Start();

            // Client identity
            identity = TLSIdentity.ImportIdentity(_store,
                clientData,
                "123",
                "CBL-Client-Cert",
                null);

            // Replicator -- Client
            var database = new Database("client-database");
            var builder = new UriBuilder(
                "wss",
                "localhost",
                _listener.Port,
                $"/{_listener.Config.Database.Name}"
            );

            var url = builder.Uri;
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.ReplicatorType = ReplicatorType.PushAndPull;
            config.Continuous = false;
            config.Authenticator = new ClientCertificateAuthenticator(identity);
            config.AcceptOnlySelfSignedServerCertificate = true;
            config.PinnedServerCertificate = _listener.TlsIdentity.Certs[0];
            using (var replicator = new Replicator(config)) {
                replicator.Start();
            }

            // Stop listener after replicator is stopped
            _listener.Stop();
            // end::client-cert-authenticator-root-cert
        }

        private static void TestClientCertAuthenticator()
        {
            var db = new Database("other-database");
            _Database = db;

            X509Store _store = new X509Store(StoreName.My);
            TLSIdentity identity;

            // tag::client-cert-authenticator[]

            // Create Listener Certificate Authenticator
            var auth = new ListenerCertificateAuthenticator((sender, cert) =&gt;
            {
                if (cert.Count != 1) {
                    return false;
                }

                return cert[0].SubjectName.Name?.Replace("CN=", "") == "couchbase";
            });

            // Create URL Endpoint Listener
            var listenerConfig = new URLEndpointListenerConfiguration(_Database);
            listenerConfig.DisableTLS = false; //The default value is false which means that the TLS will be enabled by default.
            listenerConfig.Authenticator = auth;
            _listener = new URLEndpointListener(listenerConfig);
            _listener.Start();

            // User Identity
            identity = TLSIdentity.CreateIdentity(false,
                new Dictionary&lt;string, string&gt;() { { Certificate.CommonNameAttribute, "couchbase" } },
                null,
                _store,
                ClientCertLabel,
                null);

            // Replicator -- Client
            var database = new Database("client-database");
            var builder = new UriBuilder(
                "wss",
                "localhost",
                _listener.Port,
                $"/{_listener.Config.Database.Name}"
            );

            var url = builder.Uri;
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.ReplicatorType = ReplicatorType.PushAndPull;
            config.Continuous = false;
            config.Authenticator = new ClientCertificateAuthenticator(identity);
            config.AcceptOnlySelfSignedServerCertificate = false;
            config.PinnedServerCertificate = _listener.TlsIdentity.Certs[0];
            using (var replicator = new Replicator(config)) {
                replicator.Start();
            }

            // Stop listener after replicator is stopped
            _listener.Stop();
            // end::client-cert-authenticator[]
        }

        private static void UseEncryption()
        {
            // Enterprise edition only

            // tag::database-encryption[]
            // Create a new, or open an existing database with encryption enabled
            var config = new DatabaseConfiguration
            {
                // Or, derive a key yourself and pass a byte array of the proper size
                EncryptionKey = new EncryptionKey("password")
            };

            using (var db = new Database("seekrit", config)) {
                // Change the encryption key (or add encryption if the DB is unencrypted)
                db.ChangeEncryptionKey(new EncryptionKey("betterpassw0rd"));

                // Remove encryption
                db.ChangeEncryptionKey(null);
            }
            // end::database-encryption[]
        }

        private static void ResetReplicatorCheckpoint()
        {
            var database = _Database;
            var url = new Uri("ws://localhost:4984/db");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            using (var replicator = new Replicator(config)) {
              // tag::replication-reset-checkpoint[]
              // replicator is a Replicator instance
              if (resetCheckpointRequired_Example) {
                  replicator.Start(true); <i class="conum" data-value="1"></i><b>(1)</b>
              else
                replicator.Start(false);
              }
              // end::replication-reset-checkpoint[]




                // end::replication-reset-checkpoint[]
            }
        }

        private static void Read1xAttachment()
        {
            var db = _Database;
            using (var document = new MutableDocument()) {
                // tag::1x-attachment[]
                var attachments = document.GetDictionary("_attachments");
                var avatar = attachments.GetBlob("avatar");
                var content = avatar?.Content;
                // end::1x-attachment[]
            }
        }

        private static void CreateNewDatabase()
        {
            // tag::new-database[]
            var db = new Database("my-database");
            // end::new-database[]

            _Database = db;
        }

        private static void CloseDatabase()
        {
          // tag::close-database[]
          database.Close()

          // end::close-database[]
        }

        private static void ChangeLogging()
        {
            // tag::logging[]
            Database.SetLogLevel(LogDomain.Replicator, LogLevel.Verbose);
            Database.SetLogLevel(LogDomain.Query, LogLevel.Verbose);
            // end::logging[]
        }

        private static void LoadPrebuilt()
        {
            // tag::prebuilt-database[]
            // Note: Getting the path to a database is platform-specific.  For .NET Core / .NET Framework this
            // can be a simple filesystem path.  For UWP, you will need to get the path from your assets.  For
            // iOS you need to get the path from the main bundle.  For Android you need to extract it from your
            // assets to a temporary directory and then pass that path.
            var path = Path.Combine(Environment.CurrentDirectory, "travel-sample.cblite2" + Path.DirectorySeparatorChar);
            if (!Database.Exists("travel-sample", null)) {
                _NeedsExtraDocs = true;
                Database.Copy(path, "travel-sample", null);
            }
            // end::prebuilt-database[]

            _Database.Close();
            _Database = new Database("travel-sample");
        }

        private static void QueryDeletedDocuments()
        {
            // tag::query-deleted-documents[]
            // Query documents that have been deleted
            var query = QueryBuilder
                .Select(SelectResult.Expression(Meta.ID))
                .From(DataSource.Database(db))
                .Where(Meta.IsDeleted);
            // end::query-deleted-documents[]
        }

        private static void CreateDocument()
        {
            var db = _Database;
            // tag::initializer[]
            using (var newTask = new MutableDocument("xyz")) {
                newTask.SetString("type", "task")
                    .SetString("owner", "todo")
                    .SetDate("createdAt", DateTimeOffset.UtcNow);

                db.Save(newTask);
            }
            // end::initializer[]
        }

        private static void UpdateDocument()
        {
            var db = _Database;
            // tag::update-document[]
            using(var document = db.GetDocument("xyz"))
            using (var mutableDocument = document.ToMutable()) {
                mutableDocument.SetString("name", "apples");
                db.Save(mutableDocument);
            }
            // end::update-document[]
        }

        private static void UseTypedAccessors()
        {
            using (var newTask = new MutableDocument()) {
                // tag::date-getter[]
                newTask.SetValue("createdAt", DateTimeOffset.UtcNow);
                var date = newTask.GetDate("createdAt");
                // end::date-getter[]

                Console.WriteLine(date);
            }
        }

        private static void DoBatchOperation()
        {
            var db = _Database;
            // tag::batch[]
            db.InBatch(() =&gt;
            {
                for (var i = 0; i &lt; 10; i++) {
                    using (var doc = new MutableDocument()) {
                        doc.SetString("type", "user");
                        doc.SetString("name", $"user {i}");
                        doc.SetBoolean("admin", false);
                        db.Save(doc);
                        Console.WriteLine($"Saved user document {doc.GetString("name")}");
                    }
                }
            });
            // end::batch[]
        }

        private static void DatabaseChangeListener()
        {
            var db = _Database;

            // tag::document-listener[]
            db.AddDocumentChangeListener("user.john", (sender, args) =&gt;
            {
                using (var doc = Db.GetDocument(args.DocumentID)) {
                    Console.WriteLine($"Status :: {doc.GetString("verified_account")}");
                }
            });
            // end::document-listener[]
        }

        private static void DocumentExpiration()
        {
            var db = _Database;

            // tag::document-expiration[]
            // Purge the document one day from now
            var ttl = DateTimeOffset.UtcNow.AddDays(1);
            db.SetDocumentExpiration("doc123", ttl);

            // Reset expiration
            db.SetDocumentExpiration("doc1", null);

            // Query documents that will be expired in less than five minutes
            var fiveMinutesFromNow = DateTimeOffset.UtcNow.AddMinutes(5).ToUnixTimeMilliseconds();
            var query = QueryBuilder
                .Select(SelectResult.Expression(Meta.ID))
                .From(DataSource.Database(db))
                .Where(Meta.Expiration.LessThan(Expression.Double(fiveMinutesFromNow)));
            // end::document-expiration[]
        }

        private static void UseBlob()
        {
            var db = _Database;
            using (var newTask = new MutableDocument()) {
                // tag::blob[]
                // Note: Reading the data is implementation dependent, as with prebuilt databases
                var image = File.ReadAllBytes("avatar.jpg"); <i class="conum" data-value="2"></i><b>(2)</b>
                var blob = new Blob("image/jpeg", image); <i class="conum" data-value="3"></i><b>(3)</b>
                 newTask.SetBlob("avatar", blob); <i class="conum" data-value="4"></i><b>(4)</b>
                db.Save(newTask);
                // end::blob[]

                var taskBlob = newTask.GetBlob("avatar");
                using (var bitmap = SKBitmap.Decode(taskBlob.ContentStream)) {
                    Console.WriteLine($"Bitmap dimensions: {bitmap.Width} x {bitmap.Height} ({bitmap.BytesPerPixel} bytes per pixel)");
                }
            }
        }

        public void CreateIndex()
        {
            // tag::query-index[]
            var db = _database;
            string[] indexProperties = new string[] {"type", "name" };
            var config = new ValueIndexConfiguration(indexProperties);
            db.CreateIndex("TypeNameIndex", config);
            // end::query-index[]
        }

        public void CreateIndex_Querybuilder()
        {
            // tag::query-index_Querybuilder[]
            // For value types, this is optional but provides performance enhancements
            var db = _database;
            var index = IndexBuilder.ValueIndex(
                ValueIndexItem.Expression(Expression.Property("type")),
                ValueIndexItem.Expression(Expression.Property("name"))); <i class="conum" data-value="5"></i><b>(5)</b>
            db.CreateIndex("TypeNameIndex", index);
            // end::query-index_Querybuilder[]
        }
        private static void SelectMeta()
        {
            Console.WriteLine("Select Meta");
            var db = _Database;

            // tag::query-select-meta[]
            // tag::query-select-props[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("type"),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Document ID :: {result.GetString("id")}");
                    Console.WriteLine($"Document Name :: {result.GetString("name")}");
                }
            }
            // end::query-select-props[]
            // end::query-select-meta[]
        }

        private static void SelectAll()
        {
            var db = _Database;

            // tag::query-select-all[]
            using (var query = QueryBuilder.Select(SelectResult.All())
                .From(DataSource.Database(db))) {
                // All user properties will be available here
            }
            // end::query-select-all[]

            // tag::live-query[]
            var query = QueryBuilder
                .Select(SelectResult.All())
                .From(DataSource.Database(db)); <i class="conum" data-value="6"></i><b>(6)</b>

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            var token = query.AddChangeListener((sender, args) =&gt; <i class="conum" data-value="7"></i><b>(7)</b>
            {
                var allResult = args.Results.AllResults();
                foreach (var result in allResult) {
                    Console.WriteLine(result.Keys);
                    /* Update UI */
                }
            });

            // end::live-query[]

            // tag::stop-live-query[]
            query.RemoveChangeListener(token);
            query.Dispose();
            // end::stop-live-query[]
        }

        private static void SelectWhere()
        {
            Console.WriteLine("Where");
            var db = _Database;

            // tag::query-where[]
            using (var query = QueryBuilder.Select(SelectResult.All())
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("hotel")))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    var dict = result.GetDictionary(db.Name);
                    Console.WriteLine($"Document Name :: {dict?.GetString("name")}");
                }
            }
            // end::query-where[]
        }

        private static void UseCollectionContains()
        {
            Console.WriteLine("Collection Operator CONTAINS");
            var db = _Database;

            // tag::query-collection-operator-contains[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"),
                    SelectResult.Property("public_likes"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("hotel"))
                    .And(ArrayFunction.Contains(Expression.Property("public_likes"),
                        Expression.String("Armani Langworth"))))) {
                foreach (var result in query.Execute()) {
                    var publicLikes = result.GetArray("public_likes");
                    var jsonString = JsonConvert.SerializeObject(publicLikes);
                    Console.WriteLine($"Public Likes :: {jsonString}");
                }
            }
            // end::query-collection-operator-contains[]
        }

        private static void UseCollectionIn()
        {
            Console.WriteLine("Collection Operator IN");
            var db = _Database;

            // tag::query-collection-operator-in[]
            var values = new IExpression[]
                { Expression.Property("first"), Expression.Property("last"), Expression.Property("username") };

            using (var query = QueryBuilder.Select(
                    SelectResult.All())
                .From(DataSource.Database(db))
                .Where(Expression.String("Armani").In(values))) {
                foreach (var result in query.Execute()) {
                    var body = result.GetDictionary(0);
                    var jsonString = JsonConvert.SerializeObject(body);
                    Console.WriteLine($"In results :: {jsonString}");
                }
            }
            // end::query-collection-operator-in[]
        }

        private static void SelectLike()
        {
            Console.WriteLine("Like");
            var db = _Database;

            // tag::query-like-operator[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Function.Lower(Expression.Property("name")).Like(Expression.String("Royal Engineers Museum"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-like-operator[]
        }

        private static void SelectWildcardLike()
        {
            Console.WriteLine("Wildcard Like");
            var db = _Database;

            // tag::query-like-operator-wildcard-match[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Function.Lower(Expression.Property("name")).Like(Expression.String("Eng%e%"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-like-operator-wildcard-match[]
        }

        private static void SelectWildcardCharacterLike()
        {
            Console.WriteLine("Wildchard Characters");
            var db = _Database;

            // tag::query-like-operator-wildcard-character-match[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Expression.Property("name").Like(Expression.String("Royal Eng____rs Museum"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-like-operator-wildcard-character-match[]
        }

        private static void SelectRegex()
        {
            Console.WriteLine("Regex");
            var db = _Database;

            // tag::query-regex-operator[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Expression.Property("name").Regex(Expression.String("\\bEng.*e\\b"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-regex-operator[]
        }

        private static void SelectJoin()
        {
            Console.WriteLine("Join");
            var db = _Database;

            // tag::query-join[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Expression.Property("name").From("airline")),
                    SelectResult.Expression(Expression.Property("callsign").From("airline")),
                    SelectResult.Expression(Expression.Property("destinationairport").From("route")),
                    SelectResult.Expression(Expression.Property("stops").From("route")),
                    SelectResult.Expression(Expression.Property("airline").From("route")))
                .From(DataSource.Database(db).As("airline"))
                .Join(Join.InnerJoin(DataSource.Database(db).As("route"))
                    .On(Meta.ID.From("airline").EqualTo(Expression.Property("airlineid").From("route"))))
                .Where(Expression.Property("type").From("route").EqualTo(Expression.String("route"))
                    .And(Expression.Property("type").From("airline").EqualTo(Expression.String("airline")))
                    .And(Expression.Property("sourceairport").From("route").EqualTo(Expression.String("RIX"))))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-join[]
        }

        private static void GroupBy()
        {
            Console.WriteLine("GroupBy");
            var db = _Database;

            // tag::query-groupby[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Function.Count(Expression.All())),
                    SelectResult.Property("country"),
                    SelectResult.Property("tz"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("airport"))
                    .And(Expression.Property("geo.alt").GreaterThanOrEqualTo(Expression.Int(300))))
                .GroupBy(Expression.Property("country"), Expression.Property("tz"))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine(
                        $"There are {result.GetInt("$1")} airports in the {result.GetString("tz")} timezone located in {result.GetString("country")} and above 300 ft");
                }
            }
            // end::query-groupby[]
        }

        private static void OrderBy()
        {
            Console.WriteLine("OrderBy");
            var db = _Database;

            // tag::query-orderby[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("title"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("hotel")))
                .OrderBy(Ordering.Property("title").Ascending())
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Title :: {result.GetString("title")}");
                }
            }
            // end::query-orderby[]
        }

      // ### EXPLAIN statement
      private static void TestExplainStatement()
      // For Documentation
      {
        var db = _Database;
          // tag::query-explain-all[]
        var query =
          QueryBuilder
            .Select(SelectResult.All())
            .From(DataSource.Database(db))
            .Where(Expression.Property("type").EqualTo(Expression.String("hotel")))
            .GroupBy(Expression.Property("country"))
            .OrderBy(Ordering.Property("title").Ascending()) <i class="conum" data-value="8"></i><b>(8)</b>

          Console.WriteLine(query.Explain()); <i class="conum" data-value="9"></i><b>(9)</b>

          // end::query-explain-all[]
          // tag::query-explain-like[]
var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Database(db))
    .Where(Expression.Property("type").Like(Expression.String("%hotel%"))
      .And(Function.Lower(Expression.Property("name")).Like(Expression.String("%royal%")))); <i class="conum" data-value="10"></i><b>(10)</b>
  Console.WriteLine(query.Explain());

          // end::query-explain-like[]
          // tag::query-explain-nopfx[]
var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Database(db))
    .Where(Expression.Property("type").Like(Expression.String("hotel%"))
      .And(Function.Lower(Expression.Property("name")).Like(Expression.String("%royal%")))); <i class="conum" data-value="11"></i><b>(11)</b>

  Console.WriteLine(query.Explain());

          // end::query-explain-nopfx[]
          // tag::query-explain-function[]
var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Database(db))
    .Where(Function.Lower(Expression.Property("type")).EqualTo(Expression.String("hotel"))); <i class="conum" data-value="12"></i><b>(12)</b>

  Console.WriteLine(query.Explain());

          // end::query-explain-function[]
          // tag::query-explain-nofunction[]
        var query =
          QueryBuilder
            .Select(SelectResult.All())
            .From(DataSource.Database(db))
            .Where(Expression.Property("type")).EqualTo(Expression.String("hotel")); <i class="conum" data-value="13"></i><b>(13)</b>

          Console.WriteLine(query.Explain());

          // end::query-explain-nofunction[]
      }

      // end query-explain


        public void CreateFullTextIndex()
        {
            // tag::fts-index[]
            string[] indexProperties = new string[] { "overview", "name" };
            var config = new FullTextIndexConfiguration(indexProperties);
            db.CreateIndex("overviewFTSIndex", config);
            // end::fts-index[]
        }

        public void FullTextSearch()
        {
            Console.WriteLine("Full text search");
            // tag::fts-query[]

            var db = _database;
            var ftsQuery = db.CreateQuery("SELECT * FROM _ WHERE MATCH(overviewFTSIndex, 'Michigan') ORDER BY RANK(overviewFTSIndex)");
            foreach (var result in ftsQuery.Execute())
            {
                Console.WriteLine($"Document id {result.GetString(0)}");
            }
            }
            // end::fts-query[]
        }


        private static void CreateFullTextIndex_Querybuilder()
        {
            // tag::fts-index_Querybuilder[]
            var db = _Database;

            // end::fts-index_Querybuilder[]
            if (_NeedsExtraDocs) {
                var tasks = new[] { "buy groceries", "play chess", "book travels", "buy museum tickets" };
                foreach (var task in tasks) {
                    using (var doc = new MutableDocument()) {
                        doc.SetString("type", "task");
                        doc.SetString("name", task);
                        db.Save(doc);
                    }
                }
            }

            // tag::fts-index_Querybuilder[]

            var index = IndexBuilder.FullTextIndex(FullTextIndexItem.Property("overview")).IgnoreAccents(false);
            db.CreateIndex("overviewFTSIndex", index);
            // end::fts-index_Querybuilder[]
        }

        private static void FullTextSearch_Querybuilder()
        {
            Console.WriteLine("Full text search");
            var db = _Database;

            // tag::fts-query_Querybuilder[]
            var whereClause = FullTextFunction.Match("overviewFTSIndex", "'michigan'");

            using (var query = QueryBuilder.Select(SelectResult.Expression(Meta.ID))
                .From(DataSource.Database(db))
                .Where(whereClause)) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Document id {result.GetString(0)}");
                }
            }
            // end::fts-query_Querybuilder[]
        }
        private static void StartReplication()
        {
            var db = _Database;

            /*
             * This requires Sync Gateway running with the following config, or equivalent:
             *
             * {
             *     "log":["*"],
             *     "databases": {
             *         "db": {
             *             "server":"walrus:",
             *             "users": {
             *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
             *             }
             *         }
             *     }
             * }
             */

            // tag::replication[]
            // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)
            var url = new Uri("ws://localhost:4984/db");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(db, target)
            {
                ReplicatorType = ReplicatorType.Pull
            };

            var replicator = new Replicator(config);
            replicator.Start();
            // end::replication[]

            _Replicator = replicator;
        }

        private static void VerboseReplicatorLogging()
        {
            // tag::replication-logging[]
            // deprecated
            Database.SetLogLevel(LogDomain.Replicator, LogLevel.Verbose);
            Database.SetLogLevel(LogDomain.Network, LogLevel.Verbose);
            // end::replication-logging[]
        }

        private static void ConsoleLogging()
        {
            // tag::console-logging[]
            Database.Log.Console.Domains = LogDomain.All; <i class="conum" data-value="14"></i><b>(14)</b>
            Database.Log.Console.LogLevel = LogLevel.Verbose; <i class="conum" data-value="15"></i><b>(15)</b>

            // end::console-logging[]

            // tag::console-logging-db[]
            Database.Log.Console.Domains = LogDomain.Database;

            // end::console-logging-db[]
        }

        private static void FileLogging()
        {
            // tag::file-logging[]
            var tempFolder = Path.Combine(Service.GetInstance&lt;IDefaultDirectoryResolver&gt;().DefaultDirectory(), "cbllog");
            var config = new LogFileConfiguration(tempFolder) <i class="conum" data-value="16"></i><b>(16)</b>
            {
                MaxRotateCount = 5, <i class="conum" data-value="17"></i><b>(17)</b>
                MaxSize = 10240, <i class="conum" data-value="18"></i><b>(18)</b>
                UsePlainText = false  <i class="conum" data-value="19"></i><b>(19)</b>
            };
            Database.Log.File.Config = config; // Apply configuration
            Database.Log.File.Level = LogLevel.Info; <i class="conum" data-value="20"></i><b>(20)</b>

            // end::file-logging[]
        }

        private static void EnableCustomLogging()
        {
            // tag::set-custom-logging[]
            Database.Log.Custom = new LogTestLogger(); <i class="conum" data-value="21"></i><b>(21)</b>
            or
            Database.Log.Custom = new LogTestLogger { Level = LogLevel.Warning };

            // end::set-custom-logging[]
        }

        private static void WriteConsoleLog()
        {
            // tag::write-console-logmsg[]
            Database.Log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
            // end::write-console-logmsg[]
        }
        private static void WriteCustomLog()
        {
            // tag::write-custom-logmsg[]
            Database.Log.Custom?.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
            // end::write-custom-logmsg[]
        }


        private static void WriteFileLog()
        {
            // tag::write-file-logmsg[]
            Database.Log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
            // end::write-file-logmsg[]
        }

        private static void EnableBasicAuth()
        {
            var database = _Database;

            // tag::basic-authentication[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.Authenticator = new BasicAuthenticator("john", "pass");

            var replicator = new Replicator(config);
            replicator.Start();
            // end::basic-authentication[]
        }

        private static void EnableSessionAuth()
        {
            var database = _Database;

            // tag::session-authentication[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.Authenticator = new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447");

            var replicator = new Replicator(config);
            replicator.Start();
            // end::session-authentication[]
        }

        private static void SetupReplicatorListener()
        {
            var replicator = _Replicator;

            // tag::replication-status[]
            replicator.AddChangeListener((sender, args) =&gt;
            {
                if (args.Status.Activity == ReplicatorActivityLevel.Stopped) {
                    Console.WriteLine("Replication stopped");
                }
            });
            // end::replication-status[]
        }




    //  BEGIN PendingDocuments IB -- 11/Feb/21 --
    private static void ReplicatorPendingDocuments()
    {
        // tag::replication-pendingdocuments[]
        var url = new Uri("ws://localhost:4984/mydatabase");
        var target = new URLEndpoint(url);
        var database = new Database("myDB");
        var config = new ReplicatorConfiguration(database, target);
        config.ReplicatorType  = ReplicatorType.Push;

        // tag::replication-push-pendingdocumentids[]
        var replicator = new Replicator(config);

        var mydocids =
          new HashSet &lt;string&gt; (replicator.GetPendingDocumentIDs()); <i class="conum" data-value="22"></i><b>(22)</b>

        // end::replication-push-pendingdocumentids[]

        if (mydocids.Count &gt; 0)
        {
            Console.WriteLine($"There are {mydocids.Count} documents pending");
            replicator.AddChangeListener((sender, change) =&gt;
            {
                Console.WriteLine($"Replicator activity level is " +
                                  change.Status.Activity.ToString());
                // iterate and report-on previously
                // retrieved pending docids 'list'
                foreach (var thisId in mydocids)
                    // tag::replication-push-isdocumentpending[]
                    if (!replicator.IsDocumentPending(thisId)) <i class="conum" data-value="23"></i><b>(23)</b>
                    {
                        Console.WriteLine($"Doc ID {thisId} now pushed");
                    };
                // end::replication-push-isdocumentpending[]
            });

            replicator.Start();
        }
    // end::replication-pendingdocuments[]
    }


//  END PendingDocuments IB -- 11/Feb/21 --



		private static void ReplicatorDocumentEvent()
        {
            var replicator = _Replicator;

            // tag::add-document-replication-listener[]
            var token = replicator.AddDocumentReplicationListener((sender, args) =&gt;
            {
                var direction = args.IsPush ? "Push" : "Pull";
                Console.WriteLine($"Replication type :: {direction}");
                foreach (var document in args.Documents) {
                    if (document.Error == null) {
                        Console.WriteLine($"Doc ID :: {document.Id}");
                        if (document.Flags.HasFlag(DocumentFlags.Deleted)) {
                            Console.WriteLine("Successfully replicated a deleted document");
                        }
                    } else {
                        // There was an error
                    }
                }
            });

            replicator.Start();
            // end::add-document-replication-listener[]

            // tag::remove-document-replication-listener[]
            replicator.RemoveChangeListener(token);
            // end::remove-document-replication-listener[]
        }

        private static void SetupReplicatorErrorListener()
        {
            // This can be done in the SetupReplicatorListener method
            // But it is separate so that we can have two documentation entries

            var replicator = _Replicator;

            // tag::replication-error-handling[]
            replicator.AddChangeListener((sender, args) =&gt;
            {
                if (args.Status.Error != null) {
                    Console.WriteLine($"Error :: {args.Status.Error}");
                }
            });
            // end::replication-error-handling[]
        }

        private static void DatabaseReplica()
        {
            var db = _Database;
            using (var database2 = new Database("backup")) {
                // EE feature: This code will not compile on the community edition
                // tag::database-replica[]
                var targetDatabase = new DatabaseEndpoint(database2);
                var config = new ReplicatorConfiguration(db, targetDatabase)
                {
                    ReplicatorType = ReplicatorType.Push
                };

                var replicator = new Replicator(config);
                replicator.Start();
                // end::database-replica[]

                _Replicator?.Stop();
                _Replicator = replicator;
            }
        }

        private static void PinCertificate()
        {
            // Note: No certificate is included here, so this code is for show only
            var url = new Uri("wss://localhost:4984/db");
            var target = new URLEndpoint(url);
            var db = _Database;

            // tag::certificate-pinning[]
            // Note: `GetCertificate` is a fake method. This would be the platform-specific method
            // to find and load the certificate as an instance of `X509Certificate2`.
            // For .NET Core / .NET Framework this can be loaded from the filesystem path.
            // For UWP, from the assets directory.
            // For iOS, from the main bundle.
            // For Android, from the assets directory.
            var certificate = GetCertificate("cert.cer");
            var config = new ReplicatorConfiguration(db, target)
            {
                PinnedServerCertificate = certificate
            };
            // end::certificate-pinning[]
        }

        private static void ReplicationCustomHeaders()
        {
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            // tag::replication-custom-header[]
            var config = new ReplicatorConfiguration(database, target)
            {
                Headers = new Dictionary&lt;string, string&gt;
                {
                    ["CustomHeaderName"] = "Value"
                }
            };
            // end::replication-custom-header[]
        }

        private static void PushWithFilter(Database database)
        {
            // tag::replication-push-filter[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            var config = new ReplicatorConfiguration(database, target);
            config.PushFilter = (document, flags) =&gt; <i class="conum" data-value="1"></i><b>(1)</b>
            {
                if (flags.HasFlag(DocumentFlags.Deleted)) {
                    return false;
                }

                return true;
            };

            // Dispose() later
            var replicator = new Replicator(config);
            replicator.Start();
            // end::replication-push-filter[]
        }

        private static void PullWithFilter(Database database)
        {
            // tag::replication-pull-filter[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            var config = new ReplicatorConfiguration(database, target);
            config.PullFilter = (document, flags) =&gt; <i class="conum" data-value="1"></i><b>(1)</b>
            {
                if (document.GetString("type") == "draft") {
                    return false;
                }

                return true;
            };

            // Dispose() later
            var replicator = new Replicator(config);
            replicator.Start();
            // end::replication-pull-filter[]
        }

        public void TestCustomRetryConfig()
        {
        // tag::replication-retry-config[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            var config = new ReplicatorConfiguration(database, target);

        //  other config as required . . .

        // tag::replication-set-heartbeat[]
            config.Heartbeat = TimeSpan.FromSeconds(120); //  <i class="conum" data-value="24"></i><b>(24)</b>
        // end::replication-set-heartbeat[]
        // tag::replication-set-maxattempts[]
            config.Maxattempts = 20; //  <i class="conum" data-value="25"></i><b>(25)</b>
        // end::replication-set-maxattempts[]
        // tag::replication-set-maxattemptwaittime[]
            config.MaxAttemptWaitTime = TimeSpan.FromSeconds(600); //  <i class="conum" data-value="26"></i><b>(26)</b>
        // end::replication-set-maxattemptwaittime[]

        //  other config as required . . .

            var repl = new Replicator(config);

        // end::replication-retry-config[]
        }


        private static void UsePredictiveModel()
        {
            using (var db = new Database("mydb")) {
                // tag::register-model[]
                var model = new ImageClassifierModel();
                Database.Prediction.RegisterModel("ImageClassifier", model);
                // end::register-model[]

                // tag::predictive-query-value-index[]
                var index = IndexBuilder.ValueIndex(ValueIndexItem.Property("label"));
                db.CreateIndex("value-index-image-classifier", index);
                // end::predictive-query-value-index[]

                // tag::unregister-model[]
                Database.Prediction.UnregisterModel("ImageClassifier");
                // end::unregister-model[]
            }
        }

        private static void UsePredictiveIndex()
        {
            using (var db = new Database("mydb")) {
                // tag::predictive-query-predictive-index[]
                var input = Expression.Dictionary(new Dictionary&lt;string, object&gt;
                {
                    ["photo"] = Expression.Property("photo")
                });

                var index = IndexBuilder.PredictiveIndex("ImageClassifier", input);
                db.CreateIndex("predictive-index-image-classifier", index);
                // end::predictive-query-predictive-index[]
            }
        }

        private static void DoPredictiveQuery()
        {
            using (var db = new Database("mydb")) {
                // tag::predictive-query[]
                var input = Expression.Dictionary(new Dictionary&lt;string, object&gt;
                {
                    ["photo"] = Expression.Property("photo")
                });
                var prediction = PredictiveModel.predict("ImageClassifier", input); <i class="conum" data-value="1"></i><b>(1)</b>

                using (var q = QueryBuilder.Select(SelectResult.All())
                    .From(DataSource.Database(db))
                    .Where(prediction.Property("label").EqualTo(Expression.String("car"))
                        .And(prediction.Property("probability").GreaterThanOrEqualTo(Expression.Double(0.8))))) {
                    var result = q.Execute();
                    Console.WriteLine($"Number of rows: {result.Count()}");
                }
                // end::predictive-query[]
            }
        }

        static void Main(string[] args)
        {
            // This only needs to be done once for whatever platform the executable is running
            // (UWP, iOS, Android, or desktop)
            Couchbase.Lite.Support.NetDesktop.Activate();

            CreateNewDatabase();
            CreateDocument();
            UpdateDocument();
            UseTypedAccessors();
            DoBatchOperation();
            UseBlob();
            SelectMeta();

            LoadPrebuilt();
            CreateIndex();
            SelectWhere();
            UseCollectionContains();
            SelectLike();
            SelectWildcardLike();
            SelectWildcardCharacterLike();
            SelectRegex();
            SelectJoin();
            GroupBy();
            OrderBy();

            CreateFullTextIndex();
            FullTextSearch();
            StartReplication();
            SetupReplicatorListener();

            _Replicator.Stop();
            while (_Replicator.Status.Activity != ReplicatorActivityLevel.Stopped) {
                // Database cannot close until replicators are stopped
                Console.WriteLine($"Waiting for replicator to stop (currently {_Replicator.Status.Activity})...");
                Thread.Sleep(200);
            }

            _Database.Close();
        }

        #endregion
    }

    /* ----------------------------------------------------------- */
    /* ---------------------  ACTIVE SIDE  ----------------------- */
    /* ---------------  stubs for documentation  ----------------- */
    /* ----------------------------------------------------------- */

    class ActivePeer : IMessageEndpointDelegate
    {
        ActivePeer()
        {
            var id = "";

            // tag::message-endpoint[]
            var database = new Database("dbname");

            // The delegate must implement the `IMessageEndpointDelegate` protocol.
            var messageEndpointTarget = new MessageEndpoint(uid: "UID:123", target: "",
                protocolType: ProtocolType.MessageStream, delegateObject: this);
            // end::message-endpoint[]

            // tag::message-endpoint-replicator[]
            var config = new ReplicatorConfiguration(database, messageEndpointTarget);

            // Create the replicator object
            var replicator = new Replicator(config);
            // Start the replicator
            replicator.Start();
            // end::message-endpoint-replicator[]
        }

        // tag::create-connection[]
        /* implementation of MessageEndpointDelegate */
        public IMessageEndpointConnection CreateConnection(MessageEndpoint endpoint)
        {
            var connection = new ActivePeerConnection(); /* implements MessageEndpointConnection */
            return connection;
        }
        // end::create-connection[]
    }

    class ActivePeerConnection : IMessageEndpointConnection
    {
        private IReplicatorConnection _replicatorConnection;

        public void Disconnect()
        {
            // tag::active-replicator-close[]
            _replicatorConnection?.Close(null);
            // end::active-replicator-close[]
        }

        public void Receive(byte[] data)
        {
            // tag::active-peer-receive[]
            var message = Message.FromBytes(data);
            _replicatorConnection?.Receive(message);
            // end::active-peer-receive[]
        }

        // tag::active-peer-close[]
        /* implementation of MessageEndpointConnection */
        public async Task Close(Exception error)
        {
            // await socket.Close, etc (or do nothing if already closed)
            // throw MessagingException if something goes wrong (though
            // since it is "close" nothing special will happen)
        }
        // end::active-peer-close[]

        // tag::active-peer-open[]
        /* implementation of MessageEndpointConnection */
        public async Task Open(IReplicatorConnection connection)
        {
            _replicatorConnection = connection;
            // await socket.Open(), etc
            // throw MessagingException if something goes wrong
        }
        // end::active-peer-open[]

        // tag::active-peer-send[]
        /* implementation of MessageEndpointConnection */
        public async Task Send(Message message)
        {
            var data = message.ToByteArray();
            // await Socket.Send(), etc
            // throw MessagingException if something goes wrong
        }
        // end::active-peer-send[]
    }

    /* ----------------------------------------------------------- */
    /* ---------------------  PASSIVE SIDE  ---------------------- */
    /* ---------------  stubs for documentation  ----------------- */
    /* ----------------------------------------------------------- */
    class PassivePeerConnection : IMessageEndpointConnection
    {
        private MessageEndpointListener _messageEndpointListener;
        private IReplicatorConnection _replicatorConnection;

        public void StartListener()
        {
            // tag::listener[]
            var database = new Database("mydb");
            var config = new MessageEndpointListenerConfiguration(database, ProtocolType.MessageStream);
            _messageEndpointListener = new MessageEndpointListener(config);
            // end::listener[]
        }

        public void StopListener()
        {
            // tag::passive-stop-listener[]
            _messageEndpointListener?.CloseAll();
            // end::passive-stop-listener[]
        }

        public void AcceptConnection()
        {
            // tag::advertizer-accept[]
            var connection = new PassivePeerConnection(); /* implements MessageEndpointConnection */
            _messageEndpointListener?.Accept(connection);
            // end::advertizer-accept[]
        }

        public void Disconnect()
        {
            // tag::passive-replicator-close[]
            _replicatorConnection?.Close(null);
            // end::passive-replicator-close[]
        }

        public void Receive(byte[] data)
        {
            // tag::passive-peer-receive[]
            var message = Message.FromBytes(data);
            _replicatorConnection?.Receive(message);
            // end::passive-peer-receive[]
        }

        // tag::passive-peer-close[]
        /* implementation of MessageEndpointConnection */
        public async Task Close(Exception error)
        {
            // await socket.Close, etc (or do nothing if already closed)
            // throw MessagingException if something goes wrong (though
            // since it is "close" nothing special will happen)
        }
        // end::passive-peer-close[]

        // tag::passive-peer-open[]
        /* implementation of MessageEndpointConnection */
        public Task Open(IReplicatorConnection connection)
        {
            _replicatorConnection = connection;
            // socket should already be open on the passive side
            return Task.FromResult(true);
        }
        // end::passive-peer-open[]

        // tag::passive-peer-send[]
        /* implementation of MessageEndpointConnection */
        public async Task Send(Message message)
        {
            var data = message.ToByteArray();
            // await Socket.Send(), etc
            // throw MessagingException if something goes wrong
        }
        // end::passive-peer-send[]
    }

    // tag::predictive-model[]
    // tensorFlowModel is a fake implementation
    // this would be the implementation of the ml model you have chosen
    class TensorFlowModel
    {
        public static IDictionary&lt;string, object&gt; PredictImage(byte[] data)
        {
            // Do calculations, etc
            return null;
        }
    }

    class ImageClassifierModel : IPredictiveModel
    {
        public DictionaryObject Predict(DictionaryObject input)
        {
            var blob = input.GetBlob("photo");
            if (blob == null) {
                return null;
            }

            var imageData = blob.Content;
            // tensorFlowModel is a fake implementation
            // this would be the implementation of the ml model you have chosen
            var modelOutput = TensorFlowModel.PredictImage(imageData);
            return new MutableDictionaryObject(modelOutput); <i class="conum" data-value="1"></i><b>(1)</b>
        }
    }
    // end::predictive-model[]

    // tag::custom-logging[]
    private class LogTestLogger : ILogger
    {
        public LogLevel Level { get; set; }

        public void Reset()
        {
            _lines.Clear();
        }

        public void Log(LogLevel level, LogDomain domain, string message)
        {
            // handle the message, for example piping it to
            // a third party framework
        }
    }
    // end::custom-logging[]

    // tag::local-win-conflict-resolver[]
    class LocalWinConflictResolver : IConflictResolver
    {
        Document Resolve(Conflict conflict)
        {
            return conflict.LocalDocument;
        }
    }
    // end::local-win-conflict-resolver[]

    // tag::remote-win-conflict-resolver[]
    class RemoteWinConflictResolver : IConflictResolver
    {
        public Document Resolve(Conflict conflict)
        {
            return conflict.RemoteDocument;
        }
    }
    // end::remote-win-conflict-resolver[]

    // tag::merge-conflict-resolver[]
    class MergeConflictResolver : IConflictResolver
    {
        public Document Resolve(Conflict conflict)
        {
            var localDict = conflict.LocalDocument.ToDictionary();
            var remoteDict = conflict.RemoteDocument.ToDictionary();
            var result = localDict.Concat(remoteDict)
               .GroupBy(kv =&gt; kv.Key)
               .ToDictionary(g =&gt; g.Key, g =&gt; g.First().Value);
            return new MutableDocument(conflict.DocumentID, result);
        }
    }
    // end::merge-conflict-resolver[]
}

// N1QL QUERY

  public List&lt;Result&gt; docsonly_N1QLQueryString(Database argDB)
  {
      DatabaseConfiguration dbCfg = new DatabaseConfiguration();

      Database thisDb = new Database(dbName, dbCfg);

      // For Documentation -- N1QL Query
      // tag::query-syntax-n1ql[]
      var thisQuery =
          thisDb.CreateQuery("SELECT META().id AS thisId FROM _ WHERE type = \"hotel\""); <i class="conum" data-value="27"></i><b>(27)</b>

      return thisQuery.Execute().AllResults();

      // end::query-syntax-n1ql[]
  }


  public  List&lt;Result&gt; docsonly_N1QLQueryStringParams(Database argDB)
  {
      DatabaseConfiguration dbCfg = new DatabaseConfiguration();

      Database thisDb = new Database(dbName, dbCfg);

      // For Documentation -- N1QL Query
      // tag::query-syntax-n1ql-params[]
      // Declared elsewhere: Database argDB

      var thisQuery =
          thisDb.CreateQuery("SELECT META().id AS thisId FROM _ WHERE type = $type"); <i class="conum" data-value="28"></i><b>(28)</b>

      var n1qlParams = new Parameters();
      n1qlParams.SetString("type", "hotel"); <i class="conum" data-value="29"></i><b>(29)</b>
      thisQuery.Parameters = n1qlParams;

      return thisQuery.Execute().AllResults();

      // end::query-syntax-n1ql-params[]
  }


// QUERY RESULT SET HANDLING EXAMPLES

    public static void testQuerySyntaxAll()
    {
        // For Documentation
        var dbName = "travel-sample";

        string thisDocsId;
        string thisDocsName;
        string thisDocsType;
        string thisDocsCity;
        Dictionary&lt;string,object&gt; hotel = new Dictionary&lt;string,object&gt;();

        // tag::query-syntax-all[]
        var this_Db = new Database("hotels") ;

        var query = QueryBuilder
              .Select(SelectResult.All())
              .From(DataSource.Database(this_Db));

        // end::query-syntax-all[]

        // tag::query-access-all[]
        var results = query.Execute().AllResults();

        if (results?.Count &gt; 0)
        {
            List&lt;Dictionary&lt;string,object&gt;&gt; hotels = new List&lt;Dictionary&lt;string,object&gt;&gt;();
            foreach (var result in results)
            {
                // get the result into our dictionary object
                var thisDocsProps = result.GetDictionary(dbName); <i class="conum" data-value="30"></i><b>(30)</b>

                if (thisDocsProps != null)
                {
                    thisDocsId = thisDocsProps.GetString("id"); <i class="conum" data-value="31"></i><b>(31)</b>
                    thisDocsName = thisDocsProps.GetString("name");
                    thisDocsCity = thisDocsProps.GetString("city");
                    thisDocsType = thisDocsProps.GetString("type");
                    hotel = thisDocsProps.ToDictionary();
                    hotels.Add(hotel);
                }

            }
        }
        // end::query-access-all[]

    // tag::query-access-json[]

    foreach (var result in query.Execute().AsEnumerable()) {

        // get the result into a JSON String
                var thisDocsJSONString = result.ToJSON();<i class="conum" data-value="32"></i><b>(32)</b>

        // Get a native dictionary object using the JSON string
        var dictFromJSONstring =
              JsonConvert.
                DeserializeObject&lt;Dictionary&lt;string, object&gt;&gt;
                  (thisDocsJSONString); <i class="conum" data-value="33"></i><b>(33)</b>

        // use the created dictionary
        if (dictFromJSONstring != null)
        {
            thisDocsId = dictFromJSONstring["id"].ToString();
            thisDocsName = dictFromJSONstring["name"].ToString();
            thisDocsCity = dictFromJSONstring["city"].ToString();
            thisDocsType = dictFromJSONstring["type"].ToString();
        }

        //Get a custom object using the JSON string
        Hotel this_hotel =
            JsonConvert.DeserializeObject&lt;Hotel&gt;(thisDocsJSONString); <i class="conum" data-value="34"></i><b>(34)</b>

        // Store this hotel object in a list of hotels
        hotels.Add(
            this_hotel.Id.ToString(),
                this_hotel);

    } // end foreach result
    // end::query-access-json[]
  }


    private static void testQuerySyntaxProps()
    {
        // For Documentation
        var dbName = "travel-sample";
        // var this_Db = new Database(dbName);

        string thisDocsName;
        string thisDocsType;
        string thisDocsCity;
        // tag::query-syntax-props[]
        var this_Db = new Database("hotels") ;

        Dictionary&lt;string, object&gt; hotel = new Dictionary&lt;string, object&gt;();

        List&lt;Dictionary&lt;string, object&gt;&gt; hotels = new List&lt;Dictionary&lt;string, object&gt;&gt;();

        var query = QueryBuilder.Select(
                SelectResult.Property("type"),
                SelectResult.Property("name"),
                SelectResult.Property("city")).From(DataSource.Database(this_Db));
        // end::query-syntax-props[]

        // tag::query-access-props[]
        var results = query.Execute().AllResults();
        foreach (var result in results)
        {

            // get the returned array of k-v pairs into a dictionary
            hotel = result.ToDictionary();

            // add hotel dictionary to list of hotel dictionaries
            hotels.Add(hotel);

            // use the properties of the returned array of k-v pairs directly
            thisDocsType = result.GetString("type");
            thisDocsName = result.GetString("name");
            thisDocsCity = result.GetString("city");

        }

    // end::query-access-props[]
    } // test-query-access-props



    private static void testQuerySyntaxCount()
    {
        // For Documentation
        var dbName = "travel-sample";
        // var this_Db = new Database(dbName);

        Dictionary&lt;string, object&gt; hotel = new Dictionary&lt;string, object&gt;();
        List&lt;Dictionary&lt;string, object&gt;&gt; hotels = new List&lt;Dictionary&lt;string, object&gt;&gt;();

        // tag::query-syntax-count-only[]
        var this_Db = new Database("hotels") ;

        var query =
          QueryBuilder
            .Select(SelectResult.Expression(Function.Count(Expression.All())).As("mycount")) <i class="conum" data-value="35"></i><b>(35)</b>
            .From(DataSource.Database(this_Db));

        // end::query-syntax-count-only[]


        // tag::query-access-count-only[]

        var results = query.Execute().AllResults();

        foreach (var result in results)
        {

            var numberOfDocs = result.GetInt("mycount"); <i class="conum" data-value="36"></i><b>(36)</b>

        }

        // end::query-access-count-only[]
    }




    private static void ibQueryForID()
    {

        // For Documentation
        var dbName = "travel-sample";
        // var this_Db = new Database(dbName);

        Dictionary&lt;string, object&gt; hotel = new Dictionary&lt;string, object&gt;();
        List&lt;Dictionary&lt;string, object&gt;&gt; hotels = new List&lt;Dictionary&lt;string, object&gt;&gt;();


        // tag::query-syntax-id[]
        var this_Db = new Database("hotels") ;

        var query = QueryBuilder
                .Select(SelectResult.Expression(Meta.ID).As("this_ID"))
                .From(DataSource.Database(this_Db));

        // end::query-syntax-id[]


        // tag::query-access-id[]
        var results = query.Execute().AllResults();
        foreach (var result in results)
        {

            var thisDocsID = result.GetString("this_ID"); <i class="conum" data-value="37"></i><b>(37)</b>
            var doc = this_Db.GetDocument(thisDocsID);
        }

        // end::query-access-id[]
    }


// tag::query-syntax-pagination-all[]
    private static void testQueryPagination()
    {
      // For Documentation
      var dbName = "travel-sample";
      // var this_Db = new Database(dbName);

    // tag::query-syntax-pagination[]
      var this_Db = new Database("hotels") ;

      var thisLimit = 20;
      var thisOffset = 0;

      // get a count of the number of docs matching the query
      var countQuery =
          QueryBuilder
              .Select(SelectResult.Expression(Function.Count(Expression.All())).As("mycount"))
              .From(DataSource.Database(this_Db));
      var numberOfDocs =
          countQuery.Execute().AllResults().ElementAt(0).GetInt("mycount");

      if (numberOfDocs &lt; thisLimit) {
          thisLimit = numberOfDocs;
      }

      while (thisOffset &lt; numberOfDocs)
      {
          var listQuery =
              QueryBuilder
                  .Select(SelectResult.All())
                  .From(DataSource.Database(this_Db))
                  .Limit(Expression.Int(thisLimit), Expression.Int(thisOffset)); <i class="conum" data-value="38"></i><b>(38)</b>

          foreach (var result in listQuery.Execute().AllResults())
          {
              // Display and or process query results batch

          }

          thisOffset = thisOffset + thisLimit;

      } // end while

// end::query-syntax-pagination[]
// end::query-syntax-pagination-all[]
    }

    // JSONAPIMETHODS



        public void JsonApiDocument()
        {

            // tag::tojson-document[]
            Database this_DB = new Database("travel-sample");
            Database newDb = new Database("ournewdb");

            // Get a document
            var thisDoc = this_Db.GetDocument("hotel_10025");

            // Get document data as JSON String
            var thisDocAsJsonString = thisDoc?.ToJSON(); <i class="conum" data-value="39"></i><b>(39)</b>

            // Get Json Object from the Json String
            JObject myJsonObj = JObject.Parse(thisDocAsJsonString);

            // Get Native Object (anhotel) from JSON String
            List&lt;Hotel&gt; thehotels = new List&lt;Hotel&gt;();

            Hotel anhotel = new Hotel();
            anhotel = JsonConvert.DeserializeObject&lt;Hotel&gt;(thisDocAsJsonString);
            thehotels.Add(anhotel);

            // Update the retrieved native object
            anhotel.Name = "A Copy of " + anhotel.Name;
            anhotel.Id = "2001";

            // Convert the updated object back to a JSON string
            var newJsonString = JsonConvert.SerializeObject(anhotel);

            // Update new document with JSOn String
            MutableDocument newhotel =
                new MutableDocument(anhotel.Id, newJsonString); <i class="conum" data-value="40"></i><b>(40)</b>

            foreach (string key in newhotel.ToDictionary().Keys)
            {
                System.Console.WriteLine("Data -- {0} = {1}",
                    key, newhotel.GetValue(key));
            }

            newDb.Save(newhotel);

            var thatDoc = newDb.GetDocument("2001").ToJSON(); <i class="conum" data-value="41"></i><b>(41)</b>
            System.Console.Write(thatDoc);

            // end::tojson-document[]


        //    // tag::tojson-document-output[]
        //    JSON String = { "description":"Very good and central","id":"1000","country":"France","name":"Hotel Ted","type":"hotel","city":"Paris"}
        //             type = hotel
        //             id = 1000
        //             country = France
        //             city = Paris
        //             description = Very good and central
        //             name = Hotel Ted
        //        // end::tojson-document-output[]
        //         */

        } // End JSONAPIDocument


    public void JsonApiArray()
        {
            // Init for docs
            //var this_Db = DataStore.getDbHandle();
            var ourdbname = "ournewdb";

            if (Database.Exists(ourdbname, "/"))
            {
                Database.Delete(ourdbname, "/");
            }

        // tag::tojson-array[]

            Database dbNew = new Database(ourdbname);

            // JSON String -- an Array (3 elements. including embedded arrays)
            var thisJSONstring = "[{'id':'1000','type':'hotel','name':'Hotel Ted','city':'Paris','country':'France','description':'Undefined description for Hotel Ted'},{'id':'1001','type':'hotel','name':'Hotel Fred','city':'London','country':'England','description':'Undefined description for Hotel Fred'},                        {'id':'1002','type':'hotel','name':'Hotel Ned','city':'Balmain','country':'Australia','description':'Undefined description for Hotel Ned','features':['Cable TV','Toaster','Microwave']}]".Replace("'", "\"");

            // Get JSON Array from JSON String
            JArray myJsonObj = JArray.Parse(thisJSONstring);

            // Create mutable array using JSON String Array
            var myArray = new MutableArrayObject();
            myArray.SetJSON(thisJSONstring);  <i class="conum" data-value="42"></i><b>(42)</b>


            // Create a new documenty for each array element
            for (int i = 0; i &lt; myArray.Count; i++)
            {
                var dict = myArray.GetDictionary(i);
                var docid = myArray[i].Dictionary.GetString("id");
                var newdoc = new MutableDocument(docid, dict.ToDictionary()); <i class="conum" data-value="43"></i><b>(43)</b>
                dbNew.Save(newdoc);
            }

            // Get one of the created docs and iterate through one of the embedded arrays
            var extendedDoc = dbNew.GetDocument("1002");
            var features = extendedDoc.GetArray("features");
            <i class="conum" data-value="44"></i><b>(44)</b>
            foreach (string feature in features) {
                System.Console.Write(feature);
                //process array item as required
            }
            var featuresJSON = extendedDoc.GetArray("features").ToJSON(); <i class="conum" data-value="45"></i><b>(45)</b>

            // end::tojson-array[]
        }


        public void JsonApiDictionary()
        {

            var ourdbname = "ournewdb";

            if (Database.Exists(ourdbname, "/"))
            {
                Database.Delete(ourdbname, "/");
            }
            Database dbNew = new Database(ourdbname);

            // tag::tojson-dictionary[]

            // Get dictionary from JSONstring
            var aJSONstring = "{'id':'1002','type':'hotel','name':'Hotel Ned','city':'Balmain','country':'Australia','description':'Undefined description for Hotel Ned','features':['Cable TV','Toaster','Microwave']}".Replace("'", "\"");
            var myDict = new MutableDictionaryObject(json: aJSONstring); <i class="conum" data-value="46"></i><b>(46)</b>

            // use dictionary to get name value
            var name = myDict.GetString("name");


            // Iterate through keys
            foreach (string key in myDict.Keys)
            {
                System.Console.WriteLine("Data -- {0} = {1}", key, myDict.GetValue(key).ToString());

            }
            // end::tojson-dictionary[]

            /*
            // tag::tojson-dictionary-output[]

                mono-stdout: Data -- id = 1002
                mono-stdout: Data -- type = hotel
                mono-stdout: Data -- name = Hotel Ned
                mono-stdout: Data -- city = Balmain
                mono-stdout: Data -- country = Australia
                mono-stdout: Data -- description = Undefined description for Hotel Ned
                mono-stdout: Data -- features = Couchbase.Lite.MutableArrayObject

            // end::tojson-dictionary-output[]
            */
        } /* end of func */


         public void JsonApiBlob()
        {
            // Init
            var ourpath = DataStore.getUserFolder();
            var ourdbname = "ournewdb";
            var userName = "ian";
            //ourpath = Path.Combine(ourpath,userName);

            if (Database.Exists(ourdbname, ourpath))
            {
                Database.Delete(ourdbname, ourpath);
            }
            var dbCfg = new DatabaseConfiguration();
            dbCfg.Directory=ourpath;
            Database dbNew = new Database(ourdbname,dbCfg);

            // tag::tojson-blob[]

            // Initialize base document for blob from a JSON string
            var docId = "1002";
            var aJSONstring = "{'ref':'hotel_1002','type':'hotel','name':'Hotel Ned'," +
                "'city':'Balmain','country':'Australia'," +
                "'description':'Undefined description for Hotel Ned'," +
                "'features':['Cable TV','Toaster','Microwave']}".Replace("'", "\"");
            var myDoc = new MutableDocument(docId, aJSONstring); <i class="conum" data-value="47"></i><b>(47)</b>


            // Get the content (an image), create blob and add to doc)
            var defaultDirectory =
                Path.Combine(Service.GetInstance&lt;IDefaultDirectoryResolver&gt;()
                            .DefaultDirectory(),
                                userName);
            var myImagePath = Path.Combine(defaultDirectory, "avatarimage.jpg");
            var myImageUri = new Uri(myImagePath.ToString());
            var myBlob = new Blob("image/jpg", myImageUri); <i class="conum" data-value="48"></i><b>(48)</b>
            myDoc.SetBlob("avatar", myBlob); <i class="conum" data-value="49"></i><b>(49)</b>


            // This example generates a 'blob not saved' exception
            try { Console.WriteLine("myBlob (unsaved) as JSON = {0}", myBlob.ToJSON());}
                catch (Exception e)
                    {Console.WriteLine("Exception = {0}", e.Message);}

            dbNew.Save(myDoc);

            // Alternatively -- depending on use case
            dbNew.SaveBlob(new Blob("image/jpg", myImageUri)); <i class="conum" data-value="50"></i><b>(50)</b>


            // Retrieve saved doc, get blob as JSON andheck its still a 'blob'
            var sameDoc = dbNew.GetDocument(docId);
            var reconstitutedBlob = new MutableDictionaryObject().
                SetDictionary("blobCOPY", new MutableDictionaryObject(sameDoc.GetBlob("avatar").ToJSON())); <i class="conum" data-value="51"></i><b>(51)</b>

            if (Blob.IsBlob(
                    reconstitutedBlob.GetDictionary("blobCOPY").ToDictionary()))  <i class="conum" data-value="52"></i><b>(52)</b>
            {
               //... process accordingly
               Console.WriteLine("Its a Blob!!");
            }

            // end::tojson-blob[]
            var datavalue = "";
            foreach (string key in myDoc.Keys)
            {
                if (key == "features")
                {
                    datavalue = "features are: ";
                    foreach (string item in myDoc.GetArray(key))
                    {
                        datavalue = datavalue + ", " + item;
                    }
                }
                else if (key == "avatar")
                {
                    datavalue = sameDoc.GetBlob(key).ToJSON();
                }
                else
                {
                    datavalue = sameDoc.GetValue(key).ToString();
                }

                System.Console.WriteLine(" Data -- {0} = {1}", key, datavalue);
            }

            // System.Console.WriteLine(" reconstitutedBlob = {0}", reconstitutedBlob.GetDictionary("blobCOPY").ToJSON());



            //}

            /*
            // tag::tojson-blob-output[]


                Exception = Missing Digest Due To Blob Is Not Saved To Database yet.

                Data -- id = 1002
                Data -- type = hotel
                Data -- name = Hotel Ned
                Data -- city = Balmain
                Data -- country = Australia
                Data -- description = Undefined description for Hotel Ned
                Data -- features = features are: , Cable TV, Toaster, Microwave
                Data -- avatar = {"digest":"sha1-sdCxeOeP3IZV4FEvVVlvtulpWA8=","length":2975,"content_type":"image/jpg","@type":"blob"}

                blobAsJSONstring = {"digest":"sha1-sdCxeOeP3IZV4FEvVVlvtulpWA8=","length":2975,"content_type":"image/jpg","@type":"blob"}

            // end::tojson-blob-output[]
            */
        } /* end of func */




  } // end of class



// p2p sync items


// tag::listener-simple[]
var thisConfig = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="53"></i><b>(53)</b>

thisConfig.Authenticator =
  new ListenerPasswordAuthenticator(
    (sender, username, password) =&gt;
      {
      return username.equals("valid.user")  &amp;&amp; (password == validPassword);
      }
  ); <i class="conum" data-value="54"></i><b>(54)</b>

_thisListener = new URLEndpointListener(thisConfig); <i class="conum" data-value="55"></i><b>(55)</b>

_thisListener.Start(); <i class="conum" data-value="56"></i><b>(56)</b>

// end::listener-simple[]



// tag::replicator-simple[]
var theListenerEndpoint = new URLEndpoint("wss://listener.com:4984/otherDB"); <i class="conum" data-value="57"></i><b>(57)</b>

var thisConfig = new ReplicatorConfiguration(thisDB, theListenerEndpoint); <i class="conum" data-value="58"></i><b>(58)</b>

thisConfig.AcceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="59"></i><b>(59)</b>

thisConfig.Authenticator =
  new BasicAuthenticator("valid.user", "valid.password.string"); <i class="conum" data-value="60"></i><b>(60)</b>

var thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="61"></i><b>(61)</b>

thisReplicator.Start(); <i class="conum" data-value="62"></i><b>(62)</b>

// end::replicator-simple[]







// PASSIVE PEER STUFF
// Stuff I adapted
//
//
// p2pSync-websockets.cs
//
// Copyright (c) 2017 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;

using Couchbase.Lite;
using Couchbase.Lite.Enterprise.Query;
using Couchbase.Lite.Logging;
using Couchbase.Lite.P2P;
using Couchbase.Lite.Query;
using Couchbase.Lite.Sync;
using Newtonsoft.Json;

using SkiaSharp;
namespace api_walkthrough
{
  class Program
  {
  private static Database _Database;
  private static Replicator _Replicator;
  private static ListenerToken _thisListenerToken;
  private static bool _NeedsExtraDocs;

  #region Private Methods
  private static void GettingStarted()
  {
    // tag::listener-initialize[]

    // tag::listener-config-db[]
    // Initialize the listener config
    var thisConfig = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="63"></i><b>(63)</b>

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.Port = 55990; <i class="conum" data-value="64"></i><b>(64)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    thisConfig.NetworkInterface = "10.1.1.10"; <i class="conum" data-value="65"></i><b>(65)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.EnableDeltaSync = true; <i class="conum" data-value="66"></i><b>(66)</b>

    // end::listener-config-delta-sync[]
    // tag::listener-config-tls-full[]
    // tag::listener-config-tls-enable[]
    thisConfig.DisableTLS = false; <i class="conum" data-value="67"></i><b>(67)</b>

    // end::listener-config-tls-enable[]
    // tag::listener-config-tls-id-anon[]
    // Use an Anonymous Self-Signed Cert
    thisConfig.TlsIdentity = null; <i class="conum" data-value="68"></i><b>(68)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure the client authenticator
    // Here we are using Basic Authentication) <i class="conum" data-value="69"></i><b>(69)</b>
    SecureString validPassword =  new SecureString(); /* example only */
    // Get SecureString input for validPassword
    var validUser = "valid.username";
    thisConfig.Authenticator = new ListenerPasswordAuthenticator(
      (sender, validUser, validPassword) =&gt;
        {
          return username.equals(validUser)  &amp;&amp; password == validPassword);
        }
      );

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // Initialize the listener
    _thisListener = new URLEndpointListener(thisConfig); <i class="conum" data-value="70"></i><b>(70)</b>

    // Start the listener
    thisListener.Start(); <i class="conum" data-value="71"></i><b>(71)</b>

    // end::listener-start[]
    // end::listener-initialize[]
  }

  // tag::old-listener-config-tls-disable[]
  thisConfig.disableTLS = true;
  // end::old-listener-config-tls-disable[]

  // tag::listener-config-tls-id-nil-2[]

  // Use “anonymous” cert. These are self signed certs created by the system
  thisConfig.TlsIdentity = null;
  // end::listener-config-tls-id-nil-2[]


  // tag::old-listener-config-delta-sync[]
  thisConfig.EnableDeltaSync = true;
  // end::old-listener-config-delta-sync[]


  // tag::listener-status-check[]
  int connectionCount = thisListener.Status.ConnectionCount; <i class="conum" data-value="72"></i><b>(72)</b>
  int activeConnectionCount = thisListener.Status.ActiveConnectionCount;  <i class="conum" data-value="73"></i><b>(73)</b>

  // end::listener-status-check[]


  // tag::listener-stop[]
  thisListener.Stop();

  // end::listener-stop[]

// Additional snippets


// tag::listener-get-network-interfaces[]
foreach(NetworkInterface ni in NetworkInterface.GetAllNetworkInterfaces())
{
  if(ni.NetworkInterfaceType == NetworkInterfaceType.Wireless80211 ||
      ni.NetworkInterfaceType == NetworkInterfaceType.Ethernet)
  {
    // do something with the interface(s)
  }
}

// end::listener-get-network-interfaces[]


// tag::listener-get-url-list[]
var thisConfig = new URLEndpointListenerConfiguration(thisDB);
_thisListener = new URLEndpointListener(thisConfig);

_thisListener.Start();

 Console.WriteLine("URLS are {0} ", thisListener.Urls;

// end::listener-get-url-list[]

    // tag::listener-config-tls-disable[]
    thisConfig.DisableTLS = true; <i class="conum" data-value="74"></i><b>(74)</b>

    // end::listener-config-tls-disable[]

    // tag::listener-local-db[]
    // . . . preceding application logic . . .
    // Get the database (and create it if it doesn't exist)
    var thisDB = new Database("mydb");

    // end::listener-local-db[]

    // tag::listener-config-tls-id-full[]
    // tag::listener-config-tls-id-caCert[]
    // Use CA Cert
    // Create a TLSIdentity from an imported key-pair
    // . . . previously declared variables include ...
    TLSIdentity thisIdentity;
    X509Store _store =
      new X509Store(StoreName.My); // create and label x509 store

    // Get keys and certificates from PKCS12 data
    byte[] thisIdData =
      File.ReadAllBytes("c:client.p12"); <i class="conum" data-value="75"></i><b>(75)</b>
    // . . . other user code . . .

    // tag::import-tls-identity[]
    thisIdentity = TLSIdentity.ImportIdentity(
      _store,
      thisIdData, <i class="conum" data-value="76"></i><b>(76)</b>
      "123", // Password to access certificate data
      "couchbase-demo-cert",
      null); // Label to get cert in certificate map
        // NOTE: If a null label is supplied then the same
        // default directory for a Couchbase Lite database
        // is used for map.

    // end::import-tls-identity[]
    // end::listener-config-tls-id-caCert[]

    // tag::listener-config-tls-id-anon[]
    // Use an Anonymous Self-Signed Cert
    thisConfig.TlsIdentity = null; <i class="conum" data-value="77"></i><b>(77)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-tls-id-set[]
    // Set the TLS Identity
    thisConfig.TlsIdentity = thisIdentity; <i class="conum" data-value="78"></i><b>(78)</b>

    // end::listener-config-tls-id-set[]
    // end::listener-config-tls-id-full[]

    // tag::listener-config-client-auth-root[]
    // Configure the client authenticator
    // to validate using ROOT CA

    // Get the valid cert chain, in this instance from
    // PKCS12 data containing private key, public key
    // and certificates <i class="conum" data-value="79"></i><b>(79)</b>
    var clientData = File.ReadAllBytes("c:client.p12");
    var ourCaData = File.ReadAllBytes("c:client-ca.der");

    // Get the root certs from the data
    var thisRootCert = new X509Certificate2(ourCaData); <i class="conum" data-value="80"></i><b>(80)</b>

    // Configure the authenticator to use the root certs
    var thisAuth = new ListenerCertificateAuthenticator(new X509Certificate2Collection(thisRootCert));

    thisConfig.Authenticator = thisAuth; <i class="conum" data-value="81"></i><b>(81)</b>

    // Initialize the listener using the config
    _listener = new URLEndpointListener(thisConfig);

    // end::listener-config-client-auth-root[]
    // tag::listener-config-client-auth-lambda[]
    // Configure the client authenticator
    // to validate using application logic

    // Get the valid cert chain, in this instance from
    // PKCS12 data containing private key, public key
    // and certificates <i class="conum" data-value="82"></i><b>(82)</b>
    clientData = File.ReadAllBytes("c:client.p12");
    ourCaData = File.ReadAllBytes("c:client-ca.der");

    // Get the root certs from the data
    var thisRootCert = new X509Certificate2(ourCaData);

    // Configure the authenticator to pass the root certs
    // To a user supplied code block for authentication
    var thisAuth =
      new ListenerCertificateAuthenticator(
        new X509Certificate2Collection(thisRootCert) =&gt; {
          // . . . user supplied code block
          // . . . returns boolean value (true=authenticated)
        }); <i class="conum" data-value="83"></i><b>(83)</b>

    thisConfig.Authenticator = thisAuth; <i class="conum" data-value="84"></i><b>(84)</b>

    // end::listener-config-client-auth-lambda[]



// END Additional






// Listener Callouts

// tag::listener-callouts-full[]

  // tag::listener-start-callouts[]
  &lt;.&gt; Initialize the listener instance using the configuration settings.
  &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.
  // end::listener-start-callouts[]


  // tag::listener-status-check-callouts[]

  &lt;.&gt; `connectionCount` -- the total number of connections served by the listener
  &lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
  //
  // end::listener-status-check-callouts[]

// tag::listener-config-tls-id-caCert-callouts[]
  &lt;.&gt; Ensure TLS is enabled.
  &lt;.&gt; The identity will be stored in the secure storage using the given label
  &lt;.&gt; PKCS12 data containing private key, public key, and certificates
  &lt;.&gt; The key pair as stored in the byte array
  &lt;.&gt; The password required to access the certificate data
  &lt;.&gt; The key label assigned to the cert in certificate map and used for retrieval
  &lt;.&gt; If null, the same default directory for a Couchbase Lite database is used for map
  &lt;.&gt; Use the TLSIdentity `thisIdentity.`

// end::listener-config-tls-id-caCert-callouts[]

  // tag::listener-config-tls-id-SelfSigned-callouts[]
  &lt;.&gt; Ensure TLS is enabled.
  &lt;.&gt; The identity will be stored in the secure storage using the given label
  &lt;.&gt; When creating a certificate, the common name attribute is required to create a CSR. If the common name is not present in the certificate an exception is thrown.
  &lt;.&gt; If the expiration date is not specified, the expiration date of the certificate is 365 days after creation
  &lt;.&gt; The key label to get cert in certificate map
  &lt;.&gt; If null, the same default directory for a Couchbase Lite database is used for map
  &lt;.&gt; Use the TLSIdentity `thisIdentity.`

  // end::listener-config-tls-id-SelfSigned-callouts[]

// end::listener-callouts-full[]








// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  // Work in progress. Code snippet to be provided.

  // end::old-listener-config-client-auth-root[]


  // prev content of listener-config-client-auth-self-signed (for ios)
  thisConfig.authenticator = ListenerCertificateAuthenticator.init {
    (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedUsers.contains(["name": certCommonName! as String])) {
      return true
    }
    return false
  }
  // tag::spare-listener-config-client-auth-self-signed[]
  // Work in progress. Code snippet to be provided.

  // end::spare-listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}
// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
thisConfig.port = tls ? wssPort : wsPort
thisConfig.disableTLS = !tls
thisConfig.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
// end::p2p-ws-api-urlendpointlistener-constructor[]


// ACTIVE PEER STUFF
// Replication code
//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

public class Examples {
  private static final String TAG = "EXAMPLE ACTIVE PEER";
  private static final String thisDBNAME = "local-database";
  private final Context context;
  // private Database database;
  // private Replicator replicator;

  public Examples(Context context) { this.context = context; }

  String user = "syncuser";
  String password = "sync9455";
  SecCertificate cert=null;
  String passivePeerEndpoint = "10.1.1.12:8920";
  String passivePeerPort = "8920";
  String passiveDbName = "userdb";
  Database thisDB;
  Replicator thisReplicator;
  ListenerToken replicatorListener;

  //@Test
  public void testActPeerSync() throws CouchbaseLiteException, URISyntaxException {
// tag::p2p-act-rep-func[]
    // . . . preceding code. for example . . .
    private static ListenerToken _thisListenerToken;
    var Database thisDB;
    // . . . other code . . .
    // tag::p2p-act-rep-initialize[]
    // initialize the replicator configuration

    var thisUrl = new URLEndpoint("wss://listener.com:4984/otherDB"); <i class="conum" data-value="85"></i><b>(85)</b>
    var config = new ReplicatorConfiguration(thisDB, thisUrl);

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config-type[]

    // Set replicator type
    thisConfig.ReplicatorType = ReplicatorType.PushAndPull;

    // end::p2p-act-rep-config-type[]
    // tag::autopurge-override[]
    // Set autopurge option
    // here we override its default
    thisConfig.EnableAutoPurge = false; <i class="conum" data-value="86"></i><b>(86)</b>

    // end::autopurge-override[]
    // tag::p2p-act-rep-config-cont[]
    // Configure Sync Mode
    thisConfig.Continuous = true; // default value

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Security -- only accept self-signed certs
    thisConfig.AcceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="87"></i><b>(87)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Security <i class="conum" data-value="88"></i><b>(88)</b>
    // tag::p2p-act-rep-auth[]
    // Configure basic auth using user credentials
    thisConfig.Authenticator = new BasicAuthenticator("Our Username", "Our Password");

    // end::p2p-act-rep-auth[]
    // tag::p2p-act-rep-config-conflict-full[]
    // tag::p2p-act-rep-config-conflict-builtin[]
    /* Optionally set a conflict resolver call back */ <i class="conum" data-value="89"></i><b>(89)</b>
    // Use built-in resolver
    thisConfig.ConflictResolver = new LocalWinConflictResolver();  //

    // end::p2p-act-rep-config-conflict-builtin[]
    // tag::p2p-act-rep-config-conflict-custom[]
    // optionally use custom resolver
    thisConfig.ConflictResolver = new ConflictResolver(
      (conflict) =&gt; {
        /* define resolver function */
      }
    ); //

    // end::p2p-act-rep-config-conflict-custom[]
    // end::p2p-act-rep-config-conflict-full[]
    // tag::p2p-act-rep-start-full[]
    // Initialize and start a replicator
    // Initialize replicator with configuration data
    var thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="90"></i><b>(90)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    //Optionally add a change listener <i class="conum" data-value="91"></i><b>(91)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    _thisListenerToken =
      thisReplicator.AddChangeListener((sender, args) =&gt;
        {
          if (args.Status.Activity == ReplicatorActivityLevel.Stopped) {
              Console.WriteLine("Replication stopped");
          }
        });

    // end::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-start[]
    // Start replicator
    thisReplicator.Start(); <i class="conum" data-value="92"></i><b>(92)</b>

    // end::p2p-act-rep-start[]
// end::p2p-act-rep-start-full[]
// end::p2p-act-rep-func[]         ***** End p2p-act-rep-func
}

// Additional snippets

    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA certs
    thisConfig.AcceptOnlySelfSignedServerCertificate = false; <i class="conum" data-value="93"></i><b>(93)</b>

    // end::p2p-act-rep-config-cacert[]
    // tag::p2p-act-rep-config-pinnedcert[]

    // Return the remote pinned cert (the listener's cert)
    byte returnedCert = new byte(thisConfig.getPinnedCertificate()); // Get listener cert if pinned
    // end::p2p-act-rep-config-pinnedcert[]
    // Configure Client Security <i class="conum" data-value="94"></i><b>(94)</b>
    // tag::p2p-act-rep-auth[]
    // Configure basic auth using user credentials
    thisConfig.Authenticator = new BasicAuthenticator("Our Username", "Our Password");

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]

    // tag::p2p-act-rep-config-cacert-pinned[]
    // Only CA Certs accepted
    thisConfig.AcceptOnlySelfSignedServerCertificate =
      false; <i class="conum" data-value="95"></i><b>(95)</b>

    var thisCert =
      new X509Certificate2(caData); <i class="conum" data-value="96"></i><b>(96)</b>

    thisConfig.PinnedServerCertificate =
      thisCert; <i class="conum" data-value="97"></i><b>(97)</b>

    // end::p2p-act-rep-config-cacert-pinned[]












    // Code to refactor
    Log.i(TAG, "The Replicator is currently " + thisReplicator.Status().getActivityLevel());

    Log.i(TAG, "The Replicator has processed " + t);

    if (thisReplicator.Status().getActivityLevel() == Replicator.ActivityLevel.BUSY) {
          Log.i(TAG, "Replication Processing");
          Log.i(TAG, "It has completed " + thisReplicator.Status().getProgess().getTotal() + " changes");
      }
    // tag::p2p-act-rep-status[]
    _thisReplicator.Stop();
    while (_thisReplicator.Status.Activity != ReplicatorActivityLevel.Stopped) {
        // Database cannot close until replicators are stopped
        Console.WriteLine($"Waiting for replicator to stop (currently {_thisReplicator.Status.Activity})...");
        Thread.Sleep(200);
    }
    _thisDatabase.Close();
    // end::p2p-act-rep-status[]

      // tag::p2p-act-rep-stop[]
      // Stop replication.
      thisReplicator.Stop(); <i class="conum" data-value="98"></i><b>(98)</b>
      // end::p2p-act-rep-stop[]


  }

{
  CouchbaseLite.init(context);
  Database thisDB = new Database("passivepeerdb");  <i class="conum" data-value="99"></i><b>(99)</b>
  // Initialize the listener config
  final URLEndpointListenerConfiguration thisConfig = new URLEndpointListenerConfiguration(database);
  thisConfig.Port(55990)             // &lt;.&gt; Default- port is selected
  thisConfig.DisableTls(false)       // &lt;.&gt; Optional. Defaults to false. You get TLS encryption out-of-box
  thisConfig.EnableDeltaSync(true)   // &lt;.&gt; Optional. Defaults to false.

  // Configure the client authenticator (if using basic auth)
  ListenerPasswordAuthenticator auth = new ListenerPasswordAuthenticator { "Our Username", "Our Password"}; <i class="conum" data-value="100"></i><b>(100)</b>
  thisConfig.Authenticator(auth); <i class="conum" data-value="101"></i><b>(101)</b>

  // Initialize the listener
  final URLEndpointListener listener = new URLEndpointListener( thisConfig ); <i class="conum" data-value="102"></i><b>(102)</b>

  // Start the listener
  listener.Start(); <i class="conum" data-value="103"></i><b>(103)</b>
    }


// tag::createTlsIdentity[]

Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
           TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
           TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
           TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
           TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
       )

TLSIdentity thisIdentity = new TLSIdentity.createIdentity(true, X509_ATTRIBUTES, null, "test-alias");

// end::createTlsIdentity[]


// tag::p2p-tlsid-store-in-keychain[]
. . . work in progress - GetHashCode snippet to be provided
// end::p2p-tlsid-store-in-keychain[]

// tag::deleteTlsIdentity[]
// tag::p2p-tlsid-delete-id-from-keychain[]
TLSIdentity.DeleteIdentity(_store, "alias-to-delete", null);

// end::p2p-tlsid-delete-id-from-keychain[]
// end::deleteTlsIdentity[]

// tag::retrieveTlsIdentity[]
// OPTIONALLY:: Retrieve a stored TLS identity using its alias/label

TLSIdentity thisIdentity = new TLSIdentity.getIdentity("CBL-Demo-Server-Cert")
// end::retrieveTlsIdentity[]


    // Configure the client authenticator (if using Basic Authentication)
    // String validUser = new String("validUsername"); // an example username
    // String validPassword = new String("validPasswordValue"); // an example password

    // ListenerPasswordAuthenticator thisAuth = new ListenerPasswordAuthenticator( <i class="conum" data-value="104"></i><b>(104)</b>
    //   validUser, validPassword -&gt; validUser == "validUsername" &amp;&amp; validPassword == "validPasswordValue" );

    // if (thisAuth) {
    //   thisConfig.Authenticator(auth);
    // }
    // else {
    //   // . . . authentication failed take appropriate exception action
    //   return
    // };




    // tag::old-p2p-act-rep-add-change-listener[]
    ListenerToken thisListener = new thisReplicator.addChangeListener(change -&gt; { <i class="conum" data-value="105"></i><b>(105)</b>
      if (change.Status().getError() != null) {
        Log.i(TAG, "Error code ::  " + change.Status().getError().getCode());
      }
    });

    // end::old-p2p-act-rep-add-change-listener[]



// g u b b i n s
// tag::duff-p2p-tlsid-tlsidentity-with-label[]


    // Configure TLS Cert CA auth using key-stored cert id alias 'doc-sync-server'

    // TLSIdentity thisIdentity = new TLSIdentity.getIdentity("doc-sync-server"); // Get existing TLS ID from sec storage

    // ClientCertificateAuthenticator thisAuth = new ClientCertificateAuthenticator(thisIdentity);

    // thisConfig.Authenticator(thisAuth);



    // USE KEYCHAIN IDENTITY IF EXISTS
    // Check if Id exists in keychain. If so use that Id

    // STILL NEED TO REFACTOR

    do {
      if let thisIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
          print("An identity with label : doco-sync-server already exists in keychain")
          return thisIdentity
          }
    } catch
    {return nil}
    thisAuthenticator.ClientCertificateAuthenticator(identity: thisIdentity )
    thisConfig.thisAuthenticator

    // end::duff-p2p-tlsid-tlsidentity-with-label[]


// tag::old-deleteTlsIdentity[]

String thisAlias = "alias-to-delete";
KeyStore thisKeystore = KeyStore.getInstance("PKCS12"); <i class="conum" data-value="106"></i><b>(106)</b>
thisKeyStore.load= null;
if (thisAlias != null) {
   thisKeystore.deleteEntry(thisAlias);  <i class="conum" data-value="107"></i><b>(107)</b>
}

// end::old-deleteTlsIdentity[]


// cert auth
let rootCertData = SecCertificateCopyData(cert) as Data
let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
// Listener:
thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

SecCertificate thisCert = new SecCertificate(); // populated as nec.

Data rootCertData = new Data(SecCertificateCopyData(thisCert));

let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
// Listener:
thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])
// cert auth


// C A L L O U T S

// tag::p2p-act-rep-config-cacert-pinned-callouts[]
&lt;.&gt; Configure to accept only CA certs
&lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
&lt;.&gt; Set the certificate to be compared with that provided by the server
// end::p2p-act-rep-config-cacert-pinned-callouts[]

// tag::??p2p-tlsid-tlsidentity-with-label-callouts[]
&lt;.&gt; PKCS12 data containing private key, public key, and certificates
&lt;.&gt; This is the default value and means that TLS is enabled
// end::??p2p-tlsid-tlsidentity-with-label-callouts[]

// tag::p2p-tlsid-tlsidentity-with-label-callouts[]
&lt;.&gt; Refuse self-signed certificates
&lt;.&gt; Get the identity
&lt;.&gt; Set the Client Certificate Authenticator to require signed certificates with this identity

// end::p2p-tlsid-tlsidentity-with-label-callouts[]


    // tag::old-listener-config-client-root-ca[]
    // Configure the client authenticator
    // to validate using ROOT CA <i class="conum" data-value="108"></i><b>(108)</b>
    byte[] thisCaData; // byte array for CA data
    using (var thisReader = new BinaryReader(stream)) {
      thisCaData = thisReader.ReadBytes(int stream.Length);
    }; // Get cert data

    var thisRootCert = new X509Certificate(thisCaData); //

    thisConfig.Authenticator = new  ListenerCertificateAuthenticator(
      new X509Certificate2Collection(thisRootCert)
    );

    // end::old-listener-config-client-root-ca[]



        // tag::p2p-tlsid-tlsidentity-with-label-per-sam[]
    var db = new Database("other-database");
    _Database = db;
    X509Store _store = new X509Store(StoreName.My);
    TLSIdentity thisIdentity;

    // tag::client-cert-authenticator-root-certs[]

    // Configure the expected server-supplied
    // credentials -- only accept CA Certs
    thisConfig.AcceptOnlySelfSignedServerCertificate = false; <i class="conum" data-value="109"></i><b>(109)</b>

    // Client identity
    thisIdentity =
      TLSIdentity.ImportIdentity(_store,
        clientData,
        "123",
        "CBL-Client-Cert",
        null); <i class="conum" data-value="110"></i><b>(110)</b>

    thisConfig.Authenticator =
      new ClientCertificateAuthenticator(thisIdentity); <i class="conum" data-value="111"></i><b>(111)</b>

    // end::client-cert-authenticator-root-certs[]





    byte[] thisCaData, thisClientData;
    thisClientData = File.ReadAllBytes("C:\\client.p12"); <i class="conum" data-value="112"></i><b>(112)</b>
    thisCaData = File.ReadAllBytes("C:\\client-ca.der");

    // Root certs
    var thisRootCert = new X509Certificate2(thisCaData);
    var thisAuth =
      new ListenerCertificateAuthenticator(
        new X509Certificate2Collection(thisRootCert));

    // Create URL Endpoint Listener
    var thisConfig = new URLEndpointListenerConfiguration(_Database);
    thisConfig.DisableTLS = false; <i class="conum" data-value="113"></i><b>(113)</b>
    thisConfig.Authenticator = thisAuth;
    _listener = new URLEndpointListener(thisConfig);
    _listener.Start();

    // Client identity
    thisIdentity = TLSIdentity.ImportIdentity(_store,
        thisClientData,
        "123",
        "CBL-Client-Cert",
        null);

    // Replicator -- Client
    var database = new Database("client-database");
    var builder = new UriBuilder(
        "wss",
        "localhost",
        _listener.Port,
        $"/{_listener.thisConfig.Database.Name}"
    );

    var url = builder.Uri;
    var target = new URLEndpoint(url);
    var thisConfig = new ReplicatorConfiguration(database, target);
    thisConfig.ReplicatorType = ReplicatorType.PushAndPull;
    thisConfig.Continuous = false;
    thisConfig.Authenticator = new ClientCertificateAuthenticator(thisIdentity);
    thisConfig.AcceptOnlySelfSignedServerCertificate = true;
    thisConfig.PinnedServerCertificate = _listener.TlsIdentity.Certs[0];
    using (var replicator = new Replicator(thisConfig)) {
        replicator.Start();
    }





    // Stop listener after replicator is stopped
    _listener.Stop();

    // end::p2p-tlsid-tlsidentity-with-label-per-sam[]


        // tag::p2p-tlsid-tlsidentity-with-label[]
    // Client identity
    thisIdentity =
      TLSIdentity.ImportIdentity(_store,
        clientData,
        "123",
        "CBL-Client-Cert",
        null); <i class="conum" data-value="114"></i><b>(114)</b>

    thisConfig.Authenticator =
      new ClientCertificateAuthenticator(thisIdentity); <i class="conum" data-value="115"></i><b>(115)</b>

    // end::p2p-tlsid-tlsidentity-with-label[]


  // For replications

  // BEGIN -- snippets --
  //    Purpose -- code samples for use in replication topic

  // tag::sgw-repl-pull[]
  public class MyClass
  {
      public Database Database { get; set; }
      public Replicator Replicator { get; set; } <i class="conum" data-value="116"></i><b>(116)</b>

      public void StartReplication()
      {
  }

          var url = new Uri("wss://localhost:4984/db"); <i class="conum" data-value="117"></i><b>(117)</b>
          var target = new URLEndpoint(url);
          var config = new ReplicatorConfiguration(Database, target)
          {
              ReplicatorType = ReplicatorType.Pull
          };

          Replicator = new Replicator(config);
          Replicator.Start();
      }
      // end::sgw-repl-pull[]

      // tag::sgw-repl-pull-callouts[]
      // &lt;.&gt; A replication is an asynchronous operation.
      // To keep a reference to the `replicator` object, you can set it as an instance property.
      // &lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
      // You should now use `ws:`, or `wss:` for SSL/TLS connections.
      // end::sgw-repl-pull-callouts[]

      public void InitReplication()
      {
        // tag::sgw-act-rep-initialize[]
        // initialize the replicator configuration

        var thisUrl = new URLEndpoint("wss://l10.0.2.2:4984/anotherDB"); <i class="conum" data-value="118"></i><b>(118)</b>
        var config = new ReplicatorConfiguration(thisDB, thisUrl);

        // end::sgw-act-rep-initialize[]
      }
  }
 }



  public class supporting_datatypes
  {
    public void datatype_usage()
    {

        // tag::datatype_usage[]
        // tag::datatype_usage_createdb[]
        // Get the database (and create it if it doesn’t exist).
        var database = new Database("hoteldb");

        // end::datatype_usage_createdb[]
        // tag::datatype_usage_createdoc[]
        // Create your new document

        // Add the dictionary to a document's properties and save the document
        var doc = new MutableDocument("hoteldoc");

        // end::datatype_usage_createdoc[]
        // tag::datatype_usage_mutdict[]
        // Create and populate mutable dictionary
        var address = new MutableDictionaryObject();
        address.SetString("street", "1 Main st.");
        address.SetString("city", "San Francisco");
        address.SetString("state", "CA");
        address.SetString("country", "USA");
        address.SetString("code", "90210");

        // end::datatype_usage_mutdict[]
        // tag::datatype_usage_mutarray[]
        // Create and populate mutable array
        var phones = MutableArrayObject();
        phones.AddString("650-000-0000");
        phones.AddString("650-000-0001");

        // end::datatype_usage_mutarray[]
        // tag::datatype_usage_populate[]
        // Initialize and populate the document

        // Add document type to document properties <i class="conum" data-value="119"></i><b>(119)</b>
        doc.SetString("type", "hotel");

        // Add hotel name string to document properties <i class="conum" data-value="120"></i><b>(120)</b>
        doc.SetString("name", "Hotel Java Mo");

        // Add float to document properties <i class="conum" data-value="121"></i><b>(121)</b>
        doc.SetFloat("room_rate", 121.75);

        // Add dictionary to document's properties <i class="conum" data-value="122"></i><b>(122)</b>
        doc.SetDictionary("address", address);

        // Add array to document's properties <i class="conum" data-value="123"></i><b>(123)</b>
        doc.SetArray("phones", phones);

        // end::datatype_usage_populate[]
        // tag::datatype_usage_persist[]
        // Save the document changes <i class="conum" data-value="124"></i><b>(124)</b>
        database.Save(doc);

        // end::datatype_usage_persist[]
        // tag::datatype_usage_closedb[]
        // Close the database <i class="conum" data-value="125"></i><b>(125)</b>
        database.Close();

        // end::datatype_usage_closedb[]

        // end::datatype_usage[]

     }



      public void datatype_dictionary()
      {
          var database = new Database(name: "mydb");

          // tag::datatype_dictionary[]
          // NOTE: No error handling, for brevity (see getting started)
          var document = database.GetDocument("doc1");

          // Getting a dictionary from the document's properties
          var dict = document.GetDictionary("address");

          // Access a value with a key from the dictionary
          var street = dict.GetString("street");

          // Iterate dictionary
          foreach (var key in dict.Keys)
          {
              Console.WriteLine($"Key {key} = {dict.GetValue(key)}");
          }

          // Create a mutable copy
          var mutDict = dict.ToMutable();
          // end::datatype_dictionary[]
      }

      public void datatype_mutable_dictionary()
      {

          var database = new Database("mydb");

          // tag::datatype_mutable_dictionary[]
          // NOTE: No error handling, for brevity (see getting started)

          // Create a new mutable dictionary and populate some keys/values
          var mutable_dict = new MutableDictionaryObject();
          mutable_dict.SetString("street", "1 Main st.");
          mutable_dict.SetString("city", "San Francisco");

          // Add the dictionary to a document's properties and save the document
          var doc = new MutableDocument("doc1");
          doc.SetDictionary("address", mutable_dict);
          database.Save(doc);

          // end::datatype_mutable_dictionary[]
      }


      public void datatype_array()
      {
          var database = new Database("mydb");

          // tag::datatype_array[]
          // NOTE: No error handling, for brevity (see getting started)

          var document = database.GetDocument("doc1");

          // Getting a phones array from the document's properties
          var array = document.GetArray("phones");

          // Get element count
          var count = array.Count();

          // Access an array element by index
          if (count &gt;= 0) { var phone = array[1]; }

          // Iterate dictionary
          for (int i = 0; i &lt; count; i++)
          {
              Console.WriteLine($"Item {i.ToString()} = {array[i]}");
          }

          // Create a mutable copy
          var mutable_array = array.ToMutable();
          // end::datatype_array[]


      }

        public void datatype_mutable_array()
      {
          var database = new Database("mydb");

          // tag::datatype_mutable_array[]
          // NOTE: No error handling, for brevity (see getting started)

          // Create a new mutable array and populate data into the array
          var mutable_array = new MutableArrayObject();
          mutable_array.AddString("650-000-0000");
          mutable_array.AddString("650-000-0001");

          // Set the array to document's properties and save the document
          var doc = new MutableDocument("doc1");
          doc.SetArray("phones", mutable_array);
          database.Save(doc);
          // end::datatype_mutable_array[]
      }

  } // end  class supporting_datatypes</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Import from an existing resource bundle</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#" data-source-url="https://github.com/couchbase/docs-couchbase-lite/blob/undefined/modules/csharp/examples/code_snippets/Program.cs">//
// Program.cs
//
// Copyright (c) 2017 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;

using Couchbase.Lite;
using Couchbase.Lite.Enterprise.Query;
using Couchbase.Lite.Logging;
using Couchbase.Lite.P2P;
using Couchbase.Lite.Query;
using Couchbase.Lite.Sync;
using Newtonsoft.Json;

using SkiaSharp;

namespace api_walkthrough
{
    class Program
    {
        private static Database _Database;
        private static Replicator _Replicator;
        private static URLEndpointListener _listener;
        private static ListenerToken _ListenerToken;
        private static bool _NeedsExtraDocs;

        #region Private Methods

        private static void GettingStarted()
        {
            // tag::getting-started[]

            // using System;
            // using Couchbase.Lite;
            // using Couchbase.Lite.Query;
            // using Couchbase.Lite.Sync;

            // Get the database (and create it if it doesn't exist)
            var database = new Database("mydb");
            // Create a new document (i.e. a record) in the database
            string id = null;
            using (var mutableDoc = new MutableDocument())
            {
                mutableDoc.SetFloat("version", 2.0f)
                    .SetString("type", "SDK");

                // Save it to the database
                database.Save(mutableDoc);
                id = mutableDoc.Id;
            }

            // Update a document
            using (var doc = database.GetDocument(id))
            using (var mutableDoc = doc.ToMutable())
            {
                mutableDoc.SetString("language", "C#");
                database.Save(mutableDoc);

                using (var docAgain = database.GetDocument(id))
                {
                    Console.WriteLine($"Document ID :: {docAgain.Id}");
                    Console.WriteLine($"Learning {docAgain.GetString("language")}");
                }
            }

            // Create a query to fetch documents of type SDK
            // i.e. SELECT * FROM database WHERE type = "SDK"
            using (var query = QueryBuilder.Select(SelectResult.All())
                .From(DataSource.Database(database))
                .Where(Expression.Property("type").EqualTo(Expression.String("SDK"))))
            {
                // Run the query
                var result = query.Execute();
                Console.WriteLine($"Number of rows :: {result.AllResults().Count}");
            }

            // Create replicator to push and pull changes to and from the cloud
            var targetEndpoint = new URLEndpoint(new Uri("ws://localhost:4984/getting-started-db"));
            var replConfig = new ReplicatorConfiguration(database, targetEndpoint);

            // Add authentication
            replConfig.Authenticator = new BasicAuthenticator("john", "pass");

            // Create replicator (make sure to add an instance or static variable
            // named _Replicator)
            var _Replicator = new Replicator(replConfig);
            _Replicator.AddChangeListener((sender, args) =&gt;
            {
                if (args.Status.Error != null)
                {
                    Console.WriteLine($"Error :: {args.Status.Error}");
                }
            });

            _Replicator.Start();

            // Later, stop and dispose the replicator *before* closing/disposing the
        }


// end::getting-started[]

        private static void TestReplicatorConflictResolver()
        {
            // tag::replication-conflict-resolver[]
            var target = new URLEndpoint(new Uri("ws://localhost:4984/mydatabase"));
            var replConfig = new ReplicatorConfiguration(database, target);
            replConfig.ConflictResolver = new LocalWinConflictResolver();

            var replicator = new Replicator(replConfig);
            replicator.Start();
            // end::replication-conflict-resolver[]
        }

        private static void TestSaveWithConflictHandler()
        {
            // tag::update-document-with-conflict-handler[]
            using (var document = database.GetDocument("xyz"))
            using (var mutableDocument = document.ToMutable()) {
                mutableDocument.SetString("name", "apples");
                database.Save(mutableDocument, (updated, current) =&gt;
                {
                    var currentDict = current.ToDictionary();
                    var newDict = updated.ToDictionary();
                    var result = newDict.Concat(currentDict)
                        .GroupBy(kv =&gt; kv.Key)
                        .ToDictionary(g =&gt; g.Key, g =&gt; g.First().Value);
                    updated.SetData(result);
                    return true;
                });
            }
            // end::update-document-with-conflict-handler[]
        }

        private static bool IsValidCredential(string name, SecureString password) { return true;  } // helper
        private static void TestInitListener()
        {
            var db = new Database("other-database");
            _Database = db;

            // tag::init-urllistener[]
            var config = new URLEndpointListenerConfiguration(_Database);
            config.TlsIdentity = null; // Use with anonymous self-signed cert
            config.Authenticator = new ListenerPasswordAuthenticator((sender, username, password) =&gt;
            {
                if(IsValidCredential(username, password)) {
                    return true;
                }

                return false;
            });

            _listener = new URLEndpointListener(config);
            // end::init-urllistener[]
        }

        private static void TestListenerStart()
        {
            // tag::start-urllistener[]
            // CouchbaseLiteException will be thrown when the listener cannot be started. The most common error
            // would be that the configured port has already been used.
            _listener.Start();
            // end::start-urllistener[]
        }

        private static void TestListenerStop()
        {
            // tag::stop-urllistener[]
            _listener.Stop();
            // end::stop-urllistener[]
        }

        private static void TestCreateSelfSignedCert()
        {
            TLSIdentity identity;
            X509Store _store =
             new X509Store(StoreName.My);
              // The identity will be stored in the secure
              // storage using the given label.
            DateTimeOffset fiveMinToExpireCert = DateTimeOffset.UtcNow.AddMinutes(5);

            // tag::create-self-signed-cert[]
            // tag::listener-config-tls-id-SelfSigned[]
            identity = TLSIdentity.CreateIdentity(true, /* isServer */
                new Dictionary&lt;string, string&gt;() { { Certificate.CommonNameAttribute, "Couchbase Inc" } },
                    // The common name attribute is required
                    // when creating a CSR. If it is not presented
                    // in the cert, an exception is thrown.
                fiveMinToExpireCert,
                    // If the expiration date is not specified,
                    // the certs expiration will be 365 days
                _store,
                "CBL-Server-Cert",
                null);  // The key label to get cert in certificate map.
                        // If null, the same default directory
                        // for a Couchbase Lite db is used for map.

            // end::listener-config-tls-id-SelfSigned[]
            // end::create-self-signed-cert[]
        }

        private static void TestImportTLSIdentity()
        {
            TLSIdentity identity;
            X509Store _store = new X509Store(StoreName.My); // The identity will be stored in the secure storage using the given label
            byte[] data = File.ReadAllBytes("C:\\client.p12"); // PKCS12 data containing private key, public key, and certificates

            // tag::import-tls-identity[]
            // tag::listener-config-tls-id-caCert[]
            identity = TLSIdentity.ImportIdentity(_store,
                data,
                "123", // The password that is needed to access the certificate data
                "CBL-Client-Cert",
                null);  // The key label to get cert in certificate map.
                        // If null, the same default directory
                        // for a Couchbase Lite db is used for map.
            // end::listener-config-tls-id-caCert[]
            // end::import-tls-identity[]
        }

          private static void TestClientCertAuthenticatorRootCerts()
        {
            var db = new Database("other-database");
            _Database = db;

            X509Store _store = new X509Store(StoreName.My);
            TLSIdentity identity;

            // tag::client-cert-authenticator-root-certs[]
            byte[] caData, clientData;
            clientData = File.ReadAllBytes("C:\\client.p12"); // PKCS12 data containing private key, public key, and certificates
            caData = File.ReadAllBytes("C:\\client-ca.der");

            // Root certs
            var rootCert = new X509Certificate2(caData);
            var auth = new ListenerCertificateAuthenticator(new X509Certificate2Collection(rootCert));

            // Create URL Endpoint Listener
            var listenerConfig = new URLEndpointListenerConfiguration(_Database);
            listenerConfig.DisableTLS = false; //The default value is false which means that the TLS will be enabled by default.
            listenerConfig.Authenticator = auth;
            _listener = new URLEndpointListener(listenerConfig);
            _listener.Start();

            // Client identity
            identity = TLSIdentity.ImportIdentity(_store,
                clientData,
                "123",
                "CBL-Client-Cert",
                null);

            // Replicator -- Client
            var database = new Database("client-database");
            var builder = new UriBuilder(
                "wss",
                "localhost",
                _listener.Port,
                $"/{_listener.Config.Database.Name}"
            );

            var url = builder.Uri;
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.ReplicatorType = ReplicatorType.PushAndPull;
            config.Continuous = false;
            config.Authenticator = new ClientCertificateAuthenticator(identity);
            config.AcceptOnlySelfSignedServerCertificate = true;
            config.PinnedServerCertificate = _listener.TlsIdentity.Certs[0];
            using (var replicator = new Replicator(config)) {
                replicator.Start();
            }

            // Stop listener after replicator is stopped
            _listener.Stop();
            // end::client-cert-authenticator-root-cert
        }

        private static void TestClientCertAuthenticator()
        {
            var db = new Database("other-database");
            _Database = db;

            X509Store _store = new X509Store(StoreName.My);
            TLSIdentity identity;

            // tag::client-cert-authenticator[]

            // Create Listener Certificate Authenticator
            var auth = new ListenerCertificateAuthenticator((sender, cert) =&gt;
            {
                if (cert.Count != 1) {
                    return false;
                }

                return cert[0].SubjectName.Name?.Replace("CN=", "") == "couchbase";
            });

            // Create URL Endpoint Listener
            var listenerConfig = new URLEndpointListenerConfiguration(_Database);
            listenerConfig.DisableTLS = false; //The default value is false which means that the TLS will be enabled by default.
            listenerConfig.Authenticator = auth;
            _listener = new URLEndpointListener(listenerConfig);
            _listener.Start();

            // User Identity
            identity = TLSIdentity.CreateIdentity(false,
                new Dictionary&lt;string, string&gt;() { { Certificate.CommonNameAttribute, "couchbase" } },
                null,
                _store,
                ClientCertLabel,
                null);

            // Replicator -- Client
            var database = new Database("client-database");
            var builder = new UriBuilder(
                "wss",
                "localhost",
                _listener.Port,
                $"/{_listener.Config.Database.Name}"
            );

            var url = builder.Uri;
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.ReplicatorType = ReplicatorType.PushAndPull;
            config.Continuous = false;
            config.Authenticator = new ClientCertificateAuthenticator(identity);
            config.AcceptOnlySelfSignedServerCertificate = false;
            config.PinnedServerCertificate = _listener.TlsIdentity.Certs[0];
            using (var replicator = new Replicator(config)) {
                replicator.Start();
            }

            // Stop listener after replicator is stopped
            _listener.Stop();
            // end::client-cert-authenticator[]
        }

        private static void UseEncryption()
        {
            // Enterprise edition only

            // tag::database-encryption[]
            // Create a new, or open an existing database with encryption enabled
            var config = new DatabaseConfiguration
            {
                // Or, derive a key yourself and pass a byte array of the proper size
                EncryptionKey = new EncryptionKey("password")
            };

            using (var db = new Database("seekrit", config)) {
                // Change the encryption key (or add encryption if the DB is unencrypted)
                db.ChangeEncryptionKey(new EncryptionKey("betterpassw0rd"));

                // Remove encryption
                db.ChangeEncryptionKey(null);
            }
            // end::database-encryption[]
        }

        private static void ResetReplicatorCheckpoint()
        {
            var database = _Database;
            var url = new Uri("ws://localhost:4984/db");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            using (var replicator = new Replicator(config)) {
              // tag::replication-reset-checkpoint[]
              // replicator is a Replicator instance
              if (resetCheckpointRequired_Example) {
                  replicator.Start(true); <i class="conum" data-value="1"></i><b>(1)</b>
              else
                replicator.Start(false);
              }
              // end::replication-reset-checkpoint[]




                // end::replication-reset-checkpoint[]
            }
        }

        private static void Read1xAttachment()
        {
            var db = _Database;
            using (var document = new MutableDocument()) {
                // tag::1x-attachment[]
                var attachments = document.GetDictionary("_attachments");
                var avatar = attachments.GetBlob("avatar");
                var content = avatar?.Content;
                // end::1x-attachment[]
            }
        }

        private static void CreateNewDatabase()
        {
            // tag::new-database[]
            var db = new Database("my-database");
            // end::new-database[]

            _Database = db;
        }

        private static void CloseDatabase()
        {
          // tag::close-database[]
          database.Close()

          // end::close-database[]
        }

        private static void ChangeLogging()
        {
            // tag::logging[]
            Database.SetLogLevel(LogDomain.Replicator, LogLevel.Verbose);
            Database.SetLogLevel(LogDomain.Query, LogLevel.Verbose);
            // end::logging[]
        }

        private static void LoadPrebuilt()
        {
            // tag::prebuilt-database[]
            // Note: Getting the path to a database is platform-specific.  For .NET Core / .NET Framework this
            // can be a simple filesystem path.  For UWP, you will need to get the path from your assets.  For
            // iOS you need to get the path from the main bundle.  For Android you need to extract it from your
            // assets to a temporary directory and then pass that path.
            var path = Path.Combine(Environment.CurrentDirectory, "travel-sample.cblite2" + Path.DirectorySeparatorChar);
            if (!Database.Exists("travel-sample", null)) {
                _NeedsExtraDocs = true;
                Database.Copy(path, "travel-sample", null);
            }
            // end::prebuilt-database[]

            _Database.Close();
            _Database = new Database("travel-sample");
        }

        private static void QueryDeletedDocuments()
        {
            // tag::query-deleted-documents[]
            // Query documents that have been deleted
            var query = QueryBuilder
                .Select(SelectResult.Expression(Meta.ID))
                .From(DataSource.Database(db))
                .Where(Meta.IsDeleted);
            // end::query-deleted-documents[]
        }

        private static void CreateDocument()
        {
            var db = _Database;
            // tag::initializer[]
            using (var newTask = new MutableDocument("xyz")) {
                newTask.SetString("type", "task")
                    .SetString("owner", "todo")
                    .SetDate("createdAt", DateTimeOffset.UtcNow);

                db.Save(newTask);
            }
            // end::initializer[]
        }

        private static void UpdateDocument()
        {
            var db = _Database;
            // tag::update-document[]
            using(var document = db.GetDocument("xyz"))
            using (var mutableDocument = document.ToMutable()) {
                mutableDocument.SetString("name", "apples");
                db.Save(mutableDocument);
            }
            // end::update-document[]
        }

        private static void UseTypedAccessors()
        {
            using (var newTask = new MutableDocument()) {
                // tag::date-getter[]
                newTask.SetValue("createdAt", DateTimeOffset.UtcNow);
                var date = newTask.GetDate("createdAt");
                // end::date-getter[]

                Console.WriteLine(date);
            }
        }

        private static void DoBatchOperation()
        {
            var db = _Database;
            // tag::batch[]
            db.InBatch(() =&gt;
            {
                for (var i = 0; i &lt; 10; i++) {
                    using (var doc = new MutableDocument()) {
                        doc.SetString("type", "user");
                        doc.SetString("name", $"user {i}");
                        doc.SetBoolean("admin", false);
                        db.Save(doc);
                        Console.WriteLine($"Saved user document {doc.GetString("name")}");
                    }
                }
            });
            // end::batch[]
        }

        private static void DatabaseChangeListener()
        {
            var db = _Database;

            // tag::document-listener[]
            db.AddDocumentChangeListener("user.john", (sender, args) =&gt;
            {
                using (var doc = Db.GetDocument(args.DocumentID)) {
                    Console.WriteLine($"Status :: {doc.GetString("verified_account")}");
                }
            });
            // end::document-listener[]
        }

        private static void DocumentExpiration()
        {
            var db = _Database;

            // tag::document-expiration[]
            // Purge the document one day from now
            var ttl = DateTimeOffset.UtcNow.AddDays(1);
            db.SetDocumentExpiration("doc123", ttl);

            // Reset expiration
            db.SetDocumentExpiration("doc1", null);

            // Query documents that will be expired in less than five minutes
            var fiveMinutesFromNow = DateTimeOffset.UtcNow.AddMinutes(5).ToUnixTimeMilliseconds();
            var query = QueryBuilder
                .Select(SelectResult.Expression(Meta.ID))
                .From(DataSource.Database(db))
                .Where(Meta.Expiration.LessThan(Expression.Double(fiveMinutesFromNow)));
            // end::document-expiration[]
        }

        private static void UseBlob()
        {
            var db = _Database;
            using (var newTask = new MutableDocument()) {
                // tag::blob[]
                // Note: Reading the data is implementation dependent, as with prebuilt databases
                var image = File.ReadAllBytes("avatar.jpg"); <i class="conum" data-value="2"></i><b>(2)</b>
                var blob = new Blob("image/jpeg", image); <i class="conum" data-value="3"></i><b>(3)</b>
                 newTask.SetBlob("avatar", blob); <i class="conum" data-value="4"></i><b>(4)</b>
                db.Save(newTask);
                // end::blob[]

                var taskBlob = newTask.GetBlob("avatar");
                using (var bitmap = SKBitmap.Decode(taskBlob.ContentStream)) {
                    Console.WriteLine($"Bitmap dimensions: {bitmap.Width} x {bitmap.Height} ({bitmap.BytesPerPixel} bytes per pixel)");
                }
            }
        }

        public void CreateIndex()
        {
            // tag::query-index[]
            var db = _database;
            string[] indexProperties = new string[] {"type", "name" };
            var config = new ValueIndexConfiguration(indexProperties);
            db.CreateIndex("TypeNameIndex", config);
            // end::query-index[]
        }

        public void CreateIndex_Querybuilder()
        {
            // tag::query-index_Querybuilder[]
            // For value types, this is optional but provides performance enhancements
            var db = _database;
            var index = IndexBuilder.ValueIndex(
                ValueIndexItem.Expression(Expression.Property("type")),
                ValueIndexItem.Expression(Expression.Property("name"))); <i class="conum" data-value="5"></i><b>(5)</b>
            db.CreateIndex("TypeNameIndex", index);
            // end::query-index_Querybuilder[]
        }
        private static void SelectMeta()
        {
            Console.WriteLine("Select Meta");
            var db = _Database;

            // tag::query-select-meta[]
            // tag::query-select-props[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("type"),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Document ID :: {result.GetString("id")}");
                    Console.WriteLine($"Document Name :: {result.GetString("name")}");
                }
            }
            // end::query-select-props[]
            // end::query-select-meta[]
        }

        private static void SelectAll()
        {
            var db = _Database;

            // tag::query-select-all[]
            using (var query = QueryBuilder.Select(SelectResult.All())
                .From(DataSource.Database(db))) {
                // All user properties will be available here
            }
            // end::query-select-all[]

            // tag::live-query[]
            var query = QueryBuilder
                .Select(SelectResult.All())
                .From(DataSource.Database(db)); <i class="conum" data-value="6"></i><b>(6)</b>

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            var token = query.AddChangeListener((sender, args) =&gt; <i class="conum" data-value="7"></i><b>(7)</b>
            {
                var allResult = args.Results.AllResults();
                foreach (var result in allResult) {
                    Console.WriteLine(result.Keys);
                    /* Update UI */
                }
            });

            // end::live-query[]

            // tag::stop-live-query[]
            query.RemoveChangeListener(token);
            query.Dispose();
            // end::stop-live-query[]
        }

        private static void SelectWhere()
        {
            Console.WriteLine("Where");
            var db = _Database;

            // tag::query-where[]
            using (var query = QueryBuilder.Select(SelectResult.All())
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("hotel")))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    var dict = result.GetDictionary(db.Name);
                    Console.WriteLine($"Document Name :: {dict?.GetString("name")}");
                }
            }
            // end::query-where[]
        }

        private static void UseCollectionContains()
        {
            Console.WriteLine("Collection Operator CONTAINS");
            var db = _Database;

            // tag::query-collection-operator-contains[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"),
                    SelectResult.Property("public_likes"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("hotel"))
                    .And(ArrayFunction.Contains(Expression.Property("public_likes"),
                        Expression.String("Armani Langworth"))))) {
                foreach (var result in query.Execute()) {
                    var publicLikes = result.GetArray("public_likes");
                    var jsonString = JsonConvert.SerializeObject(publicLikes);
                    Console.WriteLine($"Public Likes :: {jsonString}");
                }
            }
            // end::query-collection-operator-contains[]
        }

        private static void UseCollectionIn()
        {
            Console.WriteLine("Collection Operator IN");
            var db = _Database;

            // tag::query-collection-operator-in[]
            var values = new IExpression[]
                { Expression.Property("first"), Expression.Property("last"), Expression.Property("username") };

            using (var query = QueryBuilder.Select(
                    SelectResult.All())
                .From(DataSource.Database(db))
                .Where(Expression.String("Armani").In(values))) {
                foreach (var result in query.Execute()) {
                    var body = result.GetDictionary(0);
                    var jsonString = JsonConvert.SerializeObject(body);
                    Console.WriteLine($"In results :: {jsonString}");
                }
            }
            // end::query-collection-operator-in[]
        }

        private static void SelectLike()
        {
            Console.WriteLine("Like");
            var db = _Database;

            // tag::query-like-operator[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Function.Lower(Expression.Property("name")).Like(Expression.String("Royal Engineers Museum"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-like-operator[]
        }

        private static void SelectWildcardLike()
        {
            Console.WriteLine("Wildcard Like");
            var db = _Database;

            // tag::query-like-operator-wildcard-match[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Function.Lower(Expression.Property("name")).Like(Expression.String("Eng%e%"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-like-operator-wildcard-match[]
        }

        private static void SelectWildcardCharacterLike()
        {
            Console.WriteLine("Wildchard Characters");
            var db = _Database;

            // tag::query-like-operator-wildcard-character-match[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Expression.Property("name").Like(Expression.String("Royal Eng____rs Museum"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-like-operator-wildcard-character-match[]
        }

        private static void SelectRegex()
        {
            Console.WriteLine("Regex");
            var db = _Database;

            // tag::query-regex-operator[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Expression.Property("name").Regex(Expression.String("\\bEng.*e\\b"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-regex-operator[]
        }

        private static void SelectJoin()
        {
            Console.WriteLine("Join");
            var db = _Database;

            // tag::query-join[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Expression.Property("name").From("airline")),
                    SelectResult.Expression(Expression.Property("callsign").From("airline")),
                    SelectResult.Expression(Expression.Property("destinationairport").From("route")),
                    SelectResult.Expression(Expression.Property("stops").From("route")),
                    SelectResult.Expression(Expression.Property("airline").From("route")))
                .From(DataSource.Database(db).As("airline"))
                .Join(Join.InnerJoin(DataSource.Database(db).As("route"))
                    .On(Meta.ID.From("airline").EqualTo(Expression.Property("airlineid").From("route"))))
                .Where(Expression.Property("type").From("route").EqualTo(Expression.String("route"))
                    .And(Expression.Property("type").From("airline").EqualTo(Expression.String("airline")))
                    .And(Expression.Property("sourceairport").From("route").EqualTo(Expression.String("RIX"))))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-join[]
        }

        private static void GroupBy()
        {
            Console.WriteLine("GroupBy");
            var db = _Database;

            // tag::query-groupby[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Function.Count(Expression.All())),
                    SelectResult.Property("country"),
                    SelectResult.Property("tz"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("airport"))
                    .And(Expression.Property("geo.alt").GreaterThanOrEqualTo(Expression.Int(300))))
                .GroupBy(Expression.Property("country"), Expression.Property("tz"))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine(
                        $"There are {result.GetInt("$1")} airports in the {result.GetString("tz")} timezone located in {result.GetString("country")} and above 300 ft");
                }
            }
            // end::query-groupby[]
        }

        private static void OrderBy()
        {
            Console.WriteLine("OrderBy");
            var db = _Database;

            // tag::query-orderby[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("title"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("hotel")))
                .OrderBy(Ordering.Property("title").Ascending())
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Title :: {result.GetString("title")}");
                }
            }
            // end::query-orderby[]
        }

      // ### EXPLAIN statement
      private static void TestExplainStatement()
      // For Documentation
      {
        var db = _Database;
          // tag::query-explain-all[]
        var query =
          QueryBuilder
            .Select(SelectResult.All())
            .From(DataSource.Database(db))
            .Where(Expression.Property("type").EqualTo(Expression.String("hotel")))
            .GroupBy(Expression.Property("country"))
            .OrderBy(Ordering.Property("title").Ascending()) <i class="conum" data-value="8"></i><b>(8)</b>

          Console.WriteLine(query.Explain()); <i class="conum" data-value="9"></i><b>(9)</b>

          // end::query-explain-all[]
          // tag::query-explain-like[]
var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Database(db))
    .Where(Expression.Property("type").Like(Expression.String("%hotel%"))
      .And(Function.Lower(Expression.Property("name")).Like(Expression.String("%royal%")))); <i class="conum" data-value="10"></i><b>(10)</b>
  Console.WriteLine(query.Explain());

          // end::query-explain-like[]
          // tag::query-explain-nopfx[]
var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Database(db))
    .Where(Expression.Property("type").Like(Expression.String("hotel%"))
      .And(Function.Lower(Expression.Property("name")).Like(Expression.String("%royal%")))); <i class="conum" data-value="11"></i><b>(11)</b>

  Console.WriteLine(query.Explain());

          // end::query-explain-nopfx[]
          // tag::query-explain-function[]
var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Database(db))
    .Where(Function.Lower(Expression.Property("type")).EqualTo(Expression.String("hotel"))); <i class="conum" data-value="12"></i><b>(12)</b>

  Console.WriteLine(query.Explain());

          // end::query-explain-function[]
          // tag::query-explain-nofunction[]
        var query =
          QueryBuilder
            .Select(SelectResult.All())
            .From(DataSource.Database(db))
            .Where(Expression.Property("type")).EqualTo(Expression.String("hotel")); <i class="conum" data-value="13"></i><b>(13)</b>

          Console.WriteLine(query.Explain());

          // end::query-explain-nofunction[]
      }

      // end query-explain


        public void CreateFullTextIndex()
        {
            // tag::fts-index[]
            string[] indexProperties = new string[] { "overview", "name" };
            var config = new FullTextIndexConfiguration(indexProperties);
            db.CreateIndex("overviewFTSIndex", config);
            // end::fts-index[]
        }

        public void FullTextSearch()
        {
            Console.WriteLine("Full text search");
            // tag::fts-query[]

            var db = _database;
            var ftsQuery = db.CreateQuery("SELECT * FROM _ WHERE MATCH(overviewFTSIndex, 'Michigan') ORDER BY RANK(overviewFTSIndex)");
            foreach (var result in ftsQuery.Execute())
            {
                Console.WriteLine($"Document id {result.GetString(0)}");
            }
            }
            // end::fts-query[]
        }


        private static void CreateFullTextIndex_Querybuilder()
        {
            // tag::fts-index_Querybuilder[]
            var db = _Database;

            // end::fts-index_Querybuilder[]
            if (_NeedsExtraDocs) {
                var tasks = new[] { "buy groceries", "play chess", "book travels", "buy museum tickets" };
                foreach (var task in tasks) {
                    using (var doc = new MutableDocument()) {
                        doc.SetString("type", "task");
                        doc.SetString("name", task);
                        db.Save(doc);
                    }
                }
            }

            // tag::fts-index_Querybuilder[]

            var index = IndexBuilder.FullTextIndex(FullTextIndexItem.Property("overview")).IgnoreAccents(false);
            db.CreateIndex("overviewFTSIndex", index);
            // end::fts-index_Querybuilder[]
        }

        private static void FullTextSearch_Querybuilder()
        {
            Console.WriteLine("Full text search");
            var db = _Database;

            // tag::fts-query_Querybuilder[]
            var whereClause = FullTextFunction.Match("overviewFTSIndex", "'michigan'");

            using (var query = QueryBuilder.Select(SelectResult.Expression(Meta.ID))
                .From(DataSource.Database(db))
                .Where(whereClause)) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Document id {result.GetString(0)}");
                }
            }
            // end::fts-query_Querybuilder[]
        }
        private static void StartReplication()
        {
            var db = _Database;

            /*
             * This requires Sync Gateway running with the following config, or equivalent:
             *
             * {
             *     "log":["*"],
             *     "databases": {
             *         "db": {
             *             "server":"walrus:",
             *             "users": {
             *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
             *             }
             *         }
             *     }
             * }
             */

            // tag::replication[]
            // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)
            var url = new Uri("ws://localhost:4984/db");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(db, target)
            {
                ReplicatorType = ReplicatorType.Pull
            };

            var replicator = new Replicator(config);
            replicator.Start();
            // end::replication[]

            _Replicator = replicator;
        }

        private static void VerboseReplicatorLogging()
        {
            // tag::replication-logging[]
            // deprecated
            Database.SetLogLevel(LogDomain.Replicator, LogLevel.Verbose);
            Database.SetLogLevel(LogDomain.Network, LogLevel.Verbose);
            // end::replication-logging[]
        }

        private static void ConsoleLogging()
        {
            // tag::console-logging[]
            Database.Log.Console.Domains = LogDomain.All; <i class="conum" data-value="14"></i><b>(14)</b>
            Database.Log.Console.LogLevel = LogLevel.Verbose; <i class="conum" data-value="15"></i><b>(15)</b>

            // end::console-logging[]

            // tag::console-logging-db[]
            Database.Log.Console.Domains = LogDomain.Database;

            // end::console-logging-db[]
        }

        private static void FileLogging()
        {
            // tag::file-logging[]
            var tempFolder = Path.Combine(Service.GetInstance&lt;IDefaultDirectoryResolver&gt;().DefaultDirectory(), "cbllog");
            var config = new LogFileConfiguration(tempFolder) <i class="conum" data-value="16"></i><b>(16)</b>
            {
                MaxRotateCount = 5, <i class="conum" data-value="17"></i><b>(17)</b>
                MaxSize = 10240, <i class="conum" data-value="18"></i><b>(18)</b>
                UsePlainText = false  <i class="conum" data-value="19"></i><b>(19)</b>
            };
            Database.Log.File.Config = config; // Apply configuration
            Database.Log.File.Level = LogLevel.Info; <i class="conum" data-value="20"></i><b>(20)</b>

            // end::file-logging[]
        }

        private static void EnableCustomLogging()
        {
            // tag::set-custom-logging[]
            Database.Log.Custom = new LogTestLogger(); <i class="conum" data-value="21"></i><b>(21)</b>
            or
            Database.Log.Custom = new LogTestLogger { Level = LogLevel.Warning };

            // end::set-custom-logging[]
        }

        private static void WriteConsoleLog()
        {
            // tag::write-console-logmsg[]
            Database.Log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
            // end::write-console-logmsg[]
        }
        private static void WriteCustomLog()
        {
            // tag::write-custom-logmsg[]
            Database.Log.Custom?.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
            // end::write-custom-logmsg[]
        }


        private static void WriteFileLog()
        {
            // tag::write-file-logmsg[]
            Database.Log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
            // end::write-file-logmsg[]
        }

        private static void EnableBasicAuth()
        {
            var database = _Database;

            // tag::basic-authentication[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.Authenticator = new BasicAuthenticator("john", "pass");

            var replicator = new Replicator(config);
            replicator.Start();
            // end::basic-authentication[]
        }

        private static void EnableSessionAuth()
        {
            var database = _Database;

            // tag::session-authentication[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.Authenticator = new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447");

            var replicator = new Replicator(config);
            replicator.Start();
            // end::session-authentication[]
        }

        private static void SetupReplicatorListener()
        {
            var replicator = _Replicator;

            // tag::replication-status[]
            replicator.AddChangeListener((sender, args) =&gt;
            {
                if (args.Status.Activity == ReplicatorActivityLevel.Stopped) {
                    Console.WriteLine("Replication stopped");
                }
            });
            // end::replication-status[]
        }




    //  BEGIN PendingDocuments IB -- 11/Feb/21 --
    private static void ReplicatorPendingDocuments()
    {
        // tag::replication-pendingdocuments[]
        var url = new Uri("ws://localhost:4984/mydatabase");
        var target = new URLEndpoint(url);
        var database = new Database("myDB");
        var config = new ReplicatorConfiguration(database, target);
        config.ReplicatorType  = ReplicatorType.Push;

        // tag::replication-push-pendingdocumentids[]
        var replicator = new Replicator(config);

        var mydocids =
          new HashSet &lt;string&gt; (replicator.GetPendingDocumentIDs()); <i class="conum" data-value="22"></i><b>(22)</b>

        // end::replication-push-pendingdocumentids[]

        if (mydocids.Count &gt; 0)
        {
            Console.WriteLine($"There are {mydocids.Count} documents pending");
            replicator.AddChangeListener((sender, change) =&gt;
            {
                Console.WriteLine($"Replicator activity level is " +
                                  change.Status.Activity.ToString());
                // iterate and report-on previously
                // retrieved pending docids 'list'
                foreach (var thisId in mydocids)
                    // tag::replication-push-isdocumentpending[]
                    if (!replicator.IsDocumentPending(thisId)) <i class="conum" data-value="23"></i><b>(23)</b>
                    {
                        Console.WriteLine($"Doc ID {thisId} now pushed");
                    };
                // end::replication-push-isdocumentpending[]
            });

            replicator.Start();
        }
    // end::replication-pendingdocuments[]
    }


//  END PendingDocuments IB -- 11/Feb/21 --



		private static void ReplicatorDocumentEvent()
        {
            var replicator = _Replicator;

            // tag::add-document-replication-listener[]
            var token = replicator.AddDocumentReplicationListener((sender, args) =&gt;
            {
                var direction = args.IsPush ? "Push" : "Pull";
                Console.WriteLine($"Replication type :: {direction}");
                foreach (var document in args.Documents) {
                    if (document.Error == null) {
                        Console.WriteLine($"Doc ID :: {document.Id}");
                        if (document.Flags.HasFlag(DocumentFlags.Deleted)) {
                            Console.WriteLine("Successfully replicated a deleted document");
                        }
                    } else {
                        // There was an error
                    }
                }
            });

            replicator.Start();
            // end::add-document-replication-listener[]

            // tag::remove-document-replication-listener[]
            replicator.RemoveChangeListener(token);
            // end::remove-document-replication-listener[]
        }

        private static void SetupReplicatorErrorListener()
        {
            // This can be done in the SetupReplicatorListener method
            // But it is separate so that we can have two documentation entries

            var replicator = _Replicator;

            // tag::replication-error-handling[]
            replicator.AddChangeListener((sender, args) =&gt;
            {
                if (args.Status.Error != null) {
                    Console.WriteLine($"Error :: {args.Status.Error}");
                }
            });
            // end::replication-error-handling[]
        }

        private static void DatabaseReplica()
        {
            var db = _Database;
            using (var database2 = new Database("backup")) {
                // EE feature: This code will not compile on the community edition
                // tag::database-replica[]
                var targetDatabase = new DatabaseEndpoint(database2);
                var config = new ReplicatorConfiguration(db, targetDatabase)
                {
                    ReplicatorType = ReplicatorType.Push
                };

                var replicator = new Replicator(config);
                replicator.Start();
                // end::database-replica[]

                _Replicator?.Stop();
                _Replicator = replicator;
            }
        }

        private static void PinCertificate()
        {
            // Note: No certificate is included here, so this code is for show only
            var url = new Uri("wss://localhost:4984/db");
            var target = new URLEndpoint(url);
            var db = _Database;

            // tag::certificate-pinning[]
            // Note: `GetCertificate` is a fake method. This would be the platform-specific method
            // to find and load the certificate as an instance of `X509Certificate2`.
            // For .NET Core / .NET Framework this can be loaded from the filesystem path.
            // For UWP, from the assets directory.
            // For iOS, from the main bundle.
            // For Android, from the assets directory.
            var certificate = GetCertificate("cert.cer");
            var config = new ReplicatorConfiguration(db, target)
            {
                PinnedServerCertificate = certificate
            };
            // end::certificate-pinning[]
        }

        private static void ReplicationCustomHeaders()
        {
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            // tag::replication-custom-header[]
            var config = new ReplicatorConfiguration(database, target)
            {
                Headers = new Dictionary&lt;string, string&gt;
                {
                    ["CustomHeaderName"] = "Value"
                }
            };
            // end::replication-custom-header[]
        }

        private static void PushWithFilter(Database database)
        {
            // tag::replication-push-filter[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            var config = new ReplicatorConfiguration(database, target);
            config.PushFilter = (document, flags) =&gt; <i class="conum" data-value="1"></i><b>(1)</b>
            {
                if (flags.HasFlag(DocumentFlags.Deleted)) {
                    return false;
                }

                return true;
            };

            // Dispose() later
            var replicator = new Replicator(config);
            replicator.Start();
            // end::replication-push-filter[]
        }

        private static void PullWithFilter(Database database)
        {
            // tag::replication-pull-filter[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            var config = new ReplicatorConfiguration(database, target);
            config.PullFilter = (document, flags) =&gt; <i class="conum" data-value="1"></i><b>(1)</b>
            {
                if (document.GetString("type") == "draft") {
                    return false;
                }

                return true;
            };

            // Dispose() later
            var replicator = new Replicator(config);
            replicator.Start();
            // end::replication-pull-filter[]
        }

        public void TestCustomRetryConfig()
        {
        // tag::replication-retry-config[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            var config = new ReplicatorConfiguration(database, target);

        //  other config as required . . .

        // tag::replication-set-heartbeat[]
            config.Heartbeat = TimeSpan.FromSeconds(120); //  <i class="conum" data-value="24"></i><b>(24)</b>
        // end::replication-set-heartbeat[]
        // tag::replication-set-maxattempts[]
            config.Maxattempts = 20; //  <i class="conum" data-value="25"></i><b>(25)</b>
        // end::replication-set-maxattempts[]
        // tag::replication-set-maxattemptwaittime[]
            config.MaxAttemptWaitTime = TimeSpan.FromSeconds(600); //  <i class="conum" data-value="26"></i><b>(26)</b>
        // end::replication-set-maxattemptwaittime[]

        //  other config as required . . .

            var repl = new Replicator(config);

        // end::replication-retry-config[]
        }


        private static void UsePredictiveModel()
        {
            using (var db = new Database("mydb")) {
                // tag::register-model[]
                var model = new ImageClassifierModel();
                Database.Prediction.RegisterModel("ImageClassifier", model);
                // end::register-model[]

                // tag::predictive-query-value-index[]
                var index = IndexBuilder.ValueIndex(ValueIndexItem.Property("label"));
                db.CreateIndex("value-index-image-classifier", index);
                // end::predictive-query-value-index[]

                // tag::unregister-model[]
                Database.Prediction.UnregisterModel("ImageClassifier");
                // end::unregister-model[]
            }
        }

        private static void UsePredictiveIndex()
        {
            using (var db = new Database("mydb")) {
                // tag::predictive-query-predictive-index[]
                var input = Expression.Dictionary(new Dictionary&lt;string, object&gt;
                {
                    ["photo"] = Expression.Property("photo")
                });

                var index = IndexBuilder.PredictiveIndex("ImageClassifier", input);
                db.CreateIndex("predictive-index-image-classifier", index);
                // end::predictive-query-predictive-index[]
            }
        }

        private static void DoPredictiveQuery()
        {
            using (var db = new Database("mydb")) {
                // tag::predictive-query[]
                var input = Expression.Dictionary(new Dictionary&lt;string, object&gt;
                {
                    ["photo"] = Expression.Property("photo")
                });
                var prediction = PredictiveModel.predict("ImageClassifier", input); <i class="conum" data-value="1"></i><b>(1)</b>

                using (var q = QueryBuilder.Select(SelectResult.All())
                    .From(DataSource.Database(db))
                    .Where(prediction.Property("label").EqualTo(Expression.String("car"))
                        .And(prediction.Property("probability").GreaterThanOrEqualTo(Expression.Double(0.8))))) {
                    var result = q.Execute();
                    Console.WriteLine($"Number of rows: {result.Count()}");
                }
                // end::predictive-query[]
            }
        }

        static void Main(string[] args)
        {
            // This only needs to be done once for whatever platform the executable is running
            // (UWP, iOS, Android, or desktop)
            Couchbase.Lite.Support.NetDesktop.Activate();

            CreateNewDatabase();
            CreateDocument();
            UpdateDocument();
            UseTypedAccessors();
            DoBatchOperation();
            UseBlob();
            SelectMeta();

            LoadPrebuilt();
            CreateIndex();
            SelectWhere();
            UseCollectionContains();
            SelectLike();
            SelectWildcardLike();
            SelectWildcardCharacterLike();
            SelectRegex();
            SelectJoin();
            GroupBy();
            OrderBy();

            CreateFullTextIndex();
            FullTextSearch();
            StartReplication();
            SetupReplicatorListener();

            _Replicator.Stop();
            while (_Replicator.Status.Activity != ReplicatorActivityLevel.Stopped) {
                // Database cannot close until replicators are stopped
                Console.WriteLine($"Waiting for replicator to stop (currently {_Replicator.Status.Activity})...");
                Thread.Sleep(200);
            }

            _Database.Close();
        }

        #endregion
    }

    /* ----------------------------------------------------------- */
    /* ---------------------  ACTIVE SIDE  ----------------------- */
    /* ---------------  stubs for documentation  ----------------- */
    /* ----------------------------------------------------------- */

    class ActivePeer : IMessageEndpointDelegate
    {
        ActivePeer()
        {
            var id = "";

            // tag::message-endpoint[]
            var database = new Database("dbname");

            // The delegate must implement the `IMessageEndpointDelegate` protocol.
            var messageEndpointTarget = new MessageEndpoint(uid: "UID:123", target: "",
                protocolType: ProtocolType.MessageStream, delegateObject: this);
            // end::message-endpoint[]

            // tag::message-endpoint-replicator[]
            var config = new ReplicatorConfiguration(database, messageEndpointTarget);

            // Create the replicator object
            var replicator = new Replicator(config);
            // Start the replicator
            replicator.Start();
            // end::message-endpoint-replicator[]
        }

        // tag::create-connection[]
        /* implementation of MessageEndpointDelegate */
        public IMessageEndpointConnection CreateConnection(MessageEndpoint endpoint)
        {
            var connection = new ActivePeerConnection(); /* implements MessageEndpointConnection */
            return connection;
        }
        // end::create-connection[]
    }

    class ActivePeerConnection : IMessageEndpointConnection
    {
        private IReplicatorConnection _replicatorConnection;

        public void Disconnect()
        {
            // tag::active-replicator-close[]
            _replicatorConnection?.Close(null);
            // end::active-replicator-close[]
        }

        public void Receive(byte[] data)
        {
            // tag::active-peer-receive[]
            var message = Message.FromBytes(data);
            _replicatorConnection?.Receive(message);
            // end::active-peer-receive[]
        }

        // tag::active-peer-close[]
        /* implementation of MessageEndpointConnection */
        public async Task Close(Exception error)
        {
            // await socket.Close, etc (or do nothing if already closed)
            // throw MessagingException if something goes wrong (though
            // since it is "close" nothing special will happen)
        }
        // end::active-peer-close[]

        // tag::active-peer-open[]
        /* implementation of MessageEndpointConnection */
        public async Task Open(IReplicatorConnection connection)
        {
            _replicatorConnection = connection;
            // await socket.Open(), etc
            // throw MessagingException if something goes wrong
        }
        // end::active-peer-open[]

        // tag::active-peer-send[]
        /* implementation of MessageEndpointConnection */
        public async Task Send(Message message)
        {
            var data = message.ToByteArray();
            // await Socket.Send(), etc
            // throw MessagingException if something goes wrong
        }
        // end::active-peer-send[]
    }

    /* ----------------------------------------------------------- */
    /* ---------------------  PASSIVE SIDE  ---------------------- */
    /* ---------------  stubs for documentation  ----------------- */
    /* ----------------------------------------------------------- */
    class PassivePeerConnection : IMessageEndpointConnection
    {
        private MessageEndpointListener _messageEndpointListener;
        private IReplicatorConnection _replicatorConnection;

        public void StartListener()
        {
            // tag::listener[]
            var database = new Database("mydb");
            var config = new MessageEndpointListenerConfiguration(database, ProtocolType.MessageStream);
            _messageEndpointListener = new MessageEndpointListener(config);
            // end::listener[]
        }

        public void StopListener()
        {
            // tag::passive-stop-listener[]
            _messageEndpointListener?.CloseAll();
            // end::passive-stop-listener[]
        }

        public void AcceptConnection()
        {
            // tag::advertizer-accept[]
            var connection = new PassivePeerConnection(); /* implements MessageEndpointConnection */
            _messageEndpointListener?.Accept(connection);
            // end::advertizer-accept[]
        }

        public void Disconnect()
        {
            // tag::passive-replicator-close[]
            _replicatorConnection?.Close(null);
            // end::passive-replicator-close[]
        }

        public void Receive(byte[] data)
        {
            // tag::passive-peer-receive[]
            var message = Message.FromBytes(data);
            _replicatorConnection?.Receive(message);
            // end::passive-peer-receive[]
        }

        // tag::passive-peer-close[]
        /* implementation of MessageEndpointConnection */
        public async Task Close(Exception error)
        {
            // await socket.Close, etc (or do nothing if already closed)
            // throw MessagingException if something goes wrong (though
            // since it is "close" nothing special will happen)
        }
        // end::passive-peer-close[]

        // tag::passive-peer-open[]
        /* implementation of MessageEndpointConnection */
        public Task Open(IReplicatorConnection connection)
        {
            _replicatorConnection = connection;
            // socket should already be open on the passive side
            return Task.FromResult(true);
        }
        // end::passive-peer-open[]

        // tag::passive-peer-send[]
        /* implementation of MessageEndpointConnection */
        public async Task Send(Message message)
        {
            var data = message.ToByteArray();
            // await Socket.Send(), etc
            // throw MessagingException if something goes wrong
        }
        // end::passive-peer-send[]
    }

    // tag::predictive-model[]
    // tensorFlowModel is a fake implementation
    // this would be the implementation of the ml model you have chosen
    class TensorFlowModel
    {
        public static IDictionary&lt;string, object&gt; PredictImage(byte[] data)
        {
            // Do calculations, etc
            return null;
        }
    }

    class ImageClassifierModel : IPredictiveModel
    {
        public DictionaryObject Predict(DictionaryObject input)
        {
            var blob = input.GetBlob("photo");
            if (blob == null) {
                return null;
            }

            var imageData = blob.Content;
            // tensorFlowModel is a fake implementation
            // this would be the implementation of the ml model you have chosen
            var modelOutput = TensorFlowModel.PredictImage(imageData);
            return new MutableDictionaryObject(modelOutput); <i class="conum" data-value="1"></i><b>(1)</b>
        }
    }
    // end::predictive-model[]

    // tag::custom-logging[]
    private class LogTestLogger : ILogger
    {
        public LogLevel Level { get; set; }

        public void Reset()
        {
            _lines.Clear();
        }

        public void Log(LogLevel level, LogDomain domain, string message)
        {
            // handle the message, for example piping it to
            // a third party framework
        }
    }
    // end::custom-logging[]

    // tag::local-win-conflict-resolver[]
    class LocalWinConflictResolver : IConflictResolver
    {
        Document Resolve(Conflict conflict)
        {
            return conflict.LocalDocument;
        }
    }
    // end::local-win-conflict-resolver[]

    // tag::remote-win-conflict-resolver[]
    class RemoteWinConflictResolver : IConflictResolver
    {
        public Document Resolve(Conflict conflict)
        {
            return conflict.RemoteDocument;
        }
    }
    // end::remote-win-conflict-resolver[]

    // tag::merge-conflict-resolver[]
    class MergeConflictResolver : IConflictResolver
    {
        public Document Resolve(Conflict conflict)
        {
            var localDict = conflict.LocalDocument.ToDictionary();
            var remoteDict = conflict.RemoteDocument.ToDictionary();
            var result = localDict.Concat(remoteDict)
               .GroupBy(kv =&gt; kv.Key)
               .ToDictionary(g =&gt; g.Key, g =&gt; g.First().Value);
            return new MutableDocument(conflict.DocumentID, result);
        }
    }
    // end::merge-conflict-resolver[]
}

// N1QL QUERY

  public List&lt;Result&gt; docsonly_N1QLQueryString(Database argDB)
  {
      DatabaseConfiguration dbCfg = new DatabaseConfiguration();

      Database thisDb = new Database(dbName, dbCfg);

      // For Documentation -- N1QL Query
      // tag::query-syntax-n1ql[]
      var thisQuery =
          thisDb.CreateQuery("SELECT META().id AS thisId FROM _ WHERE type = \"hotel\""); <i class="conum" data-value="27"></i><b>(27)</b>

      return thisQuery.Execute().AllResults();

      // end::query-syntax-n1ql[]
  }


  public  List&lt;Result&gt; docsonly_N1QLQueryStringParams(Database argDB)
  {
      DatabaseConfiguration dbCfg = new DatabaseConfiguration();

      Database thisDb = new Database(dbName, dbCfg);

      // For Documentation -- N1QL Query
      // tag::query-syntax-n1ql-params[]
      // Declared elsewhere: Database argDB

      var thisQuery =
          thisDb.CreateQuery("SELECT META().id AS thisId FROM _ WHERE type = $type"); <i class="conum" data-value="28"></i><b>(28)</b>

      var n1qlParams = new Parameters();
      n1qlParams.SetString("type", "hotel"); <i class="conum" data-value="29"></i><b>(29)</b>
      thisQuery.Parameters = n1qlParams;

      return thisQuery.Execute().AllResults();

      // end::query-syntax-n1ql-params[]
  }


// QUERY RESULT SET HANDLING EXAMPLES

    public static void testQuerySyntaxAll()
    {
        // For Documentation
        var dbName = "travel-sample";

        string thisDocsId;
        string thisDocsName;
        string thisDocsType;
        string thisDocsCity;
        Dictionary&lt;string,object&gt; hotel = new Dictionary&lt;string,object&gt;();

        // tag::query-syntax-all[]
        var this_Db = new Database("hotels") ;

        var query = QueryBuilder
              .Select(SelectResult.All())
              .From(DataSource.Database(this_Db));

        // end::query-syntax-all[]

        // tag::query-access-all[]
        var results = query.Execute().AllResults();

        if (results?.Count &gt; 0)
        {
            List&lt;Dictionary&lt;string,object&gt;&gt; hotels = new List&lt;Dictionary&lt;string,object&gt;&gt;();
            foreach (var result in results)
            {
                // get the result into our dictionary object
                var thisDocsProps = result.GetDictionary(dbName); <i class="conum" data-value="30"></i><b>(30)</b>

                if (thisDocsProps != null)
                {
                    thisDocsId = thisDocsProps.GetString("id"); <i class="conum" data-value="31"></i><b>(31)</b>
                    thisDocsName = thisDocsProps.GetString("name");
                    thisDocsCity = thisDocsProps.GetString("city");
                    thisDocsType = thisDocsProps.GetString("type");
                    hotel = thisDocsProps.ToDictionary();
                    hotels.Add(hotel);
                }

            }
        }
        // end::query-access-all[]

    // tag::query-access-json[]

    foreach (var result in query.Execute().AsEnumerable()) {

        // get the result into a JSON String
                var thisDocsJSONString = result.ToJSON();<i class="conum" data-value="32"></i><b>(32)</b>

        // Get a native dictionary object using the JSON string
        var dictFromJSONstring =
              JsonConvert.
                DeserializeObject&lt;Dictionary&lt;string, object&gt;&gt;
                  (thisDocsJSONString); <i class="conum" data-value="33"></i><b>(33)</b>

        // use the created dictionary
        if (dictFromJSONstring != null)
        {
            thisDocsId = dictFromJSONstring["id"].ToString();
            thisDocsName = dictFromJSONstring["name"].ToString();
            thisDocsCity = dictFromJSONstring["city"].ToString();
            thisDocsType = dictFromJSONstring["type"].ToString();
        }

        //Get a custom object using the JSON string
        Hotel this_hotel =
            JsonConvert.DeserializeObject&lt;Hotel&gt;(thisDocsJSONString); <i class="conum" data-value="34"></i><b>(34)</b>

        // Store this hotel object in a list of hotels
        hotels.Add(
            this_hotel.Id.ToString(),
                this_hotel);

    } // end foreach result
    // end::query-access-json[]
  }


    private static void testQuerySyntaxProps()
    {
        // For Documentation
        var dbName = "travel-sample";
        // var this_Db = new Database(dbName);

        string thisDocsName;
        string thisDocsType;
        string thisDocsCity;
        // tag::query-syntax-props[]
        var this_Db = new Database("hotels") ;

        Dictionary&lt;string, object&gt; hotel = new Dictionary&lt;string, object&gt;();

        List&lt;Dictionary&lt;string, object&gt;&gt; hotels = new List&lt;Dictionary&lt;string, object&gt;&gt;();

        var query = QueryBuilder.Select(
                SelectResult.Property("type"),
                SelectResult.Property("name"),
                SelectResult.Property("city")).From(DataSource.Database(this_Db));
        // end::query-syntax-props[]

        // tag::query-access-props[]
        var results = query.Execute().AllResults();
        foreach (var result in results)
        {

            // get the returned array of k-v pairs into a dictionary
            hotel = result.ToDictionary();

            // add hotel dictionary to list of hotel dictionaries
            hotels.Add(hotel);

            // use the properties of the returned array of k-v pairs directly
            thisDocsType = result.GetString("type");
            thisDocsName = result.GetString("name");
            thisDocsCity = result.GetString("city");

        }

    // end::query-access-props[]
    } // test-query-access-props



    private static void testQuerySyntaxCount()
    {
        // For Documentation
        var dbName = "travel-sample";
        // var this_Db = new Database(dbName);

        Dictionary&lt;string, object&gt; hotel = new Dictionary&lt;string, object&gt;();
        List&lt;Dictionary&lt;string, object&gt;&gt; hotels = new List&lt;Dictionary&lt;string, object&gt;&gt;();

        // tag::query-syntax-count-only[]
        var this_Db = new Database("hotels") ;

        var query =
          QueryBuilder
            .Select(SelectResult.Expression(Function.Count(Expression.All())).As("mycount")) <i class="conum" data-value="35"></i><b>(35)</b>
            .From(DataSource.Database(this_Db));

        // end::query-syntax-count-only[]


        // tag::query-access-count-only[]

        var results = query.Execute().AllResults();

        foreach (var result in results)
        {

            var numberOfDocs = result.GetInt("mycount"); <i class="conum" data-value="36"></i><b>(36)</b>

        }

        // end::query-access-count-only[]
    }




    private static void ibQueryForID()
    {

        // For Documentation
        var dbName = "travel-sample";
        // var this_Db = new Database(dbName);

        Dictionary&lt;string, object&gt; hotel = new Dictionary&lt;string, object&gt;();
        List&lt;Dictionary&lt;string, object&gt;&gt; hotels = new List&lt;Dictionary&lt;string, object&gt;&gt;();


        // tag::query-syntax-id[]
        var this_Db = new Database("hotels") ;

        var query = QueryBuilder
                .Select(SelectResult.Expression(Meta.ID).As("this_ID"))
                .From(DataSource.Database(this_Db));

        // end::query-syntax-id[]


        // tag::query-access-id[]
        var results = query.Execute().AllResults();
        foreach (var result in results)
        {

            var thisDocsID = result.GetString("this_ID"); <i class="conum" data-value="37"></i><b>(37)</b>
            var doc = this_Db.GetDocument(thisDocsID);
        }

        // end::query-access-id[]
    }


// tag::query-syntax-pagination-all[]
    private static void testQueryPagination()
    {
      // For Documentation
      var dbName = "travel-sample";
      // var this_Db = new Database(dbName);

    // tag::query-syntax-pagination[]
      var this_Db = new Database("hotels") ;

      var thisLimit = 20;
      var thisOffset = 0;

      // get a count of the number of docs matching the query
      var countQuery =
          QueryBuilder
              .Select(SelectResult.Expression(Function.Count(Expression.All())).As("mycount"))
              .From(DataSource.Database(this_Db));
      var numberOfDocs =
          countQuery.Execute().AllResults().ElementAt(0).GetInt("mycount");

      if (numberOfDocs &lt; thisLimit) {
          thisLimit = numberOfDocs;
      }

      while (thisOffset &lt; numberOfDocs)
      {
          var listQuery =
              QueryBuilder
                  .Select(SelectResult.All())
                  .From(DataSource.Database(this_Db))
                  .Limit(Expression.Int(thisLimit), Expression.Int(thisOffset)); <i class="conum" data-value="38"></i><b>(38)</b>

          foreach (var result in listQuery.Execute().AllResults())
          {
              // Display and or process query results batch

          }

          thisOffset = thisOffset + thisLimit;

      } // end while

// end::query-syntax-pagination[]
// end::query-syntax-pagination-all[]
    }

    // JSONAPIMETHODS



        public void JsonApiDocument()
        {

            // tag::tojson-document[]
            Database this_DB = new Database("travel-sample");
            Database newDb = new Database("ournewdb");

            // Get a document
            var thisDoc = this_Db.GetDocument("hotel_10025");

            // Get document data as JSON String
            var thisDocAsJsonString = thisDoc?.ToJSON(); <i class="conum" data-value="39"></i><b>(39)</b>

            // Get Json Object from the Json String
            JObject myJsonObj = JObject.Parse(thisDocAsJsonString);

            // Get Native Object (anhotel) from JSON String
            List&lt;Hotel&gt; thehotels = new List&lt;Hotel&gt;();

            Hotel anhotel = new Hotel();
            anhotel = JsonConvert.DeserializeObject&lt;Hotel&gt;(thisDocAsJsonString);
            thehotels.Add(anhotel);

            // Update the retrieved native object
            anhotel.Name = "A Copy of " + anhotel.Name;
            anhotel.Id = "2001";

            // Convert the updated object back to a JSON string
            var newJsonString = JsonConvert.SerializeObject(anhotel);

            // Update new document with JSOn String
            MutableDocument newhotel =
                new MutableDocument(anhotel.Id, newJsonString); <i class="conum" data-value="40"></i><b>(40)</b>

            foreach (string key in newhotel.ToDictionary().Keys)
            {
                System.Console.WriteLine("Data -- {0} = {1}",
                    key, newhotel.GetValue(key));
            }

            newDb.Save(newhotel);

            var thatDoc = newDb.GetDocument("2001").ToJSON(); <i class="conum" data-value="41"></i><b>(41)</b>
            System.Console.Write(thatDoc);

            // end::tojson-document[]


        //    // tag::tojson-document-output[]
        //    JSON String = { "description":"Very good and central","id":"1000","country":"France","name":"Hotel Ted","type":"hotel","city":"Paris"}
        //             type = hotel
        //             id = 1000
        //             country = France
        //             city = Paris
        //             description = Very good and central
        //             name = Hotel Ted
        //        // end::tojson-document-output[]
        //         */

        } // End JSONAPIDocument


    public void JsonApiArray()
        {
            // Init for docs
            //var this_Db = DataStore.getDbHandle();
            var ourdbname = "ournewdb";

            if (Database.Exists(ourdbname, "/"))
            {
                Database.Delete(ourdbname, "/");
            }

        // tag::tojson-array[]

            Database dbNew = new Database(ourdbname);

            // JSON String -- an Array (3 elements. including embedded arrays)
            var thisJSONstring = "[{'id':'1000','type':'hotel','name':'Hotel Ted','city':'Paris','country':'France','description':'Undefined description for Hotel Ted'},{'id':'1001','type':'hotel','name':'Hotel Fred','city':'London','country':'England','description':'Undefined description for Hotel Fred'},                        {'id':'1002','type':'hotel','name':'Hotel Ned','city':'Balmain','country':'Australia','description':'Undefined description for Hotel Ned','features':['Cable TV','Toaster','Microwave']}]".Replace("'", "\"");

            // Get JSON Array from JSON String
            JArray myJsonObj = JArray.Parse(thisJSONstring);

            // Create mutable array using JSON String Array
            var myArray = new MutableArrayObject();
            myArray.SetJSON(thisJSONstring);  <i class="conum" data-value="42"></i><b>(42)</b>


            // Create a new documenty for each array element
            for (int i = 0; i &lt; myArray.Count; i++)
            {
                var dict = myArray.GetDictionary(i);
                var docid = myArray[i].Dictionary.GetString("id");
                var newdoc = new MutableDocument(docid, dict.ToDictionary()); <i class="conum" data-value="43"></i><b>(43)</b>
                dbNew.Save(newdoc);
            }

            // Get one of the created docs and iterate through one of the embedded arrays
            var extendedDoc = dbNew.GetDocument("1002");
            var features = extendedDoc.GetArray("features");
            <i class="conum" data-value="44"></i><b>(44)</b>
            foreach (string feature in features) {
                System.Console.Write(feature);
                //process array item as required
            }
            var featuresJSON = extendedDoc.GetArray("features").ToJSON(); <i class="conum" data-value="45"></i><b>(45)</b>

            // end::tojson-array[]
        }


        public void JsonApiDictionary()
        {

            var ourdbname = "ournewdb";

            if (Database.Exists(ourdbname, "/"))
            {
                Database.Delete(ourdbname, "/");
            }
            Database dbNew = new Database(ourdbname);

            // tag::tojson-dictionary[]

            // Get dictionary from JSONstring
            var aJSONstring = "{'id':'1002','type':'hotel','name':'Hotel Ned','city':'Balmain','country':'Australia','description':'Undefined description for Hotel Ned','features':['Cable TV','Toaster','Microwave']}".Replace("'", "\"");
            var myDict = new MutableDictionaryObject(json: aJSONstring); <i class="conum" data-value="46"></i><b>(46)</b>

            // use dictionary to get name value
            var name = myDict.GetString("name");


            // Iterate through keys
            foreach (string key in myDict.Keys)
            {
                System.Console.WriteLine("Data -- {0} = {1}", key, myDict.GetValue(key).ToString());

            }
            // end::tojson-dictionary[]

            /*
            // tag::tojson-dictionary-output[]

                mono-stdout: Data -- id = 1002
                mono-stdout: Data -- type = hotel
                mono-stdout: Data -- name = Hotel Ned
                mono-stdout: Data -- city = Balmain
                mono-stdout: Data -- country = Australia
                mono-stdout: Data -- description = Undefined description for Hotel Ned
                mono-stdout: Data -- features = Couchbase.Lite.MutableArrayObject

            // end::tojson-dictionary-output[]
            */
        } /* end of func */


         public void JsonApiBlob()
        {
            // Init
            var ourpath = DataStore.getUserFolder();
            var ourdbname = "ournewdb";
            var userName = "ian";
            //ourpath = Path.Combine(ourpath,userName);

            if (Database.Exists(ourdbname, ourpath))
            {
                Database.Delete(ourdbname, ourpath);
            }
            var dbCfg = new DatabaseConfiguration();
            dbCfg.Directory=ourpath;
            Database dbNew = new Database(ourdbname,dbCfg);

            // tag::tojson-blob[]

            // Initialize base document for blob from a JSON string
            var docId = "1002";
            var aJSONstring = "{'ref':'hotel_1002','type':'hotel','name':'Hotel Ned'," +
                "'city':'Balmain','country':'Australia'," +
                "'description':'Undefined description for Hotel Ned'," +
                "'features':['Cable TV','Toaster','Microwave']}".Replace("'", "\"");
            var myDoc = new MutableDocument(docId, aJSONstring); <i class="conum" data-value="47"></i><b>(47)</b>


            // Get the content (an image), create blob and add to doc)
            var defaultDirectory =
                Path.Combine(Service.GetInstance&lt;IDefaultDirectoryResolver&gt;()
                            .DefaultDirectory(),
                                userName);
            var myImagePath = Path.Combine(defaultDirectory, "avatarimage.jpg");
            var myImageUri = new Uri(myImagePath.ToString());
            var myBlob = new Blob("image/jpg", myImageUri); <i class="conum" data-value="48"></i><b>(48)</b>
            myDoc.SetBlob("avatar", myBlob); <i class="conum" data-value="49"></i><b>(49)</b>


            // This example generates a 'blob not saved' exception
            try { Console.WriteLine("myBlob (unsaved) as JSON = {0}", myBlob.ToJSON());}
                catch (Exception e)
                    {Console.WriteLine("Exception = {0}", e.Message);}

            dbNew.Save(myDoc);

            // Alternatively -- depending on use case
            dbNew.SaveBlob(new Blob("image/jpg", myImageUri)); <i class="conum" data-value="50"></i><b>(50)</b>


            // Retrieve saved doc, get blob as JSON andheck its still a 'blob'
            var sameDoc = dbNew.GetDocument(docId);
            var reconstitutedBlob = new MutableDictionaryObject().
                SetDictionary("blobCOPY", new MutableDictionaryObject(sameDoc.GetBlob("avatar").ToJSON())); <i class="conum" data-value="51"></i><b>(51)</b>

            if (Blob.IsBlob(
                    reconstitutedBlob.GetDictionary("blobCOPY").ToDictionary()))  <i class="conum" data-value="52"></i><b>(52)</b>
            {
               //... process accordingly
               Console.WriteLine("Its a Blob!!");
            }

            // end::tojson-blob[]
            var datavalue = "";
            foreach (string key in myDoc.Keys)
            {
                if (key == "features")
                {
                    datavalue = "features are: ";
                    foreach (string item in myDoc.GetArray(key))
                    {
                        datavalue = datavalue + ", " + item;
                    }
                }
                else if (key == "avatar")
                {
                    datavalue = sameDoc.GetBlob(key).ToJSON();
                }
                else
                {
                    datavalue = sameDoc.GetValue(key).ToString();
                }

                System.Console.WriteLine(" Data -- {0} = {1}", key, datavalue);
            }

            // System.Console.WriteLine(" reconstitutedBlob = {0}", reconstitutedBlob.GetDictionary("blobCOPY").ToJSON());



            //}

            /*
            // tag::tojson-blob-output[]


                Exception = Missing Digest Due To Blob Is Not Saved To Database yet.

                Data -- id = 1002
                Data -- type = hotel
                Data -- name = Hotel Ned
                Data -- city = Balmain
                Data -- country = Australia
                Data -- description = Undefined description for Hotel Ned
                Data -- features = features are: , Cable TV, Toaster, Microwave
                Data -- avatar = {"digest":"sha1-sdCxeOeP3IZV4FEvVVlvtulpWA8=","length":2975,"content_type":"image/jpg","@type":"blob"}

                blobAsJSONstring = {"digest":"sha1-sdCxeOeP3IZV4FEvVVlvtulpWA8=","length":2975,"content_type":"image/jpg","@type":"blob"}

            // end::tojson-blob-output[]
            */
        } /* end of func */




  } // end of class



// p2p sync items


// tag::listener-simple[]
var thisConfig = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="53"></i><b>(53)</b>

thisConfig.Authenticator =
  new ListenerPasswordAuthenticator(
    (sender, username, password) =&gt;
      {
      return username.equals("valid.user")  &amp;&amp; (password == validPassword);
      }
  ); <i class="conum" data-value="54"></i><b>(54)</b>

_thisListener = new URLEndpointListener(thisConfig); <i class="conum" data-value="55"></i><b>(55)</b>

_thisListener.Start(); <i class="conum" data-value="56"></i><b>(56)</b>

// end::listener-simple[]



// tag::replicator-simple[]
var theListenerEndpoint = new URLEndpoint("wss://listener.com:4984/otherDB"); <i class="conum" data-value="57"></i><b>(57)</b>

var thisConfig = new ReplicatorConfiguration(thisDB, theListenerEndpoint); <i class="conum" data-value="58"></i><b>(58)</b>

thisConfig.AcceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="59"></i><b>(59)</b>

thisConfig.Authenticator =
  new BasicAuthenticator("valid.user", "valid.password.string"); <i class="conum" data-value="60"></i><b>(60)</b>

var thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="61"></i><b>(61)</b>

thisReplicator.Start(); <i class="conum" data-value="62"></i><b>(62)</b>

// end::replicator-simple[]







// PASSIVE PEER STUFF
// Stuff I adapted
//
//
// p2pSync-websockets.cs
//
// Copyright (c) 2017 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;

using Couchbase.Lite;
using Couchbase.Lite.Enterprise.Query;
using Couchbase.Lite.Logging;
using Couchbase.Lite.P2P;
using Couchbase.Lite.Query;
using Couchbase.Lite.Sync;
using Newtonsoft.Json;

using SkiaSharp;
namespace api_walkthrough
{
  class Program
  {
  private static Database _Database;
  private static Replicator _Replicator;
  private static ListenerToken _thisListenerToken;
  private static bool _NeedsExtraDocs;

  #region Private Methods
  private static void GettingStarted()
  {
    // tag::listener-initialize[]

    // tag::listener-config-db[]
    // Initialize the listener config
    var thisConfig = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="63"></i><b>(63)</b>

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.Port = 55990; <i class="conum" data-value="64"></i><b>(64)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    thisConfig.NetworkInterface = "10.1.1.10"; <i class="conum" data-value="65"></i><b>(65)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.EnableDeltaSync = true; <i class="conum" data-value="66"></i><b>(66)</b>

    // end::listener-config-delta-sync[]
    // tag::listener-config-tls-full[]
    // tag::listener-config-tls-enable[]
    thisConfig.DisableTLS = false; <i class="conum" data-value="67"></i><b>(67)</b>

    // end::listener-config-tls-enable[]
    // tag::listener-config-tls-id-anon[]
    // Use an Anonymous Self-Signed Cert
    thisConfig.TlsIdentity = null; <i class="conum" data-value="68"></i><b>(68)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure the client authenticator
    // Here we are using Basic Authentication) <i class="conum" data-value="69"></i><b>(69)</b>
    SecureString validPassword =  new SecureString(); /* example only */
    // Get SecureString input for validPassword
    var validUser = "valid.username";
    thisConfig.Authenticator = new ListenerPasswordAuthenticator(
      (sender, validUser, validPassword) =&gt;
        {
          return username.equals(validUser)  &amp;&amp; password == validPassword);
        }
      );

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // Initialize the listener
    _thisListener = new URLEndpointListener(thisConfig); <i class="conum" data-value="70"></i><b>(70)</b>

    // Start the listener
    thisListener.Start(); <i class="conum" data-value="71"></i><b>(71)</b>

    // end::listener-start[]
    // end::listener-initialize[]
  }

  // tag::old-listener-config-tls-disable[]
  thisConfig.disableTLS = true;
  // end::old-listener-config-tls-disable[]

  // tag::listener-config-tls-id-nil-2[]

  // Use “anonymous” cert. These are self signed certs created by the system
  thisConfig.TlsIdentity = null;
  // end::listener-config-tls-id-nil-2[]


  // tag::old-listener-config-delta-sync[]
  thisConfig.EnableDeltaSync = true;
  // end::old-listener-config-delta-sync[]


  // tag::listener-status-check[]
  int connectionCount = thisListener.Status.ConnectionCount; <i class="conum" data-value="72"></i><b>(72)</b>
  int activeConnectionCount = thisListener.Status.ActiveConnectionCount;  <i class="conum" data-value="73"></i><b>(73)</b>

  // end::listener-status-check[]


  // tag::listener-stop[]
  thisListener.Stop();

  // end::listener-stop[]

// Additional snippets


// tag::listener-get-network-interfaces[]
foreach(NetworkInterface ni in NetworkInterface.GetAllNetworkInterfaces())
{
  if(ni.NetworkInterfaceType == NetworkInterfaceType.Wireless80211 ||
      ni.NetworkInterfaceType == NetworkInterfaceType.Ethernet)
  {
    // do something with the interface(s)
  }
}

// end::listener-get-network-interfaces[]


// tag::listener-get-url-list[]
var thisConfig = new URLEndpointListenerConfiguration(thisDB);
_thisListener = new URLEndpointListener(thisConfig);

_thisListener.Start();

 Console.WriteLine("URLS are {0} ", thisListener.Urls;

// end::listener-get-url-list[]

    // tag::listener-config-tls-disable[]
    thisConfig.DisableTLS = true; <i class="conum" data-value="74"></i><b>(74)</b>

    // end::listener-config-tls-disable[]

    // tag::listener-local-db[]
    // . . . preceding application logic . . .
    // Get the database (and create it if it doesn't exist)
    var thisDB = new Database("mydb");

    // end::listener-local-db[]

    // tag::listener-config-tls-id-full[]
    // tag::listener-config-tls-id-caCert[]
    // Use CA Cert
    // Create a TLSIdentity from an imported key-pair
    // . . . previously declared variables include ...
    TLSIdentity thisIdentity;
    X509Store _store =
      new X509Store(StoreName.My); // create and label x509 store

    // Get keys and certificates from PKCS12 data
    byte[] thisIdData =
      File.ReadAllBytes("c:client.p12"); <i class="conum" data-value="75"></i><b>(75)</b>
    // . . . other user code . . .

    // tag::import-tls-identity[]
    thisIdentity = TLSIdentity.ImportIdentity(
      _store,
      thisIdData, <i class="conum" data-value="76"></i><b>(76)</b>
      "123", // Password to access certificate data
      "couchbase-demo-cert",
      null); // Label to get cert in certificate map
        // NOTE: If a null label is supplied then the same
        // default directory for a Couchbase Lite database
        // is used for map.

    // end::import-tls-identity[]
    // end::listener-config-tls-id-caCert[]

    // tag::listener-config-tls-id-anon[]
    // Use an Anonymous Self-Signed Cert
    thisConfig.TlsIdentity = null; <i class="conum" data-value="77"></i><b>(77)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-tls-id-set[]
    // Set the TLS Identity
    thisConfig.TlsIdentity = thisIdentity; <i class="conum" data-value="78"></i><b>(78)</b>

    // end::listener-config-tls-id-set[]
    // end::listener-config-tls-id-full[]

    // tag::listener-config-client-auth-root[]
    // Configure the client authenticator
    // to validate using ROOT CA

    // Get the valid cert chain, in this instance from
    // PKCS12 data containing private key, public key
    // and certificates <i class="conum" data-value="79"></i><b>(79)</b>
    var clientData = File.ReadAllBytes("c:client.p12");
    var ourCaData = File.ReadAllBytes("c:client-ca.der");

    // Get the root certs from the data
    var thisRootCert = new X509Certificate2(ourCaData); <i class="conum" data-value="80"></i><b>(80)</b>

    // Configure the authenticator to use the root certs
    var thisAuth = new ListenerCertificateAuthenticator(new X509Certificate2Collection(thisRootCert));

    thisConfig.Authenticator = thisAuth; <i class="conum" data-value="81"></i><b>(81)</b>

    // Initialize the listener using the config
    _listener = new URLEndpointListener(thisConfig);

    // end::listener-config-client-auth-root[]
    // tag::listener-config-client-auth-lambda[]
    // Configure the client authenticator
    // to validate using application logic

    // Get the valid cert chain, in this instance from
    // PKCS12 data containing private key, public key
    // and certificates <i class="conum" data-value="82"></i><b>(82)</b>
    clientData = File.ReadAllBytes("c:client.p12");
    ourCaData = File.ReadAllBytes("c:client-ca.der");

    // Get the root certs from the data
    var thisRootCert = new X509Certificate2(ourCaData);

    // Configure the authenticator to pass the root certs
    // To a user supplied code block for authentication
    var thisAuth =
      new ListenerCertificateAuthenticator(
        new X509Certificate2Collection(thisRootCert) =&gt; {
          // . . . user supplied code block
          // . . . returns boolean value (true=authenticated)
        }); <i class="conum" data-value="83"></i><b>(83)</b>

    thisConfig.Authenticator = thisAuth; <i class="conum" data-value="84"></i><b>(84)</b>

    // end::listener-config-client-auth-lambda[]



// END Additional






// Listener Callouts

// tag::listener-callouts-full[]

  // tag::listener-start-callouts[]
  &lt;.&gt; Initialize the listener instance using the configuration settings.
  &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.
  // end::listener-start-callouts[]


  // tag::listener-status-check-callouts[]

  &lt;.&gt; `connectionCount` -- the total number of connections served by the listener
  &lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
  //
  // end::listener-status-check-callouts[]

// tag::listener-config-tls-id-caCert-callouts[]
  &lt;.&gt; Ensure TLS is enabled.
  &lt;.&gt; The identity will be stored in the secure storage using the given label
  &lt;.&gt; PKCS12 data containing private key, public key, and certificates
  &lt;.&gt; The key pair as stored in the byte array
  &lt;.&gt; The password required to access the certificate data
  &lt;.&gt; The key label assigned to the cert in certificate map and used for retrieval
  &lt;.&gt; If null, the same default directory for a Couchbase Lite database is used for map
  &lt;.&gt; Use the TLSIdentity `thisIdentity.`

// end::listener-config-tls-id-caCert-callouts[]

  // tag::listener-config-tls-id-SelfSigned-callouts[]
  &lt;.&gt; Ensure TLS is enabled.
  &lt;.&gt; The identity will be stored in the secure storage using the given label
  &lt;.&gt; When creating a certificate, the common name attribute is required to create a CSR. If the common name is not present in the certificate an exception is thrown.
  &lt;.&gt; If the expiration date is not specified, the expiration date of the certificate is 365 days after creation
  &lt;.&gt; The key label to get cert in certificate map
  &lt;.&gt; If null, the same default directory for a Couchbase Lite database is used for map
  &lt;.&gt; Use the TLSIdentity `thisIdentity.`

  // end::listener-config-tls-id-SelfSigned-callouts[]

// end::listener-callouts-full[]








// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  // Work in progress. Code snippet to be provided.

  // end::old-listener-config-client-auth-root[]


  // prev content of listener-config-client-auth-self-signed (for ios)
  thisConfig.authenticator = ListenerCertificateAuthenticator.init {
    (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedUsers.contains(["name": certCommonName! as String])) {
      return true
    }
    return false
  }
  // tag::spare-listener-config-client-auth-self-signed[]
  // Work in progress. Code snippet to be provided.

  // end::spare-listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}
// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
thisConfig.port = tls ? wssPort : wsPort
thisConfig.disableTLS = !tls
thisConfig.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
// end::p2p-ws-api-urlendpointlistener-constructor[]


// ACTIVE PEER STUFF
// Replication code
//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

public class Examples {
  private static final String TAG = "EXAMPLE ACTIVE PEER";
  private static final String thisDBNAME = "local-database";
  private final Context context;
  // private Database database;
  // private Replicator replicator;

  public Examples(Context context) { this.context = context; }

  String user = "syncuser";
  String password = "sync9455";
  SecCertificate cert=null;
  String passivePeerEndpoint = "10.1.1.12:8920";
  String passivePeerPort = "8920";
  String passiveDbName = "userdb";
  Database thisDB;
  Replicator thisReplicator;
  ListenerToken replicatorListener;

  //@Test
  public void testActPeerSync() throws CouchbaseLiteException, URISyntaxException {
// tag::p2p-act-rep-func[]
    // . . . preceding code. for example . . .
    private static ListenerToken _thisListenerToken;
    var Database thisDB;
    // . . . other code . . .
    // tag::p2p-act-rep-initialize[]
    // initialize the replicator configuration

    var thisUrl = new URLEndpoint("wss://listener.com:4984/otherDB"); <i class="conum" data-value="85"></i><b>(85)</b>
    var config = new ReplicatorConfiguration(thisDB, thisUrl);

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config-type[]

    // Set replicator type
    thisConfig.ReplicatorType = ReplicatorType.PushAndPull;

    // end::p2p-act-rep-config-type[]
    // tag::autopurge-override[]
    // Set autopurge option
    // here we override its default
    thisConfig.EnableAutoPurge = false; <i class="conum" data-value="86"></i><b>(86)</b>

    // end::autopurge-override[]
    // tag::p2p-act-rep-config-cont[]
    // Configure Sync Mode
    thisConfig.Continuous = true; // default value

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Security -- only accept self-signed certs
    thisConfig.AcceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="87"></i><b>(87)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Security <i class="conum" data-value="88"></i><b>(88)</b>
    // tag::p2p-act-rep-auth[]
    // Configure basic auth using user credentials
    thisConfig.Authenticator = new BasicAuthenticator("Our Username", "Our Password");

    // end::p2p-act-rep-auth[]
    // tag::p2p-act-rep-config-conflict-full[]
    // tag::p2p-act-rep-config-conflict-builtin[]
    /* Optionally set a conflict resolver call back */ <i class="conum" data-value="89"></i><b>(89)</b>
    // Use built-in resolver
    thisConfig.ConflictResolver = new LocalWinConflictResolver();  //

    // end::p2p-act-rep-config-conflict-builtin[]
    // tag::p2p-act-rep-config-conflict-custom[]
    // optionally use custom resolver
    thisConfig.ConflictResolver = new ConflictResolver(
      (conflict) =&gt; {
        /* define resolver function */
      }
    ); //

    // end::p2p-act-rep-config-conflict-custom[]
    // end::p2p-act-rep-config-conflict-full[]
    // tag::p2p-act-rep-start-full[]
    // Initialize and start a replicator
    // Initialize replicator with configuration data
    var thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="90"></i><b>(90)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    //Optionally add a change listener <i class="conum" data-value="91"></i><b>(91)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    _thisListenerToken =
      thisReplicator.AddChangeListener((sender, args) =&gt;
        {
          if (args.Status.Activity == ReplicatorActivityLevel.Stopped) {
              Console.WriteLine("Replication stopped");
          }
        });

    // end::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-start[]
    // Start replicator
    thisReplicator.Start(); <i class="conum" data-value="92"></i><b>(92)</b>

    // end::p2p-act-rep-start[]
// end::p2p-act-rep-start-full[]
// end::p2p-act-rep-func[]         ***** End p2p-act-rep-func
}

// Additional snippets

    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA certs
    thisConfig.AcceptOnlySelfSignedServerCertificate = false; <i class="conum" data-value="93"></i><b>(93)</b>

    // end::p2p-act-rep-config-cacert[]
    // tag::p2p-act-rep-config-pinnedcert[]

    // Return the remote pinned cert (the listener's cert)
    byte returnedCert = new byte(thisConfig.getPinnedCertificate()); // Get listener cert if pinned
    // end::p2p-act-rep-config-pinnedcert[]
    // Configure Client Security <i class="conum" data-value="94"></i><b>(94)</b>
    // tag::p2p-act-rep-auth[]
    // Configure basic auth using user credentials
    thisConfig.Authenticator = new BasicAuthenticator("Our Username", "Our Password");

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]

    // tag::p2p-act-rep-config-cacert-pinned[]
    // Only CA Certs accepted
    thisConfig.AcceptOnlySelfSignedServerCertificate =
      false; <i class="conum" data-value="95"></i><b>(95)</b>

    var thisCert =
      new X509Certificate2(caData); <i class="conum" data-value="96"></i><b>(96)</b>

    thisConfig.PinnedServerCertificate =
      thisCert; <i class="conum" data-value="97"></i><b>(97)</b>

    // end::p2p-act-rep-config-cacert-pinned[]












    // Code to refactor
    Log.i(TAG, "The Replicator is currently " + thisReplicator.Status().getActivityLevel());

    Log.i(TAG, "The Replicator has processed " + t);

    if (thisReplicator.Status().getActivityLevel() == Replicator.ActivityLevel.BUSY) {
          Log.i(TAG, "Replication Processing");
          Log.i(TAG, "It has completed " + thisReplicator.Status().getProgess().getTotal() + " changes");
      }
    // tag::p2p-act-rep-status[]
    _thisReplicator.Stop();
    while (_thisReplicator.Status.Activity != ReplicatorActivityLevel.Stopped) {
        // Database cannot close until replicators are stopped
        Console.WriteLine($"Waiting for replicator to stop (currently {_thisReplicator.Status.Activity})...");
        Thread.Sleep(200);
    }
    _thisDatabase.Close();
    // end::p2p-act-rep-status[]

      // tag::p2p-act-rep-stop[]
      // Stop replication.
      thisReplicator.Stop(); <i class="conum" data-value="98"></i><b>(98)</b>
      // end::p2p-act-rep-stop[]


  }

{
  CouchbaseLite.init(context);
  Database thisDB = new Database("passivepeerdb");  <i class="conum" data-value="99"></i><b>(99)</b>
  // Initialize the listener config
  final URLEndpointListenerConfiguration thisConfig = new URLEndpointListenerConfiguration(database);
  thisConfig.Port(55990)             // &lt;.&gt; Default- port is selected
  thisConfig.DisableTls(false)       // &lt;.&gt; Optional. Defaults to false. You get TLS encryption out-of-box
  thisConfig.EnableDeltaSync(true)   // &lt;.&gt; Optional. Defaults to false.

  // Configure the client authenticator (if using basic auth)
  ListenerPasswordAuthenticator auth = new ListenerPasswordAuthenticator { "Our Username", "Our Password"}; <i class="conum" data-value="100"></i><b>(100)</b>
  thisConfig.Authenticator(auth); <i class="conum" data-value="101"></i><b>(101)</b>

  // Initialize the listener
  final URLEndpointListener listener = new URLEndpointListener( thisConfig ); <i class="conum" data-value="102"></i><b>(102)</b>

  // Start the listener
  listener.Start(); <i class="conum" data-value="103"></i><b>(103)</b>
    }


// tag::createTlsIdentity[]

Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
           TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
           TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
           TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
           TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
       )

TLSIdentity thisIdentity = new TLSIdentity.createIdentity(true, X509_ATTRIBUTES, null, "test-alias");

// end::createTlsIdentity[]


// tag::p2p-tlsid-store-in-keychain[]
. . . work in progress - GetHashCode snippet to be provided
// end::p2p-tlsid-store-in-keychain[]

// tag::deleteTlsIdentity[]
// tag::p2p-tlsid-delete-id-from-keychain[]
TLSIdentity.DeleteIdentity(_store, "alias-to-delete", null);

// end::p2p-tlsid-delete-id-from-keychain[]
// end::deleteTlsIdentity[]

// tag::retrieveTlsIdentity[]
// OPTIONALLY:: Retrieve a stored TLS identity using its alias/label

TLSIdentity thisIdentity = new TLSIdentity.getIdentity("CBL-Demo-Server-Cert")
// end::retrieveTlsIdentity[]


    // Configure the client authenticator (if using Basic Authentication)
    // String validUser = new String("validUsername"); // an example username
    // String validPassword = new String("validPasswordValue"); // an example password

    // ListenerPasswordAuthenticator thisAuth = new ListenerPasswordAuthenticator( <i class="conum" data-value="104"></i><b>(104)</b>
    //   validUser, validPassword -&gt; validUser == "validUsername" &amp;&amp; validPassword == "validPasswordValue" );

    // if (thisAuth) {
    //   thisConfig.Authenticator(auth);
    // }
    // else {
    //   // . . . authentication failed take appropriate exception action
    //   return
    // };




    // tag::old-p2p-act-rep-add-change-listener[]
    ListenerToken thisListener = new thisReplicator.addChangeListener(change -&gt; { <i class="conum" data-value="105"></i><b>(105)</b>
      if (change.Status().getError() != null) {
        Log.i(TAG, "Error code ::  " + change.Status().getError().getCode());
      }
    });

    // end::old-p2p-act-rep-add-change-listener[]



// g u b b i n s
// tag::duff-p2p-tlsid-tlsidentity-with-label[]


    // Configure TLS Cert CA auth using key-stored cert id alias 'doc-sync-server'

    // TLSIdentity thisIdentity = new TLSIdentity.getIdentity("doc-sync-server"); // Get existing TLS ID from sec storage

    // ClientCertificateAuthenticator thisAuth = new ClientCertificateAuthenticator(thisIdentity);

    // thisConfig.Authenticator(thisAuth);



    // USE KEYCHAIN IDENTITY IF EXISTS
    // Check if Id exists in keychain. If so use that Id

    // STILL NEED TO REFACTOR

    do {
      if let thisIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
          print("An identity with label : doco-sync-server already exists in keychain")
          return thisIdentity
          }
    } catch
    {return nil}
    thisAuthenticator.ClientCertificateAuthenticator(identity: thisIdentity )
    thisConfig.thisAuthenticator

    // end::duff-p2p-tlsid-tlsidentity-with-label[]


// tag::old-deleteTlsIdentity[]

String thisAlias = "alias-to-delete";
KeyStore thisKeystore = KeyStore.getInstance("PKCS12"); <i class="conum" data-value="106"></i><b>(106)</b>
thisKeyStore.load= null;
if (thisAlias != null) {
   thisKeystore.deleteEntry(thisAlias);  <i class="conum" data-value="107"></i><b>(107)</b>
}

// end::old-deleteTlsIdentity[]


// cert auth
let rootCertData = SecCertificateCopyData(cert) as Data
let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
// Listener:
thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

SecCertificate thisCert = new SecCertificate(); // populated as nec.

Data rootCertData = new Data(SecCertificateCopyData(thisCert));

let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
// Listener:
thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])
// cert auth


// C A L L O U T S

// tag::p2p-act-rep-config-cacert-pinned-callouts[]
&lt;.&gt; Configure to accept only CA certs
&lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
&lt;.&gt; Set the certificate to be compared with that provided by the server
// end::p2p-act-rep-config-cacert-pinned-callouts[]

// tag::??p2p-tlsid-tlsidentity-with-label-callouts[]
&lt;.&gt; PKCS12 data containing private key, public key, and certificates
&lt;.&gt; This is the default value and means that TLS is enabled
// end::??p2p-tlsid-tlsidentity-with-label-callouts[]

// tag::p2p-tlsid-tlsidentity-with-label-callouts[]
&lt;.&gt; Refuse self-signed certificates
&lt;.&gt; Get the identity
&lt;.&gt; Set the Client Certificate Authenticator to require signed certificates with this identity

// end::p2p-tlsid-tlsidentity-with-label-callouts[]


    // tag::old-listener-config-client-root-ca[]
    // Configure the client authenticator
    // to validate using ROOT CA <i class="conum" data-value="108"></i><b>(108)</b>
    byte[] thisCaData; // byte array for CA data
    using (var thisReader = new BinaryReader(stream)) {
      thisCaData = thisReader.ReadBytes(int stream.Length);
    }; // Get cert data

    var thisRootCert = new X509Certificate(thisCaData); //

    thisConfig.Authenticator = new  ListenerCertificateAuthenticator(
      new X509Certificate2Collection(thisRootCert)
    );

    // end::old-listener-config-client-root-ca[]



        // tag::p2p-tlsid-tlsidentity-with-label-per-sam[]
    var db = new Database("other-database");
    _Database = db;
    X509Store _store = new X509Store(StoreName.My);
    TLSIdentity thisIdentity;

    // tag::client-cert-authenticator-root-certs[]

    // Configure the expected server-supplied
    // credentials -- only accept CA Certs
    thisConfig.AcceptOnlySelfSignedServerCertificate = false; <i class="conum" data-value="109"></i><b>(109)</b>

    // Client identity
    thisIdentity =
      TLSIdentity.ImportIdentity(_store,
        clientData,
        "123",
        "CBL-Client-Cert",
        null); <i class="conum" data-value="110"></i><b>(110)</b>

    thisConfig.Authenticator =
      new ClientCertificateAuthenticator(thisIdentity); <i class="conum" data-value="111"></i><b>(111)</b>

    // end::client-cert-authenticator-root-certs[]





    byte[] thisCaData, thisClientData;
    thisClientData = File.ReadAllBytes("C:\\client.p12"); <i class="conum" data-value="112"></i><b>(112)</b>
    thisCaData = File.ReadAllBytes("C:\\client-ca.der");

    // Root certs
    var thisRootCert = new X509Certificate2(thisCaData);
    var thisAuth =
      new ListenerCertificateAuthenticator(
        new X509Certificate2Collection(thisRootCert));

    // Create URL Endpoint Listener
    var thisConfig = new URLEndpointListenerConfiguration(_Database);
    thisConfig.DisableTLS = false; <i class="conum" data-value="113"></i><b>(113)</b>
    thisConfig.Authenticator = thisAuth;
    _listener = new URLEndpointListener(thisConfig);
    _listener.Start();

    // Client identity
    thisIdentity = TLSIdentity.ImportIdentity(_store,
        thisClientData,
        "123",
        "CBL-Client-Cert",
        null);

    // Replicator -- Client
    var database = new Database("client-database");
    var builder = new UriBuilder(
        "wss",
        "localhost",
        _listener.Port,
        $"/{_listener.thisConfig.Database.Name}"
    );

    var url = builder.Uri;
    var target = new URLEndpoint(url);
    var thisConfig = new ReplicatorConfiguration(database, target);
    thisConfig.ReplicatorType = ReplicatorType.PushAndPull;
    thisConfig.Continuous = false;
    thisConfig.Authenticator = new ClientCertificateAuthenticator(thisIdentity);
    thisConfig.AcceptOnlySelfSignedServerCertificate = true;
    thisConfig.PinnedServerCertificate = _listener.TlsIdentity.Certs[0];
    using (var replicator = new Replicator(thisConfig)) {
        replicator.Start();
    }





    // Stop listener after replicator is stopped
    _listener.Stop();

    // end::p2p-tlsid-tlsidentity-with-label-per-sam[]


        // tag::p2p-tlsid-tlsidentity-with-label[]
    // Client identity
    thisIdentity =
      TLSIdentity.ImportIdentity(_store,
        clientData,
        "123",
        "CBL-Client-Cert",
        null); <i class="conum" data-value="114"></i><b>(114)</b>

    thisConfig.Authenticator =
      new ClientCertificateAuthenticator(thisIdentity); <i class="conum" data-value="115"></i><b>(115)</b>

    // end::p2p-tlsid-tlsidentity-with-label[]


  // For replications

  // BEGIN -- snippets --
  //    Purpose -- code samples for use in replication topic

  // tag::sgw-repl-pull[]
  public class MyClass
  {
      public Database Database { get; set; }
      public Replicator Replicator { get; set; } <i class="conum" data-value="116"></i><b>(116)</b>

      public void StartReplication()
      {
  }

          var url = new Uri("wss://localhost:4984/db"); <i class="conum" data-value="117"></i><b>(117)</b>
          var target = new URLEndpoint(url);
          var config = new ReplicatorConfiguration(Database, target)
          {
              ReplicatorType = ReplicatorType.Pull
          };

          Replicator = new Replicator(config);
          Replicator.Start();
      }
      // end::sgw-repl-pull[]

      // tag::sgw-repl-pull-callouts[]
      // &lt;.&gt; A replication is an asynchronous operation.
      // To keep a reference to the `replicator` object, you can set it as an instance property.
      // &lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
      // You should now use `ws:`, or `wss:` for SSL/TLS connections.
      // end::sgw-repl-pull-callouts[]

      public void InitReplication()
      {
        // tag::sgw-act-rep-initialize[]
        // initialize the replicator configuration

        var thisUrl = new URLEndpoint("wss://l10.0.2.2:4984/anotherDB"); <i class="conum" data-value="118"></i><b>(118)</b>
        var config = new ReplicatorConfiguration(thisDB, thisUrl);

        // end::sgw-act-rep-initialize[]
      }
  }
 }



  public class supporting_datatypes
  {
    public void datatype_usage()
    {

        // tag::datatype_usage[]
        // tag::datatype_usage_createdb[]
        // Get the database (and create it if it doesn’t exist).
        var database = new Database("hoteldb");

        // end::datatype_usage_createdb[]
        // tag::datatype_usage_createdoc[]
        // Create your new document

        // Add the dictionary to a document's properties and save the document
        var doc = new MutableDocument("hoteldoc");

        // end::datatype_usage_createdoc[]
        // tag::datatype_usage_mutdict[]
        // Create and populate mutable dictionary
        var address = new MutableDictionaryObject();
        address.SetString("street", "1 Main st.");
        address.SetString("city", "San Francisco");
        address.SetString("state", "CA");
        address.SetString("country", "USA");
        address.SetString("code", "90210");

        // end::datatype_usage_mutdict[]
        // tag::datatype_usage_mutarray[]
        // Create and populate mutable array
        var phones = MutableArrayObject();
        phones.AddString("650-000-0000");
        phones.AddString("650-000-0001");

        // end::datatype_usage_mutarray[]
        // tag::datatype_usage_populate[]
        // Initialize and populate the document

        // Add document type to document properties <i class="conum" data-value="119"></i><b>(119)</b>
        doc.SetString("type", "hotel");

        // Add hotel name string to document properties <i class="conum" data-value="120"></i><b>(120)</b>
        doc.SetString("name", "Hotel Java Mo");

        // Add float to document properties <i class="conum" data-value="121"></i><b>(121)</b>
        doc.SetFloat("room_rate", 121.75);

        // Add dictionary to document's properties <i class="conum" data-value="122"></i><b>(122)</b>
        doc.SetDictionary("address", address);

        // Add array to document's properties <i class="conum" data-value="123"></i><b>(123)</b>
        doc.SetArray("phones", phones);

        // end::datatype_usage_populate[]
        // tag::datatype_usage_persist[]
        // Save the document changes <i class="conum" data-value="124"></i><b>(124)</b>
        database.Save(doc);

        // end::datatype_usage_persist[]
        // tag::datatype_usage_closedb[]
        // Close the database <i class="conum" data-value="125"></i><b>(125)</b>
        database.Close();

        // end::datatype_usage_closedb[]

        // end::datatype_usage[]

     }



      public void datatype_dictionary()
      {
          var database = new Database(name: "mydb");

          // tag::datatype_dictionary[]
          // NOTE: No error handling, for brevity (see getting started)
          var document = database.GetDocument("doc1");

          // Getting a dictionary from the document's properties
          var dict = document.GetDictionary("address");

          // Access a value with a key from the dictionary
          var street = dict.GetString("street");

          // Iterate dictionary
          foreach (var key in dict.Keys)
          {
              Console.WriteLine($"Key {key} = {dict.GetValue(key)}");
          }

          // Create a mutable copy
          var mutDict = dict.ToMutable();
          // end::datatype_dictionary[]
      }

      public void datatype_mutable_dictionary()
      {

          var database = new Database("mydb");

          // tag::datatype_mutable_dictionary[]
          // NOTE: No error handling, for brevity (see getting started)

          // Create a new mutable dictionary and populate some keys/values
          var mutable_dict = new MutableDictionaryObject();
          mutable_dict.SetString("street", "1 Main st.");
          mutable_dict.SetString("city", "San Francisco");

          // Add the dictionary to a document's properties and save the document
          var doc = new MutableDocument("doc1");
          doc.SetDictionary("address", mutable_dict);
          database.Save(doc);

          // end::datatype_mutable_dictionary[]
      }


      public void datatype_array()
      {
          var database = new Database("mydb");

          // tag::datatype_array[]
          // NOTE: No error handling, for brevity (see getting started)

          var document = database.GetDocument("doc1");

          // Getting a phones array from the document's properties
          var array = document.GetArray("phones");

          // Get element count
          var count = array.Count();

          // Access an array element by index
          if (count &gt;= 0) { var phone = array[1]; }

          // Iterate dictionary
          for (int i = 0; i &lt; count; i++)
          {
              Console.WriteLine($"Item {i.ToString()} = {array[i]}");
          }

          // Create a mutable copy
          var mutable_array = array.ToMutable();
          // end::datatype_array[]


      }

        public void datatype_mutable_array()
      {
          var database = new Database("mydb");

          // tag::datatype_mutable_array[]
          // NOTE: No error handling, for brevity (see getting started)

          // Create a new mutable array and populate data into the array
          var mutable_array = new MutableArrayObject();
          mutable_array.AddString("650-000-0000");
          mutable_array.AddString("650-000-0001");

          // Set the array to document's properties and save the document
          var doc = new MutableDocument("doc1");
          doc.SetArray("phones", mutable_array);
          database.Save(doc);
          // end::datatype_mutable_array[]
      }

  } // end  class supporting_datatypes</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Store imported identity in keychain</p>
</li>
</ol>
</div>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#" data-source-url="https://github.com/couchbase/docs-couchbase-lite/blob/undefined/modules/csharp/examples/code_snippets/Program.cs">//
// Program.cs
//
// Copyright (c) 2017 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;

using Couchbase.Lite;
using Couchbase.Lite.Enterprise.Query;
using Couchbase.Lite.Logging;
using Couchbase.Lite.P2P;
using Couchbase.Lite.Query;
using Couchbase.Lite.Sync;
using Newtonsoft.Json;

using SkiaSharp;

namespace api_walkthrough
{
    class Program
    {
        private static Database _Database;
        private static Replicator _Replicator;
        private static URLEndpointListener _listener;
        private static ListenerToken _ListenerToken;
        private static bool _NeedsExtraDocs;

        #region Private Methods

        private static void GettingStarted()
        {
            // tag::getting-started[]

            // using System;
            // using Couchbase.Lite;
            // using Couchbase.Lite.Query;
            // using Couchbase.Lite.Sync;

            // Get the database (and create it if it doesn't exist)
            var database = new Database("mydb");
            // Create a new document (i.e. a record) in the database
            string id = null;
            using (var mutableDoc = new MutableDocument())
            {
                mutableDoc.SetFloat("version", 2.0f)
                    .SetString("type", "SDK");

                // Save it to the database
                database.Save(mutableDoc);
                id = mutableDoc.Id;
            }

            // Update a document
            using (var doc = database.GetDocument(id))
            using (var mutableDoc = doc.ToMutable())
            {
                mutableDoc.SetString("language", "C#");
                database.Save(mutableDoc);

                using (var docAgain = database.GetDocument(id))
                {
                    Console.WriteLine($"Document ID :: {docAgain.Id}");
                    Console.WriteLine($"Learning {docAgain.GetString("language")}");
                }
            }

            // Create a query to fetch documents of type SDK
            // i.e. SELECT * FROM database WHERE type = "SDK"
            using (var query = QueryBuilder.Select(SelectResult.All())
                .From(DataSource.Database(database))
                .Where(Expression.Property("type").EqualTo(Expression.String("SDK"))))
            {
                // Run the query
                var result = query.Execute();
                Console.WriteLine($"Number of rows :: {result.AllResults().Count}");
            }

            // Create replicator to push and pull changes to and from the cloud
            var targetEndpoint = new URLEndpoint(new Uri("ws://localhost:4984/getting-started-db"));
            var replConfig = new ReplicatorConfiguration(database, targetEndpoint);

            // Add authentication
            replConfig.Authenticator = new BasicAuthenticator("john", "pass");

            // Create replicator (make sure to add an instance or static variable
            // named _Replicator)
            var _Replicator = new Replicator(replConfig);
            _Replicator.AddChangeListener((sender, args) =&gt;
            {
                if (args.Status.Error != null)
                {
                    Console.WriteLine($"Error :: {args.Status.Error}");
                }
            });

            _Replicator.Start();

            // Later, stop and dispose the replicator *before* closing/disposing the
        }


// end::getting-started[]

        private static void TestReplicatorConflictResolver()
        {
            // tag::replication-conflict-resolver[]
            var target = new URLEndpoint(new Uri("ws://localhost:4984/mydatabase"));
            var replConfig = new ReplicatorConfiguration(database, target);
            replConfig.ConflictResolver = new LocalWinConflictResolver();

            var replicator = new Replicator(replConfig);
            replicator.Start();
            // end::replication-conflict-resolver[]
        }

        private static void TestSaveWithConflictHandler()
        {
            // tag::update-document-with-conflict-handler[]
            using (var document = database.GetDocument("xyz"))
            using (var mutableDocument = document.ToMutable()) {
                mutableDocument.SetString("name", "apples");
                database.Save(mutableDocument, (updated, current) =&gt;
                {
                    var currentDict = current.ToDictionary();
                    var newDict = updated.ToDictionary();
                    var result = newDict.Concat(currentDict)
                        .GroupBy(kv =&gt; kv.Key)
                        .ToDictionary(g =&gt; g.Key, g =&gt; g.First().Value);
                    updated.SetData(result);
                    return true;
                });
            }
            // end::update-document-with-conflict-handler[]
        }

        private static bool IsValidCredential(string name, SecureString password) { return true;  } // helper
        private static void TestInitListener()
        {
            var db = new Database("other-database");
            _Database = db;

            // tag::init-urllistener[]
            var config = new URLEndpointListenerConfiguration(_Database);
            config.TlsIdentity = null; // Use with anonymous self-signed cert
            config.Authenticator = new ListenerPasswordAuthenticator((sender, username, password) =&gt;
            {
                if(IsValidCredential(username, password)) {
                    return true;
                }

                return false;
            });

            _listener = new URLEndpointListener(config);
            // end::init-urllistener[]
        }

        private static void TestListenerStart()
        {
            // tag::start-urllistener[]
            // CouchbaseLiteException will be thrown when the listener cannot be started. The most common error
            // would be that the configured port has already been used.
            _listener.Start();
            // end::start-urllistener[]
        }

        private static void TestListenerStop()
        {
            // tag::stop-urllistener[]
            _listener.Stop();
            // end::stop-urllistener[]
        }

        private static void TestCreateSelfSignedCert()
        {
            TLSIdentity identity;
            X509Store _store =
             new X509Store(StoreName.My);
              // The identity will be stored in the secure
              // storage using the given label.
            DateTimeOffset fiveMinToExpireCert = DateTimeOffset.UtcNow.AddMinutes(5);

            // tag::create-self-signed-cert[]
            // tag::listener-config-tls-id-SelfSigned[]
            identity = TLSIdentity.CreateIdentity(true, /* isServer */
                new Dictionary&lt;string, string&gt;() { { Certificate.CommonNameAttribute, "Couchbase Inc" } },
                    // The common name attribute is required
                    // when creating a CSR. If it is not presented
                    // in the cert, an exception is thrown.
                fiveMinToExpireCert,
                    // If the expiration date is not specified,
                    // the certs expiration will be 365 days
                _store,
                "CBL-Server-Cert",
                null);  // The key label to get cert in certificate map.
                        // If null, the same default directory
                        // for a Couchbase Lite db is used for map.

            // end::listener-config-tls-id-SelfSigned[]
            // end::create-self-signed-cert[]
        }

        private static void TestImportTLSIdentity()
        {
            TLSIdentity identity;
            X509Store _store = new X509Store(StoreName.My); // The identity will be stored in the secure storage using the given label
            byte[] data = File.ReadAllBytes("C:\\client.p12"); // PKCS12 data containing private key, public key, and certificates

            // tag::import-tls-identity[]
            // tag::listener-config-tls-id-caCert[]
            identity = TLSIdentity.ImportIdentity(_store,
                data,
                "123", // The password that is needed to access the certificate data
                "CBL-Client-Cert",
                null);  // The key label to get cert in certificate map.
                        // If null, the same default directory
                        // for a Couchbase Lite db is used for map.
            // end::listener-config-tls-id-caCert[]
            // end::import-tls-identity[]
        }

          private static void TestClientCertAuthenticatorRootCerts()
        {
            var db = new Database("other-database");
            _Database = db;

            X509Store _store = new X509Store(StoreName.My);
            TLSIdentity identity;

            // tag::client-cert-authenticator-root-certs[]
            byte[] caData, clientData;
            clientData = File.ReadAllBytes("C:\\client.p12"); // PKCS12 data containing private key, public key, and certificates
            caData = File.ReadAllBytes("C:\\client-ca.der");

            // Root certs
            var rootCert = new X509Certificate2(caData);
            var auth = new ListenerCertificateAuthenticator(new X509Certificate2Collection(rootCert));

            // Create URL Endpoint Listener
            var listenerConfig = new URLEndpointListenerConfiguration(_Database);
            listenerConfig.DisableTLS = false; //The default value is false which means that the TLS will be enabled by default.
            listenerConfig.Authenticator = auth;
            _listener = new URLEndpointListener(listenerConfig);
            _listener.Start();

            // Client identity
            identity = TLSIdentity.ImportIdentity(_store,
                clientData,
                "123",
                "CBL-Client-Cert",
                null);

            // Replicator -- Client
            var database = new Database("client-database");
            var builder = new UriBuilder(
                "wss",
                "localhost",
                _listener.Port,
                $"/{_listener.Config.Database.Name}"
            );

            var url = builder.Uri;
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.ReplicatorType = ReplicatorType.PushAndPull;
            config.Continuous = false;
            config.Authenticator = new ClientCertificateAuthenticator(identity);
            config.AcceptOnlySelfSignedServerCertificate = true;
            config.PinnedServerCertificate = _listener.TlsIdentity.Certs[0];
            using (var replicator = new Replicator(config)) {
                replicator.Start();
            }

            // Stop listener after replicator is stopped
            _listener.Stop();
            // end::client-cert-authenticator-root-cert
        }

        private static void TestClientCertAuthenticator()
        {
            var db = new Database("other-database");
            _Database = db;

            X509Store _store = new X509Store(StoreName.My);
            TLSIdentity identity;

            // tag::client-cert-authenticator[]

            // Create Listener Certificate Authenticator
            var auth = new ListenerCertificateAuthenticator((sender, cert) =&gt;
            {
                if (cert.Count != 1) {
                    return false;
                }

                return cert[0].SubjectName.Name?.Replace("CN=", "") == "couchbase";
            });

            // Create URL Endpoint Listener
            var listenerConfig = new URLEndpointListenerConfiguration(_Database);
            listenerConfig.DisableTLS = false; //The default value is false which means that the TLS will be enabled by default.
            listenerConfig.Authenticator = auth;
            _listener = new URLEndpointListener(listenerConfig);
            _listener.Start();

            // User Identity
            identity = TLSIdentity.CreateIdentity(false,
                new Dictionary&lt;string, string&gt;() { { Certificate.CommonNameAttribute, "couchbase" } },
                null,
                _store,
                ClientCertLabel,
                null);

            // Replicator -- Client
            var database = new Database("client-database");
            var builder = new UriBuilder(
                "wss",
                "localhost",
                _listener.Port,
                $"/{_listener.Config.Database.Name}"
            );

            var url = builder.Uri;
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.ReplicatorType = ReplicatorType.PushAndPull;
            config.Continuous = false;
            config.Authenticator = new ClientCertificateAuthenticator(identity);
            config.AcceptOnlySelfSignedServerCertificate = false;
            config.PinnedServerCertificate = _listener.TlsIdentity.Certs[0];
            using (var replicator = new Replicator(config)) {
                replicator.Start();
            }

            // Stop listener after replicator is stopped
            _listener.Stop();
            // end::client-cert-authenticator[]
        }

        private static void UseEncryption()
        {
            // Enterprise edition only

            // tag::database-encryption[]
            // Create a new, or open an existing database with encryption enabled
            var config = new DatabaseConfiguration
            {
                // Or, derive a key yourself and pass a byte array of the proper size
                EncryptionKey = new EncryptionKey("password")
            };

            using (var db = new Database("seekrit", config)) {
                // Change the encryption key (or add encryption if the DB is unencrypted)
                db.ChangeEncryptionKey(new EncryptionKey("betterpassw0rd"));

                // Remove encryption
                db.ChangeEncryptionKey(null);
            }
            // end::database-encryption[]
        }

        private static void ResetReplicatorCheckpoint()
        {
            var database = _Database;
            var url = new Uri("ws://localhost:4984/db");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            using (var replicator = new Replicator(config)) {
              // tag::replication-reset-checkpoint[]
              // replicator is a Replicator instance
              if (resetCheckpointRequired_Example) {
                  replicator.Start(true); <i class="conum" data-value="1"></i><b>(1)</b>
              else
                replicator.Start(false);
              }
              // end::replication-reset-checkpoint[]




                // end::replication-reset-checkpoint[]
            }
        }

        private static void Read1xAttachment()
        {
            var db = _Database;
            using (var document = new MutableDocument()) {
                // tag::1x-attachment[]
                var attachments = document.GetDictionary("_attachments");
                var avatar = attachments.GetBlob("avatar");
                var content = avatar?.Content;
                // end::1x-attachment[]
            }
        }

        private static void CreateNewDatabase()
        {
            // tag::new-database[]
            var db = new Database("my-database");
            // end::new-database[]

            _Database = db;
        }

        private static void CloseDatabase()
        {
          // tag::close-database[]
          database.Close()

          // end::close-database[]
        }

        private static void ChangeLogging()
        {
            // tag::logging[]
            Database.SetLogLevel(LogDomain.Replicator, LogLevel.Verbose);
            Database.SetLogLevel(LogDomain.Query, LogLevel.Verbose);
            // end::logging[]
        }

        private static void LoadPrebuilt()
        {
            // tag::prebuilt-database[]
            // Note: Getting the path to a database is platform-specific.  For .NET Core / .NET Framework this
            // can be a simple filesystem path.  For UWP, you will need to get the path from your assets.  For
            // iOS you need to get the path from the main bundle.  For Android you need to extract it from your
            // assets to a temporary directory and then pass that path.
            var path = Path.Combine(Environment.CurrentDirectory, "travel-sample.cblite2" + Path.DirectorySeparatorChar);
            if (!Database.Exists("travel-sample", null)) {
                _NeedsExtraDocs = true;
                Database.Copy(path, "travel-sample", null);
            }
            // end::prebuilt-database[]

            _Database.Close();
            _Database = new Database("travel-sample");
        }

        private static void QueryDeletedDocuments()
        {
            // tag::query-deleted-documents[]
            // Query documents that have been deleted
            var query = QueryBuilder
                .Select(SelectResult.Expression(Meta.ID))
                .From(DataSource.Database(db))
                .Where(Meta.IsDeleted);
            // end::query-deleted-documents[]
        }

        private static void CreateDocument()
        {
            var db = _Database;
            // tag::initializer[]
            using (var newTask = new MutableDocument("xyz")) {
                newTask.SetString("type", "task")
                    .SetString("owner", "todo")
                    .SetDate("createdAt", DateTimeOffset.UtcNow);

                db.Save(newTask);
            }
            // end::initializer[]
        }

        private static void UpdateDocument()
        {
            var db = _Database;
            // tag::update-document[]
            using(var document = db.GetDocument("xyz"))
            using (var mutableDocument = document.ToMutable()) {
                mutableDocument.SetString("name", "apples");
                db.Save(mutableDocument);
            }
            // end::update-document[]
        }

        private static void UseTypedAccessors()
        {
            using (var newTask = new MutableDocument()) {
                // tag::date-getter[]
                newTask.SetValue("createdAt", DateTimeOffset.UtcNow);
                var date = newTask.GetDate("createdAt");
                // end::date-getter[]

                Console.WriteLine(date);
            }
        }

        private static void DoBatchOperation()
        {
            var db = _Database;
            // tag::batch[]
            db.InBatch(() =&gt;
            {
                for (var i = 0; i &lt; 10; i++) {
                    using (var doc = new MutableDocument()) {
                        doc.SetString("type", "user");
                        doc.SetString("name", $"user {i}");
                        doc.SetBoolean("admin", false);
                        db.Save(doc);
                        Console.WriteLine($"Saved user document {doc.GetString("name")}");
                    }
                }
            });
            // end::batch[]
        }

        private static void DatabaseChangeListener()
        {
            var db = _Database;

            // tag::document-listener[]
            db.AddDocumentChangeListener("user.john", (sender, args) =&gt;
            {
                using (var doc = Db.GetDocument(args.DocumentID)) {
                    Console.WriteLine($"Status :: {doc.GetString("verified_account")}");
                }
            });
            // end::document-listener[]
        }

        private static void DocumentExpiration()
        {
            var db = _Database;

            // tag::document-expiration[]
            // Purge the document one day from now
            var ttl = DateTimeOffset.UtcNow.AddDays(1);
            db.SetDocumentExpiration("doc123", ttl);

            // Reset expiration
            db.SetDocumentExpiration("doc1", null);

            // Query documents that will be expired in less than five minutes
            var fiveMinutesFromNow = DateTimeOffset.UtcNow.AddMinutes(5).ToUnixTimeMilliseconds();
            var query = QueryBuilder
                .Select(SelectResult.Expression(Meta.ID))
                .From(DataSource.Database(db))
                .Where(Meta.Expiration.LessThan(Expression.Double(fiveMinutesFromNow)));
            // end::document-expiration[]
        }

        private static void UseBlob()
        {
            var db = _Database;
            using (var newTask = new MutableDocument()) {
                // tag::blob[]
                // Note: Reading the data is implementation dependent, as with prebuilt databases
                var image = File.ReadAllBytes("avatar.jpg"); <i class="conum" data-value="2"></i><b>(2)</b>
                var blob = new Blob("image/jpeg", image); <i class="conum" data-value="3"></i><b>(3)</b>
                 newTask.SetBlob("avatar", blob); <i class="conum" data-value="4"></i><b>(4)</b>
                db.Save(newTask);
                // end::blob[]

                var taskBlob = newTask.GetBlob("avatar");
                using (var bitmap = SKBitmap.Decode(taskBlob.ContentStream)) {
                    Console.WriteLine($"Bitmap dimensions: {bitmap.Width} x {bitmap.Height} ({bitmap.BytesPerPixel} bytes per pixel)");
                }
            }
        }

        public void CreateIndex()
        {
            // tag::query-index[]
            var db = _database;
            string[] indexProperties = new string[] {"type", "name" };
            var config = new ValueIndexConfiguration(indexProperties);
            db.CreateIndex("TypeNameIndex", config);
            // end::query-index[]
        }

        public void CreateIndex_Querybuilder()
        {
            // tag::query-index_Querybuilder[]
            // For value types, this is optional but provides performance enhancements
            var db = _database;
            var index = IndexBuilder.ValueIndex(
                ValueIndexItem.Expression(Expression.Property("type")),
                ValueIndexItem.Expression(Expression.Property("name"))); <i class="conum" data-value="5"></i><b>(5)</b>
            db.CreateIndex("TypeNameIndex", index);
            // end::query-index_Querybuilder[]
        }
        private static void SelectMeta()
        {
            Console.WriteLine("Select Meta");
            var db = _Database;

            // tag::query-select-meta[]
            // tag::query-select-props[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("type"),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Document ID :: {result.GetString("id")}");
                    Console.WriteLine($"Document Name :: {result.GetString("name")}");
                }
            }
            // end::query-select-props[]
            // end::query-select-meta[]
        }

        private static void SelectAll()
        {
            var db = _Database;

            // tag::query-select-all[]
            using (var query = QueryBuilder.Select(SelectResult.All())
                .From(DataSource.Database(db))) {
                // All user properties will be available here
            }
            // end::query-select-all[]

            // tag::live-query[]
            var query = QueryBuilder
                .Select(SelectResult.All())
                .From(DataSource.Database(db)); <i class="conum" data-value="6"></i><b>(6)</b>

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            var token = query.AddChangeListener((sender, args) =&gt; <i class="conum" data-value="7"></i><b>(7)</b>
            {
                var allResult = args.Results.AllResults();
                foreach (var result in allResult) {
                    Console.WriteLine(result.Keys);
                    /* Update UI */
                }
            });

            // end::live-query[]

            // tag::stop-live-query[]
            query.RemoveChangeListener(token);
            query.Dispose();
            // end::stop-live-query[]
        }

        private static void SelectWhere()
        {
            Console.WriteLine("Where");
            var db = _Database;

            // tag::query-where[]
            using (var query = QueryBuilder.Select(SelectResult.All())
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("hotel")))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    var dict = result.GetDictionary(db.Name);
                    Console.WriteLine($"Document Name :: {dict?.GetString("name")}");
                }
            }
            // end::query-where[]
        }

        private static void UseCollectionContains()
        {
            Console.WriteLine("Collection Operator CONTAINS");
            var db = _Database;

            // tag::query-collection-operator-contains[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"),
                    SelectResult.Property("public_likes"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("hotel"))
                    .And(ArrayFunction.Contains(Expression.Property("public_likes"),
                        Expression.String("Armani Langworth"))))) {
                foreach (var result in query.Execute()) {
                    var publicLikes = result.GetArray("public_likes");
                    var jsonString = JsonConvert.SerializeObject(publicLikes);
                    Console.WriteLine($"Public Likes :: {jsonString}");
                }
            }
            // end::query-collection-operator-contains[]
        }

        private static void UseCollectionIn()
        {
            Console.WriteLine("Collection Operator IN");
            var db = _Database;

            // tag::query-collection-operator-in[]
            var values = new IExpression[]
                { Expression.Property("first"), Expression.Property("last"), Expression.Property("username") };

            using (var query = QueryBuilder.Select(
                    SelectResult.All())
                .From(DataSource.Database(db))
                .Where(Expression.String("Armani").In(values))) {
                foreach (var result in query.Execute()) {
                    var body = result.GetDictionary(0);
                    var jsonString = JsonConvert.SerializeObject(body);
                    Console.WriteLine($"In results :: {jsonString}");
                }
            }
            // end::query-collection-operator-in[]
        }

        private static void SelectLike()
        {
            Console.WriteLine("Like");
            var db = _Database;

            // tag::query-like-operator[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Function.Lower(Expression.Property("name")).Like(Expression.String("Royal Engineers Museum"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-like-operator[]
        }

        private static void SelectWildcardLike()
        {
            Console.WriteLine("Wildcard Like");
            var db = _Database;

            // tag::query-like-operator-wildcard-match[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Function.Lower(Expression.Property("name")).Like(Expression.String("Eng%e%"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-like-operator-wildcard-match[]
        }

        private static void SelectWildcardCharacterLike()
        {
            Console.WriteLine("Wildchard Characters");
            var db = _Database;

            // tag::query-like-operator-wildcard-character-match[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Expression.Property("name").Like(Expression.String("Royal Eng____rs Museum"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-like-operator-wildcard-character-match[]
        }

        private static void SelectRegex()
        {
            Console.WriteLine("Regex");
            var db = _Database;

            // tag::query-regex-operator[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Expression.Property("name").Regex(Expression.String("\\bEng.*e\\b"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-regex-operator[]
        }

        private static void SelectJoin()
        {
            Console.WriteLine("Join");
            var db = _Database;

            // tag::query-join[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Expression.Property("name").From("airline")),
                    SelectResult.Expression(Expression.Property("callsign").From("airline")),
                    SelectResult.Expression(Expression.Property("destinationairport").From("route")),
                    SelectResult.Expression(Expression.Property("stops").From("route")),
                    SelectResult.Expression(Expression.Property("airline").From("route")))
                .From(DataSource.Database(db).As("airline"))
                .Join(Join.InnerJoin(DataSource.Database(db).As("route"))
                    .On(Meta.ID.From("airline").EqualTo(Expression.Property("airlineid").From("route"))))
                .Where(Expression.Property("type").From("route").EqualTo(Expression.String("route"))
                    .And(Expression.Property("type").From("airline").EqualTo(Expression.String("airline")))
                    .And(Expression.Property("sourceairport").From("route").EqualTo(Expression.String("RIX"))))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-join[]
        }

        private static void GroupBy()
        {
            Console.WriteLine("GroupBy");
            var db = _Database;

            // tag::query-groupby[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Function.Count(Expression.All())),
                    SelectResult.Property("country"),
                    SelectResult.Property("tz"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("airport"))
                    .And(Expression.Property("geo.alt").GreaterThanOrEqualTo(Expression.Int(300))))
                .GroupBy(Expression.Property("country"), Expression.Property("tz"))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine(
                        $"There are {result.GetInt("$1")} airports in the {result.GetString("tz")} timezone located in {result.GetString("country")} and above 300 ft");
                }
            }
            // end::query-groupby[]
        }

        private static void OrderBy()
        {
            Console.WriteLine("OrderBy");
            var db = _Database;

            // tag::query-orderby[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("title"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("hotel")))
                .OrderBy(Ordering.Property("title").Ascending())
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Title :: {result.GetString("title")}");
                }
            }
            // end::query-orderby[]
        }

      // ### EXPLAIN statement
      private static void TestExplainStatement()
      // For Documentation
      {
        var db = _Database;
          // tag::query-explain-all[]
        var query =
          QueryBuilder
            .Select(SelectResult.All())
            .From(DataSource.Database(db))
            .Where(Expression.Property("type").EqualTo(Expression.String("hotel")))
            .GroupBy(Expression.Property("country"))
            .OrderBy(Ordering.Property("title").Ascending()) <i class="conum" data-value="8"></i><b>(8)</b>

          Console.WriteLine(query.Explain()); <i class="conum" data-value="9"></i><b>(9)</b>

          // end::query-explain-all[]
          // tag::query-explain-like[]
var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Database(db))
    .Where(Expression.Property("type").Like(Expression.String("%hotel%"))
      .And(Function.Lower(Expression.Property("name")).Like(Expression.String("%royal%")))); <i class="conum" data-value="10"></i><b>(10)</b>
  Console.WriteLine(query.Explain());

          // end::query-explain-like[]
          // tag::query-explain-nopfx[]
var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Database(db))
    .Where(Expression.Property("type").Like(Expression.String("hotel%"))
      .And(Function.Lower(Expression.Property("name")).Like(Expression.String("%royal%")))); <i class="conum" data-value="11"></i><b>(11)</b>

  Console.WriteLine(query.Explain());

          // end::query-explain-nopfx[]
          // tag::query-explain-function[]
var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Database(db))
    .Where(Function.Lower(Expression.Property("type")).EqualTo(Expression.String("hotel"))); <i class="conum" data-value="12"></i><b>(12)</b>

  Console.WriteLine(query.Explain());

          // end::query-explain-function[]
          // tag::query-explain-nofunction[]
        var query =
          QueryBuilder
            .Select(SelectResult.All())
            .From(DataSource.Database(db))
            .Where(Expression.Property("type")).EqualTo(Expression.String("hotel")); <i class="conum" data-value="13"></i><b>(13)</b>

          Console.WriteLine(query.Explain());

          // end::query-explain-nofunction[]
      }

      // end query-explain


        public void CreateFullTextIndex()
        {
            // tag::fts-index[]
            string[] indexProperties = new string[] { "overview", "name" };
            var config = new FullTextIndexConfiguration(indexProperties);
            db.CreateIndex("overviewFTSIndex", config);
            // end::fts-index[]
        }

        public void FullTextSearch()
        {
            Console.WriteLine("Full text search");
            // tag::fts-query[]

            var db = _database;
            var ftsQuery = db.CreateQuery("SELECT * FROM _ WHERE MATCH(overviewFTSIndex, 'Michigan') ORDER BY RANK(overviewFTSIndex)");
            foreach (var result in ftsQuery.Execute())
            {
                Console.WriteLine($"Document id {result.GetString(0)}");
            }
            }
            // end::fts-query[]
        }


        private static void CreateFullTextIndex_Querybuilder()
        {
            // tag::fts-index_Querybuilder[]
            var db = _Database;

            // end::fts-index_Querybuilder[]
            if (_NeedsExtraDocs) {
                var tasks = new[] { "buy groceries", "play chess", "book travels", "buy museum tickets" };
                foreach (var task in tasks) {
                    using (var doc = new MutableDocument()) {
                        doc.SetString("type", "task");
                        doc.SetString("name", task);
                        db.Save(doc);
                    }
                }
            }

            // tag::fts-index_Querybuilder[]

            var index = IndexBuilder.FullTextIndex(FullTextIndexItem.Property("overview")).IgnoreAccents(false);
            db.CreateIndex("overviewFTSIndex", index);
            // end::fts-index_Querybuilder[]
        }

        private static void FullTextSearch_Querybuilder()
        {
            Console.WriteLine("Full text search");
            var db = _Database;

            // tag::fts-query_Querybuilder[]
            var whereClause = FullTextFunction.Match("overviewFTSIndex", "'michigan'");

            using (var query = QueryBuilder.Select(SelectResult.Expression(Meta.ID))
                .From(DataSource.Database(db))
                .Where(whereClause)) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Document id {result.GetString(0)}");
                }
            }
            // end::fts-query_Querybuilder[]
        }
        private static void StartReplication()
        {
            var db = _Database;

            /*
             * This requires Sync Gateway running with the following config, or equivalent:
             *
             * {
             *     "log":["*"],
             *     "databases": {
             *         "db": {
             *             "server":"walrus:",
             *             "users": {
             *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
             *             }
             *         }
             *     }
             * }
             */

            // tag::replication[]
            // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)
            var url = new Uri("ws://localhost:4984/db");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(db, target)
            {
                ReplicatorType = ReplicatorType.Pull
            };

            var replicator = new Replicator(config);
            replicator.Start();
            // end::replication[]

            _Replicator = replicator;
        }

        private static void VerboseReplicatorLogging()
        {
            // tag::replication-logging[]
            // deprecated
            Database.SetLogLevel(LogDomain.Replicator, LogLevel.Verbose);
            Database.SetLogLevel(LogDomain.Network, LogLevel.Verbose);
            // end::replication-logging[]
        }

        private static void ConsoleLogging()
        {
            // tag::console-logging[]
            Database.Log.Console.Domains = LogDomain.All; <i class="conum" data-value="14"></i><b>(14)</b>
            Database.Log.Console.LogLevel = LogLevel.Verbose; <i class="conum" data-value="15"></i><b>(15)</b>

            // end::console-logging[]

            // tag::console-logging-db[]
            Database.Log.Console.Domains = LogDomain.Database;

            // end::console-logging-db[]
        }

        private static void FileLogging()
        {
            // tag::file-logging[]
            var tempFolder = Path.Combine(Service.GetInstance&lt;IDefaultDirectoryResolver&gt;().DefaultDirectory(), "cbllog");
            var config = new LogFileConfiguration(tempFolder) <i class="conum" data-value="16"></i><b>(16)</b>
            {
                MaxRotateCount = 5, <i class="conum" data-value="17"></i><b>(17)</b>
                MaxSize = 10240, <i class="conum" data-value="18"></i><b>(18)</b>
                UsePlainText = false  <i class="conum" data-value="19"></i><b>(19)</b>
            };
            Database.Log.File.Config = config; // Apply configuration
            Database.Log.File.Level = LogLevel.Info; <i class="conum" data-value="20"></i><b>(20)</b>

            // end::file-logging[]
        }

        private static void EnableCustomLogging()
        {
            // tag::set-custom-logging[]
            Database.Log.Custom = new LogTestLogger(); <i class="conum" data-value="21"></i><b>(21)</b>
            or
            Database.Log.Custom = new LogTestLogger { Level = LogLevel.Warning };

            // end::set-custom-logging[]
        }

        private static void WriteConsoleLog()
        {
            // tag::write-console-logmsg[]
            Database.Log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
            // end::write-console-logmsg[]
        }
        private static void WriteCustomLog()
        {
            // tag::write-custom-logmsg[]
            Database.Log.Custom?.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
            // end::write-custom-logmsg[]
        }


        private static void WriteFileLog()
        {
            // tag::write-file-logmsg[]
            Database.Log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
            // end::write-file-logmsg[]
        }

        private static void EnableBasicAuth()
        {
            var database = _Database;

            // tag::basic-authentication[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.Authenticator = new BasicAuthenticator("john", "pass");

            var replicator = new Replicator(config);
            replicator.Start();
            // end::basic-authentication[]
        }

        private static void EnableSessionAuth()
        {
            var database = _Database;

            // tag::session-authentication[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.Authenticator = new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447");

            var replicator = new Replicator(config);
            replicator.Start();
            // end::session-authentication[]
        }

        private static void SetupReplicatorListener()
        {
            var replicator = _Replicator;

            // tag::replication-status[]
            replicator.AddChangeListener((sender, args) =&gt;
            {
                if (args.Status.Activity == ReplicatorActivityLevel.Stopped) {
                    Console.WriteLine("Replication stopped");
                }
            });
            // end::replication-status[]
        }




    //  BEGIN PendingDocuments IB -- 11/Feb/21 --
    private static void ReplicatorPendingDocuments()
    {
        // tag::replication-pendingdocuments[]
        var url = new Uri("ws://localhost:4984/mydatabase");
        var target = new URLEndpoint(url);
        var database = new Database("myDB");
        var config = new ReplicatorConfiguration(database, target);
        config.ReplicatorType  = ReplicatorType.Push;

        // tag::replication-push-pendingdocumentids[]
        var replicator = new Replicator(config);

        var mydocids =
          new HashSet &lt;string&gt; (replicator.GetPendingDocumentIDs()); <i class="conum" data-value="22"></i><b>(22)</b>

        // end::replication-push-pendingdocumentids[]

        if (mydocids.Count &gt; 0)
        {
            Console.WriteLine($"There are {mydocids.Count} documents pending");
            replicator.AddChangeListener((sender, change) =&gt;
            {
                Console.WriteLine($"Replicator activity level is " +
                                  change.Status.Activity.ToString());
                // iterate and report-on previously
                // retrieved pending docids 'list'
                foreach (var thisId in mydocids)
                    // tag::replication-push-isdocumentpending[]
                    if (!replicator.IsDocumentPending(thisId)) <i class="conum" data-value="23"></i><b>(23)</b>
                    {
                        Console.WriteLine($"Doc ID {thisId} now pushed");
                    };
                // end::replication-push-isdocumentpending[]
            });

            replicator.Start();
        }
    // end::replication-pendingdocuments[]
    }


//  END PendingDocuments IB -- 11/Feb/21 --



		private static void ReplicatorDocumentEvent()
        {
            var replicator = _Replicator;

            // tag::add-document-replication-listener[]
            var token = replicator.AddDocumentReplicationListener((sender, args) =&gt;
            {
                var direction = args.IsPush ? "Push" : "Pull";
                Console.WriteLine($"Replication type :: {direction}");
                foreach (var document in args.Documents) {
                    if (document.Error == null) {
                        Console.WriteLine($"Doc ID :: {document.Id}");
                        if (document.Flags.HasFlag(DocumentFlags.Deleted)) {
                            Console.WriteLine("Successfully replicated a deleted document");
                        }
                    } else {
                        // There was an error
                    }
                }
            });

            replicator.Start();
            // end::add-document-replication-listener[]

            // tag::remove-document-replication-listener[]
            replicator.RemoveChangeListener(token);
            // end::remove-document-replication-listener[]
        }

        private static void SetupReplicatorErrorListener()
        {
            // This can be done in the SetupReplicatorListener method
            // But it is separate so that we can have two documentation entries

            var replicator = _Replicator;

            // tag::replication-error-handling[]
            replicator.AddChangeListener((sender, args) =&gt;
            {
                if (args.Status.Error != null) {
                    Console.WriteLine($"Error :: {args.Status.Error}");
                }
            });
            // end::replication-error-handling[]
        }

        private static void DatabaseReplica()
        {
            var db = _Database;
            using (var database2 = new Database("backup")) {
                // EE feature: This code will not compile on the community edition
                // tag::database-replica[]
                var targetDatabase = new DatabaseEndpoint(database2);
                var config = new ReplicatorConfiguration(db, targetDatabase)
                {
                    ReplicatorType = ReplicatorType.Push
                };

                var replicator = new Replicator(config);
                replicator.Start();
                // end::database-replica[]

                _Replicator?.Stop();
                _Replicator = replicator;
            }
        }

        private static void PinCertificate()
        {
            // Note: No certificate is included here, so this code is for show only
            var url = new Uri("wss://localhost:4984/db");
            var target = new URLEndpoint(url);
            var db = _Database;

            // tag::certificate-pinning[]
            // Note: `GetCertificate` is a fake method. This would be the platform-specific method
            // to find and load the certificate as an instance of `X509Certificate2`.
            // For .NET Core / .NET Framework this can be loaded from the filesystem path.
            // For UWP, from the assets directory.
            // For iOS, from the main bundle.
            // For Android, from the assets directory.
            var certificate = GetCertificate("cert.cer");
            var config = new ReplicatorConfiguration(db, target)
            {
                PinnedServerCertificate = certificate
            };
            // end::certificate-pinning[]
        }

        private static void ReplicationCustomHeaders()
        {
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            // tag::replication-custom-header[]
            var config = new ReplicatorConfiguration(database, target)
            {
                Headers = new Dictionary&lt;string, string&gt;
                {
                    ["CustomHeaderName"] = "Value"
                }
            };
            // end::replication-custom-header[]
        }

        private static void PushWithFilter(Database database)
        {
            // tag::replication-push-filter[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            var config = new ReplicatorConfiguration(database, target);
            config.PushFilter = (document, flags) =&gt; <i class="conum" data-value="1"></i><b>(1)</b>
            {
                if (flags.HasFlag(DocumentFlags.Deleted)) {
                    return false;
                }

                return true;
            };

            // Dispose() later
            var replicator = new Replicator(config);
            replicator.Start();
            // end::replication-push-filter[]
        }

        private static void PullWithFilter(Database database)
        {
            // tag::replication-pull-filter[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            var config = new ReplicatorConfiguration(database, target);
            config.PullFilter = (document, flags) =&gt; <i class="conum" data-value="1"></i><b>(1)</b>
            {
                if (document.GetString("type") == "draft") {
                    return false;
                }

                return true;
            };

            // Dispose() later
            var replicator = new Replicator(config);
            replicator.Start();
            // end::replication-pull-filter[]
        }

        public void TestCustomRetryConfig()
        {
        // tag::replication-retry-config[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            var config = new ReplicatorConfiguration(database, target);

        //  other config as required . . .

        // tag::replication-set-heartbeat[]
            config.Heartbeat = TimeSpan.FromSeconds(120); //  <i class="conum" data-value="24"></i><b>(24)</b>
        // end::replication-set-heartbeat[]
        // tag::replication-set-maxattempts[]
            config.Maxattempts = 20; //  <i class="conum" data-value="25"></i><b>(25)</b>
        // end::replication-set-maxattempts[]
        // tag::replication-set-maxattemptwaittime[]
            config.MaxAttemptWaitTime = TimeSpan.FromSeconds(600); //  <i class="conum" data-value="26"></i><b>(26)</b>
        // end::replication-set-maxattemptwaittime[]

        //  other config as required . . .

            var repl = new Replicator(config);

        // end::replication-retry-config[]
        }


        private static void UsePredictiveModel()
        {
            using (var db = new Database("mydb")) {
                // tag::register-model[]
                var model = new ImageClassifierModel();
                Database.Prediction.RegisterModel("ImageClassifier", model);
                // end::register-model[]

                // tag::predictive-query-value-index[]
                var index = IndexBuilder.ValueIndex(ValueIndexItem.Property("label"));
                db.CreateIndex("value-index-image-classifier", index);
                // end::predictive-query-value-index[]

                // tag::unregister-model[]
                Database.Prediction.UnregisterModel("ImageClassifier");
                // end::unregister-model[]
            }
        }

        private static void UsePredictiveIndex()
        {
            using (var db = new Database("mydb")) {
                // tag::predictive-query-predictive-index[]
                var input = Expression.Dictionary(new Dictionary&lt;string, object&gt;
                {
                    ["photo"] = Expression.Property("photo")
                });

                var index = IndexBuilder.PredictiveIndex("ImageClassifier", input);
                db.CreateIndex("predictive-index-image-classifier", index);
                // end::predictive-query-predictive-index[]
            }
        }

        private static void DoPredictiveQuery()
        {
            using (var db = new Database("mydb")) {
                // tag::predictive-query[]
                var input = Expression.Dictionary(new Dictionary&lt;string, object&gt;
                {
                    ["photo"] = Expression.Property("photo")
                });
                var prediction = PredictiveModel.predict("ImageClassifier", input); <i class="conum" data-value="1"></i><b>(1)</b>

                using (var q = QueryBuilder.Select(SelectResult.All())
                    .From(DataSource.Database(db))
                    .Where(prediction.Property("label").EqualTo(Expression.String("car"))
                        .And(prediction.Property("probability").GreaterThanOrEqualTo(Expression.Double(0.8))))) {
                    var result = q.Execute();
                    Console.WriteLine($"Number of rows: {result.Count()}");
                }
                // end::predictive-query[]
            }
        }

        static void Main(string[] args)
        {
            // This only needs to be done once for whatever platform the executable is running
            // (UWP, iOS, Android, or desktop)
            Couchbase.Lite.Support.NetDesktop.Activate();

            CreateNewDatabase();
            CreateDocument();
            UpdateDocument();
            UseTypedAccessors();
            DoBatchOperation();
            UseBlob();
            SelectMeta();

            LoadPrebuilt();
            CreateIndex();
            SelectWhere();
            UseCollectionContains();
            SelectLike();
            SelectWildcardLike();
            SelectWildcardCharacterLike();
            SelectRegex();
            SelectJoin();
            GroupBy();
            OrderBy();

            CreateFullTextIndex();
            FullTextSearch();
            StartReplication();
            SetupReplicatorListener();

            _Replicator.Stop();
            while (_Replicator.Status.Activity != ReplicatorActivityLevel.Stopped) {
                // Database cannot close until replicators are stopped
                Console.WriteLine($"Waiting for replicator to stop (currently {_Replicator.Status.Activity})...");
                Thread.Sleep(200);
            }

            _Database.Close();
        }

        #endregion
    }

    /* ----------------------------------------------------------- */
    /* ---------------------  ACTIVE SIDE  ----------------------- */
    /* ---------------  stubs for documentation  ----------------- */
    /* ----------------------------------------------------------- */

    class ActivePeer : IMessageEndpointDelegate
    {
        ActivePeer()
        {
            var id = "";

            // tag::message-endpoint[]
            var database = new Database("dbname");

            // The delegate must implement the `IMessageEndpointDelegate` protocol.
            var messageEndpointTarget = new MessageEndpoint(uid: "UID:123", target: "",
                protocolType: ProtocolType.MessageStream, delegateObject: this);
            // end::message-endpoint[]

            // tag::message-endpoint-replicator[]
            var config = new ReplicatorConfiguration(database, messageEndpointTarget);

            // Create the replicator object
            var replicator = new Replicator(config);
            // Start the replicator
            replicator.Start();
            // end::message-endpoint-replicator[]
        }

        // tag::create-connection[]
        /* implementation of MessageEndpointDelegate */
        public IMessageEndpointConnection CreateConnection(MessageEndpoint endpoint)
        {
            var connection = new ActivePeerConnection(); /* implements MessageEndpointConnection */
            return connection;
        }
        // end::create-connection[]
    }

    class ActivePeerConnection : IMessageEndpointConnection
    {
        private IReplicatorConnection _replicatorConnection;

        public void Disconnect()
        {
            // tag::active-replicator-close[]
            _replicatorConnection?.Close(null);
            // end::active-replicator-close[]
        }

        public void Receive(byte[] data)
        {
            // tag::active-peer-receive[]
            var message = Message.FromBytes(data);
            _replicatorConnection?.Receive(message);
            // end::active-peer-receive[]
        }

        // tag::active-peer-close[]
        /* implementation of MessageEndpointConnection */
        public async Task Close(Exception error)
        {
            // await socket.Close, etc (or do nothing if already closed)
            // throw MessagingException if something goes wrong (though
            // since it is "close" nothing special will happen)
        }
        // end::active-peer-close[]

        // tag::active-peer-open[]
        /* implementation of MessageEndpointConnection */
        public async Task Open(IReplicatorConnection connection)
        {
            _replicatorConnection = connection;
            // await socket.Open(), etc
            // throw MessagingException if something goes wrong
        }
        // end::active-peer-open[]

        // tag::active-peer-send[]
        /* implementation of MessageEndpointConnection */
        public async Task Send(Message message)
        {
            var data = message.ToByteArray();
            // await Socket.Send(), etc
            // throw MessagingException if something goes wrong
        }
        // end::active-peer-send[]
    }

    /* ----------------------------------------------------------- */
    /* ---------------------  PASSIVE SIDE  ---------------------- */
    /* ---------------  stubs for documentation  ----------------- */
    /* ----------------------------------------------------------- */
    class PassivePeerConnection : IMessageEndpointConnection
    {
        private MessageEndpointListener _messageEndpointListener;
        private IReplicatorConnection _replicatorConnection;

        public void StartListener()
        {
            // tag::listener[]
            var database = new Database("mydb");
            var config = new MessageEndpointListenerConfiguration(database, ProtocolType.MessageStream);
            _messageEndpointListener = new MessageEndpointListener(config);
            // end::listener[]
        }

        public void StopListener()
        {
            // tag::passive-stop-listener[]
            _messageEndpointListener?.CloseAll();
            // end::passive-stop-listener[]
        }

        public void AcceptConnection()
        {
            // tag::advertizer-accept[]
            var connection = new PassivePeerConnection(); /* implements MessageEndpointConnection */
            _messageEndpointListener?.Accept(connection);
            // end::advertizer-accept[]
        }

        public void Disconnect()
        {
            // tag::passive-replicator-close[]
            _replicatorConnection?.Close(null);
            // end::passive-replicator-close[]
        }

        public void Receive(byte[] data)
        {
            // tag::passive-peer-receive[]
            var message = Message.FromBytes(data);
            _replicatorConnection?.Receive(message);
            // end::passive-peer-receive[]
        }

        // tag::passive-peer-close[]
        /* implementation of MessageEndpointConnection */
        public async Task Close(Exception error)
        {
            // await socket.Close, etc (or do nothing if already closed)
            // throw MessagingException if something goes wrong (though
            // since it is "close" nothing special will happen)
        }
        // end::passive-peer-close[]

        // tag::passive-peer-open[]
        /* implementation of MessageEndpointConnection */
        public Task Open(IReplicatorConnection connection)
        {
            _replicatorConnection = connection;
            // socket should already be open on the passive side
            return Task.FromResult(true);
        }
        // end::passive-peer-open[]

        // tag::passive-peer-send[]
        /* implementation of MessageEndpointConnection */
        public async Task Send(Message message)
        {
            var data = message.ToByteArray();
            // await Socket.Send(), etc
            // throw MessagingException if something goes wrong
        }
        // end::passive-peer-send[]
    }

    // tag::predictive-model[]
    // tensorFlowModel is a fake implementation
    // this would be the implementation of the ml model you have chosen
    class TensorFlowModel
    {
        public static IDictionary&lt;string, object&gt; PredictImage(byte[] data)
        {
            // Do calculations, etc
            return null;
        }
    }

    class ImageClassifierModel : IPredictiveModel
    {
        public DictionaryObject Predict(DictionaryObject input)
        {
            var blob = input.GetBlob("photo");
            if (blob == null) {
                return null;
            }

            var imageData = blob.Content;
            // tensorFlowModel is a fake implementation
            // this would be the implementation of the ml model you have chosen
            var modelOutput = TensorFlowModel.PredictImage(imageData);
            return new MutableDictionaryObject(modelOutput); <i class="conum" data-value="1"></i><b>(1)</b>
        }
    }
    // end::predictive-model[]

    // tag::custom-logging[]
    private class LogTestLogger : ILogger
    {
        public LogLevel Level { get; set; }

        public void Reset()
        {
            _lines.Clear();
        }

        public void Log(LogLevel level, LogDomain domain, string message)
        {
            // handle the message, for example piping it to
            // a third party framework
        }
    }
    // end::custom-logging[]

    // tag::local-win-conflict-resolver[]
    class LocalWinConflictResolver : IConflictResolver
    {
        Document Resolve(Conflict conflict)
        {
            return conflict.LocalDocument;
        }
    }
    // end::local-win-conflict-resolver[]

    // tag::remote-win-conflict-resolver[]
    class RemoteWinConflictResolver : IConflictResolver
    {
        public Document Resolve(Conflict conflict)
        {
            return conflict.RemoteDocument;
        }
    }
    // end::remote-win-conflict-resolver[]

    // tag::merge-conflict-resolver[]
    class MergeConflictResolver : IConflictResolver
    {
        public Document Resolve(Conflict conflict)
        {
            var localDict = conflict.LocalDocument.ToDictionary();
            var remoteDict = conflict.RemoteDocument.ToDictionary();
            var result = localDict.Concat(remoteDict)
               .GroupBy(kv =&gt; kv.Key)
               .ToDictionary(g =&gt; g.Key, g =&gt; g.First().Value);
            return new MutableDocument(conflict.DocumentID, result);
        }
    }
    // end::merge-conflict-resolver[]
}

// N1QL QUERY

  public List&lt;Result&gt; docsonly_N1QLQueryString(Database argDB)
  {
      DatabaseConfiguration dbCfg = new DatabaseConfiguration();

      Database thisDb = new Database(dbName, dbCfg);

      // For Documentation -- N1QL Query
      // tag::query-syntax-n1ql[]
      var thisQuery =
          thisDb.CreateQuery("SELECT META().id AS thisId FROM _ WHERE type = \"hotel\""); <i class="conum" data-value="27"></i><b>(27)</b>

      return thisQuery.Execute().AllResults();

      // end::query-syntax-n1ql[]
  }


  public  List&lt;Result&gt; docsonly_N1QLQueryStringParams(Database argDB)
  {
      DatabaseConfiguration dbCfg = new DatabaseConfiguration();

      Database thisDb = new Database(dbName, dbCfg);

      // For Documentation -- N1QL Query
      // tag::query-syntax-n1ql-params[]
      // Declared elsewhere: Database argDB

      var thisQuery =
          thisDb.CreateQuery("SELECT META().id AS thisId FROM _ WHERE type = $type"); <i class="conum" data-value="28"></i><b>(28)</b>

      var n1qlParams = new Parameters();
      n1qlParams.SetString("type", "hotel"); <i class="conum" data-value="29"></i><b>(29)</b>
      thisQuery.Parameters = n1qlParams;

      return thisQuery.Execute().AllResults();

      // end::query-syntax-n1ql-params[]
  }


// QUERY RESULT SET HANDLING EXAMPLES

    public static void testQuerySyntaxAll()
    {
        // For Documentation
        var dbName = "travel-sample";

        string thisDocsId;
        string thisDocsName;
        string thisDocsType;
        string thisDocsCity;
        Dictionary&lt;string,object&gt; hotel = new Dictionary&lt;string,object&gt;();

        // tag::query-syntax-all[]
        var this_Db = new Database("hotels") ;

        var query = QueryBuilder
              .Select(SelectResult.All())
              .From(DataSource.Database(this_Db));

        // end::query-syntax-all[]

        // tag::query-access-all[]
        var results = query.Execute().AllResults();

        if (results?.Count &gt; 0)
        {
            List&lt;Dictionary&lt;string,object&gt;&gt; hotels = new List&lt;Dictionary&lt;string,object&gt;&gt;();
            foreach (var result in results)
            {
                // get the result into our dictionary object
                var thisDocsProps = result.GetDictionary(dbName); <i class="conum" data-value="30"></i><b>(30)</b>

                if (thisDocsProps != null)
                {
                    thisDocsId = thisDocsProps.GetString("id"); <i class="conum" data-value="31"></i><b>(31)</b>
                    thisDocsName = thisDocsProps.GetString("name");
                    thisDocsCity = thisDocsProps.GetString("city");
                    thisDocsType = thisDocsProps.GetString("type");
                    hotel = thisDocsProps.ToDictionary();
                    hotels.Add(hotel);
                }

            }
        }
        // end::query-access-all[]

    // tag::query-access-json[]

    foreach (var result in query.Execute().AsEnumerable()) {

        // get the result into a JSON String
                var thisDocsJSONString = result.ToJSON();<i class="conum" data-value="32"></i><b>(32)</b>

        // Get a native dictionary object using the JSON string
        var dictFromJSONstring =
              JsonConvert.
                DeserializeObject&lt;Dictionary&lt;string, object&gt;&gt;
                  (thisDocsJSONString); <i class="conum" data-value="33"></i><b>(33)</b>

        // use the created dictionary
        if (dictFromJSONstring != null)
        {
            thisDocsId = dictFromJSONstring["id"].ToString();
            thisDocsName = dictFromJSONstring["name"].ToString();
            thisDocsCity = dictFromJSONstring["city"].ToString();
            thisDocsType = dictFromJSONstring["type"].ToString();
        }

        //Get a custom object using the JSON string
        Hotel this_hotel =
            JsonConvert.DeserializeObject&lt;Hotel&gt;(thisDocsJSONString); <i class="conum" data-value="34"></i><b>(34)</b>

        // Store this hotel object in a list of hotels
        hotels.Add(
            this_hotel.Id.ToString(),
                this_hotel);

    } // end foreach result
    // end::query-access-json[]
  }


    private static void testQuerySyntaxProps()
    {
        // For Documentation
        var dbName = "travel-sample";
        // var this_Db = new Database(dbName);

        string thisDocsName;
        string thisDocsType;
        string thisDocsCity;
        // tag::query-syntax-props[]
        var this_Db = new Database("hotels") ;

        Dictionary&lt;string, object&gt; hotel = new Dictionary&lt;string, object&gt;();

        List&lt;Dictionary&lt;string, object&gt;&gt; hotels = new List&lt;Dictionary&lt;string, object&gt;&gt;();

        var query = QueryBuilder.Select(
                SelectResult.Property("type"),
                SelectResult.Property("name"),
                SelectResult.Property("city")).From(DataSource.Database(this_Db));
        // end::query-syntax-props[]

        // tag::query-access-props[]
        var results = query.Execute().AllResults();
        foreach (var result in results)
        {

            // get the returned array of k-v pairs into a dictionary
            hotel = result.ToDictionary();

            // add hotel dictionary to list of hotel dictionaries
            hotels.Add(hotel);

            // use the properties of the returned array of k-v pairs directly
            thisDocsType = result.GetString("type");
            thisDocsName = result.GetString("name");
            thisDocsCity = result.GetString("city");

        }

    // end::query-access-props[]
    } // test-query-access-props



    private static void testQuerySyntaxCount()
    {
        // For Documentation
        var dbName = "travel-sample";
        // var this_Db = new Database(dbName);

        Dictionary&lt;string, object&gt; hotel = new Dictionary&lt;string, object&gt;();
        List&lt;Dictionary&lt;string, object&gt;&gt; hotels = new List&lt;Dictionary&lt;string, object&gt;&gt;();

        // tag::query-syntax-count-only[]
        var this_Db = new Database("hotels") ;

        var query =
          QueryBuilder
            .Select(SelectResult.Expression(Function.Count(Expression.All())).As("mycount")) <i class="conum" data-value="35"></i><b>(35)</b>
            .From(DataSource.Database(this_Db));

        // end::query-syntax-count-only[]


        // tag::query-access-count-only[]

        var results = query.Execute().AllResults();

        foreach (var result in results)
        {

            var numberOfDocs = result.GetInt("mycount"); <i class="conum" data-value="36"></i><b>(36)</b>

        }

        // end::query-access-count-only[]
    }




    private static void ibQueryForID()
    {

        // For Documentation
        var dbName = "travel-sample";
        // var this_Db = new Database(dbName);

        Dictionary&lt;string, object&gt; hotel = new Dictionary&lt;string, object&gt;();
        List&lt;Dictionary&lt;string, object&gt;&gt; hotels = new List&lt;Dictionary&lt;string, object&gt;&gt;();


        // tag::query-syntax-id[]
        var this_Db = new Database("hotels") ;

        var query = QueryBuilder
                .Select(SelectResult.Expression(Meta.ID).As("this_ID"))
                .From(DataSource.Database(this_Db));

        // end::query-syntax-id[]


        // tag::query-access-id[]
        var results = query.Execute().AllResults();
        foreach (var result in results)
        {

            var thisDocsID = result.GetString("this_ID"); <i class="conum" data-value="37"></i><b>(37)</b>
            var doc = this_Db.GetDocument(thisDocsID);
        }

        // end::query-access-id[]
    }


// tag::query-syntax-pagination-all[]
    private static void testQueryPagination()
    {
      // For Documentation
      var dbName = "travel-sample";
      // var this_Db = new Database(dbName);

    // tag::query-syntax-pagination[]
      var this_Db = new Database("hotels") ;

      var thisLimit = 20;
      var thisOffset = 0;

      // get a count of the number of docs matching the query
      var countQuery =
          QueryBuilder
              .Select(SelectResult.Expression(Function.Count(Expression.All())).As("mycount"))
              .From(DataSource.Database(this_Db));
      var numberOfDocs =
          countQuery.Execute().AllResults().ElementAt(0).GetInt("mycount");

      if (numberOfDocs &lt; thisLimit) {
          thisLimit = numberOfDocs;
      }

      while (thisOffset &lt; numberOfDocs)
      {
          var listQuery =
              QueryBuilder
                  .Select(SelectResult.All())
                  .From(DataSource.Database(this_Db))
                  .Limit(Expression.Int(thisLimit), Expression.Int(thisOffset)); <i class="conum" data-value="38"></i><b>(38)</b>

          foreach (var result in listQuery.Execute().AllResults())
          {
              // Display and or process query results batch

          }

          thisOffset = thisOffset + thisLimit;

      } // end while

// end::query-syntax-pagination[]
// end::query-syntax-pagination-all[]
    }

    // JSONAPIMETHODS



        public void JsonApiDocument()
        {

            // tag::tojson-document[]
            Database this_DB = new Database("travel-sample");
            Database newDb = new Database("ournewdb");

            // Get a document
            var thisDoc = this_Db.GetDocument("hotel_10025");

            // Get document data as JSON String
            var thisDocAsJsonString = thisDoc?.ToJSON(); <i class="conum" data-value="39"></i><b>(39)</b>

            // Get Json Object from the Json String
            JObject myJsonObj = JObject.Parse(thisDocAsJsonString);

            // Get Native Object (anhotel) from JSON String
            List&lt;Hotel&gt; thehotels = new List&lt;Hotel&gt;();

            Hotel anhotel = new Hotel();
            anhotel = JsonConvert.DeserializeObject&lt;Hotel&gt;(thisDocAsJsonString);
            thehotels.Add(anhotel);

            // Update the retrieved native object
            anhotel.Name = "A Copy of " + anhotel.Name;
            anhotel.Id = "2001";

            // Convert the updated object back to a JSON string
            var newJsonString = JsonConvert.SerializeObject(anhotel);

            // Update new document with JSOn String
            MutableDocument newhotel =
                new MutableDocument(anhotel.Id, newJsonString); <i class="conum" data-value="40"></i><b>(40)</b>

            foreach (string key in newhotel.ToDictionary().Keys)
            {
                System.Console.WriteLine("Data -- {0} = {1}",
                    key, newhotel.GetValue(key));
            }

            newDb.Save(newhotel);

            var thatDoc = newDb.GetDocument("2001").ToJSON(); <i class="conum" data-value="41"></i><b>(41)</b>
            System.Console.Write(thatDoc);

            // end::tojson-document[]


        //    // tag::tojson-document-output[]
        //    JSON String = { "description":"Very good and central","id":"1000","country":"France","name":"Hotel Ted","type":"hotel","city":"Paris"}
        //             type = hotel
        //             id = 1000
        //             country = France
        //             city = Paris
        //             description = Very good and central
        //             name = Hotel Ted
        //        // end::tojson-document-output[]
        //         */

        } // End JSONAPIDocument


    public void JsonApiArray()
        {
            // Init for docs
            //var this_Db = DataStore.getDbHandle();
            var ourdbname = "ournewdb";

            if (Database.Exists(ourdbname, "/"))
            {
                Database.Delete(ourdbname, "/");
            }

        // tag::tojson-array[]

            Database dbNew = new Database(ourdbname);

            // JSON String -- an Array (3 elements. including embedded arrays)
            var thisJSONstring = "[{'id':'1000','type':'hotel','name':'Hotel Ted','city':'Paris','country':'France','description':'Undefined description for Hotel Ted'},{'id':'1001','type':'hotel','name':'Hotel Fred','city':'London','country':'England','description':'Undefined description for Hotel Fred'},                        {'id':'1002','type':'hotel','name':'Hotel Ned','city':'Balmain','country':'Australia','description':'Undefined description for Hotel Ned','features':['Cable TV','Toaster','Microwave']}]".Replace("'", "\"");

            // Get JSON Array from JSON String
            JArray myJsonObj = JArray.Parse(thisJSONstring);

            // Create mutable array using JSON String Array
            var myArray = new MutableArrayObject();
            myArray.SetJSON(thisJSONstring);  <i class="conum" data-value="42"></i><b>(42)</b>


            // Create a new documenty for each array element
            for (int i = 0; i &lt; myArray.Count; i++)
            {
                var dict = myArray.GetDictionary(i);
                var docid = myArray[i].Dictionary.GetString("id");
                var newdoc = new MutableDocument(docid, dict.ToDictionary()); <i class="conum" data-value="43"></i><b>(43)</b>
                dbNew.Save(newdoc);
            }

            // Get one of the created docs and iterate through one of the embedded arrays
            var extendedDoc = dbNew.GetDocument("1002");
            var features = extendedDoc.GetArray("features");
            <i class="conum" data-value="44"></i><b>(44)</b>
            foreach (string feature in features) {
                System.Console.Write(feature);
                //process array item as required
            }
            var featuresJSON = extendedDoc.GetArray("features").ToJSON(); <i class="conum" data-value="45"></i><b>(45)</b>

            // end::tojson-array[]
        }


        public void JsonApiDictionary()
        {

            var ourdbname = "ournewdb";

            if (Database.Exists(ourdbname, "/"))
            {
                Database.Delete(ourdbname, "/");
            }
            Database dbNew = new Database(ourdbname);

            // tag::tojson-dictionary[]

            // Get dictionary from JSONstring
            var aJSONstring = "{'id':'1002','type':'hotel','name':'Hotel Ned','city':'Balmain','country':'Australia','description':'Undefined description for Hotel Ned','features':['Cable TV','Toaster','Microwave']}".Replace("'", "\"");
            var myDict = new MutableDictionaryObject(json: aJSONstring); <i class="conum" data-value="46"></i><b>(46)</b>

            // use dictionary to get name value
            var name = myDict.GetString("name");


            // Iterate through keys
            foreach (string key in myDict.Keys)
            {
                System.Console.WriteLine("Data -- {0} = {1}", key, myDict.GetValue(key).ToString());

            }
            // end::tojson-dictionary[]

            /*
            // tag::tojson-dictionary-output[]

                mono-stdout: Data -- id = 1002
                mono-stdout: Data -- type = hotel
                mono-stdout: Data -- name = Hotel Ned
                mono-stdout: Data -- city = Balmain
                mono-stdout: Data -- country = Australia
                mono-stdout: Data -- description = Undefined description for Hotel Ned
                mono-stdout: Data -- features = Couchbase.Lite.MutableArrayObject

            // end::tojson-dictionary-output[]
            */
        } /* end of func */


         public void JsonApiBlob()
        {
            // Init
            var ourpath = DataStore.getUserFolder();
            var ourdbname = "ournewdb";
            var userName = "ian";
            //ourpath = Path.Combine(ourpath,userName);

            if (Database.Exists(ourdbname, ourpath))
            {
                Database.Delete(ourdbname, ourpath);
            }
            var dbCfg = new DatabaseConfiguration();
            dbCfg.Directory=ourpath;
            Database dbNew = new Database(ourdbname,dbCfg);

            // tag::tojson-blob[]

            // Initialize base document for blob from a JSON string
            var docId = "1002";
            var aJSONstring = "{'ref':'hotel_1002','type':'hotel','name':'Hotel Ned'," +
                "'city':'Balmain','country':'Australia'," +
                "'description':'Undefined description for Hotel Ned'," +
                "'features':['Cable TV','Toaster','Microwave']}".Replace("'", "\"");
            var myDoc = new MutableDocument(docId, aJSONstring); <i class="conum" data-value="47"></i><b>(47)</b>


            // Get the content (an image), create blob and add to doc)
            var defaultDirectory =
                Path.Combine(Service.GetInstance&lt;IDefaultDirectoryResolver&gt;()
                            .DefaultDirectory(),
                                userName);
            var myImagePath = Path.Combine(defaultDirectory, "avatarimage.jpg");
            var myImageUri = new Uri(myImagePath.ToString());
            var myBlob = new Blob("image/jpg", myImageUri); <i class="conum" data-value="48"></i><b>(48)</b>
            myDoc.SetBlob("avatar", myBlob); <i class="conum" data-value="49"></i><b>(49)</b>


            // This example generates a 'blob not saved' exception
            try { Console.WriteLine("myBlob (unsaved) as JSON = {0}", myBlob.ToJSON());}
                catch (Exception e)
                    {Console.WriteLine("Exception = {0}", e.Message);}

            dbNew.Save(myDoc);

            // Alternatively -- depending on use case
            dbNew.SaveBlob(new Blob("image/jpg", myImageUri)); <i class="conum" data-value="50"></i><b>(50)</b>


            // Retrieve saved doc, get blob as JSON andheck its still a 'blob'
            var sameDoc = dbNew.GetDocument(docId);
            var reconstitutedBlob = new MutableDictionaryObject().
                SetDictionary("blobCOPY", new MutableDictionaryObject(sameDoc.GetBlob("avatar").ToJSON())); <i class="conum" data-value="51"></i><b>(51)</b>

            if (Blob.IsBlob(
                    reconstitutedBlob.GetDictionary("blobCOPY").ToDictionary()))  <i class="conum" data-value="52"></i><b>(52)</b>
            {
               //... process accordingly
               Console.WriteLine("Its a Blob!!");
            }

            // end::tojson-blob[]
            var datavalue = "";
            foreach (string key in myDoc.Keys)
            {
                if (key == "features")
                {
                    datavalue = "features are: ";
                    foreach (string item in myDoc.GetArray(key))
                    {
                        datavalue = datavalue + ", " + item;
                    }
                }
                else if (key == "avatar")
                {
                    datavalue = sameDoc.GetBlob(key).ToJSON();
                }
                else
                {
                    datavalue = sameDoc.GetValue(key).ToString();
                }

                System.Console.WriteLine(" Data -- {0} = {1}", key, datavalue);
            }

            // System.Console.WriteLine(" reconstitutedBlob = {0}", reconstitutedBlob.GetDictionary("blobCOPY").ToJSON());



            //}

            /*
            // tag::tojson-blob-output[]


                Exception = Missing Digest Due To Blob Is Not Saved To Database yet.

                Data -- id = 1002
                Data -- type = hotel
                Data -- name = Hotel Ned
                Data -- city = Balmain
                Data -- country = Australia
                Data -- description = Undefined description for Hotel Ned
                Data -- features = features are: , Cable TV, Toaster, Microwave
                Data -- avatar = {"digest":"sha1-sdCxeOeP3IZV4FEvVVlvtulpWA8=","length":2975,"content_type":"image/jpg","@type":"blob"}

                blobAsJSONstring = {"digest":"sha1-sdCxeOeP3IZV4FEvVVlvtulpWA8=","length":2975,"content_type":"image/jpg","@type":"blob"}

            // end::tojson-blob-output[]
            */
        } /* end of func */




  } // end of class



// p2p sync items


// tag::listener-simple[]
var thisConfig = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="53"></i><b>(53)</b>

thisConfig.Authenticator =
  new ListenerPasswordAuthenticator(
    (sender, username, password) =&gt;
      {
      return username.equals("valid.user")  &amp;&amp; (password == validPassword);
      }
  ); <i class="conum" data-value="54"></i><b>(54)</b>

_thisListener = new URLEndpointListener(thisConfig); <i class="conum" data-value="55"></i><b>(55)</b>

_thisListener.Start(); <i class="conum" data-value="56"></i><b>(56)</b>

// end::listener-simple[]



// tag::replicator-simple[]
var theListenerEndpoint = new URLEndpoint("wss://listener.com:4984/otherDB"); <i class="conum" data-value="57"></i><b>(57)</b>

var thisConfig = new ReplicatorConfiguration(thisDB, theListenerEndpoint); <i class="conum" data-value="58"></i><b>(58)</b>

thisConfig.AcceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="59"></i><b>(59)</b>

thisConfig.Authenticator =
  new BasicAuthenticator("valid.user", "valid.password.string"); <i class="conum" data-value="60"></i><b>(60)</b>

var thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="61"></i><b>(61)</b>

thisReplicator.Start(); <i class="conum" data-value="62"></i><b>(62)</b>

// end::replicator-simple[]







// PASSIVE PEER STUFF
// Stuff I adapted
//
//
// p2pSync-websockets.cs
//
// Copyright (c) 2017 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;

using Couchbase.Lite;
using Couchbase.Lite.Enterprise.Query;
using Couchbase.Lite.Logging;
using Couchbase.Lite.P2P;
using Couchbase.Lite.Query;
using Couchbase.Lite.Sync;
using Newtonsoft.Json;

using SkiaSharp;
namespace api_walkthrough
{
  class Program
  {
  private static Database _Database;
  private static Replicator _Replicator;
  private static ListenerToken _thisListenerToken;
  private static bool _NeedsExtraDocs;

  #region Private Methods
  private static void GettingStarted()
  {
    // tag::listener-initialize[]

    // tag::listener-config-db[]
    // Initialize the listener config
    var thisConfig = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="63"></i><b>(63)</b>

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.Port = 55990; <i class="conum" data-value="64"></i><b>(64)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    thisConfig.NetworkInterface = "10.1.1.10"; <i class="conum" data-value="65"></i><b>(65)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.EnableDeltaSync = true; <i class="conum" data-value="66"></i><b>(66)</b>

    // end::listener-config-delta-sync[]
    // tag::listener-config-tls-full[]
    // tag::listener-config-tls-enable[]
    thisConfig.DisableTLS = false; <i class="conum" data-value="67"></i><b>(67)</b>

    // end::listener-config-tls-enable[]
    // tag::listener-config-tls-id-anon[]
    // Use an Anonymous Self-Signed Cert
    thisConfig.TlsIdentity = null; <i class="conum" data-value="68"></i><b>(68)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure the client authenticator
    // Here we are using Basic Authentication) <i class="conum" data-value="69"></i><b>(69)</b>
    SecureString validPassword =  new SecureString(); /* example only */
    // Get SecureString input for validPassword
    var validUser = "valid.username";
    thisConfig.Authenticator = new ListenerPasswordAuthenticator(
      (sender, validUser, validPassword) =&gt;
        {
          return username.equals(validUser)  &amp;&amp; password == validPassword);
        }
      );

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // Initialize the listener
    _thisListener = new URLEndpointListener(thisConfig); <i class="conum" data-value="70"></i><b>(70)</b>

    // Start the listener
    thisListener.Start(); <i class="conum" data-value="71"></i><b>(71)</b>

    // end::listener-start[]
    // end::listener-initialize[]
  }

  // tag::old-listener-config-tls-disable[]
  thisConfig.disableTLS = true;
  // end::old-listener-config-tls-disable[]

  // tag::listener-config-tls-id-nil-2[]

  // Use “anonymous” cert. These are self signed certs created by the system
  thisConfig.TlsIdentity = null;
  // end::listener-config-tls-id-nil-2[]


  // tag::old-listener-config-delta-sync[]
  thisConfig.EnableDeltaSync = true;
  // end::old-listener-config-delta-sync[]


  // tag::listener-status-check[]
  int connectionCount = thisListener.Status.ConnectionCount; <i class="conum" data-value="72"></i><b>(72)</b>
  int activeConnectionCount = thisListener.Status.ActiveConnectionCount;  <i class="conum" data-value="73"></i><b>(73)</b>

  // end::listener-status-check[]


  // tag::listener-stop[]
  thisListener.Stop();

  // end::listener-stop[]

// Additional snippets


// tag::listener-get-network-interfaces[]
foreach(NetworkInterface ni in NetworkInterface.GetAllNetworkInterfaces())
{
  if(ni.NetworkInterfaceType == NetworkInterfaceType.Wireless80211 ||
      ni.NetworkInterfaceType == NetworkInterfaceType.Ethernet)
  {
    // do something with the interface(s)
  }
}

// end::listener-get-network-interfaces[]


// tag::listener-get-url-list[]
var thisConfig = new URLEndpointListenerConfiguration(thisDB);
_thisListener = new URLEndpointListener(thisConfig);

_thisListener.Start();

 Console.WriteLine("URLS are {0} ", thisListener.Urls;

// end::listener-get-url-list[]

    // tag::listener-config-tls-disable[]
    thisConfig.DisableTLS = true; <i class="conum" data-value="74"></i><b>(74)</b>

    // end::listener-config-tls-disable[]

    // tag::listener-local-db[]
    // . . . preceding application logic . . .
    // Get the database (and create it if it doesn't exist)
    var thisDB = new Database("mydb");

    // end::listener-local-db[]

    // tag::listener-config-tls-id-full[]
    // tag::listener-config-tls-id-caCert[]
    // Use CA Cert
    // Create a TLSIdentity from an imported key-pair
    // . . . previously declared variables include ...
    TLSIdentity thisIdentity;
    X509Store _store =
      new X509Store(StoreName.My); // create and label x509 store

    // Get keys and certificates from PKCS12 data
    byte[] thisIdData =
      File.ReadAllBytes("c:client.p12"); <i class="conum" data-value="75"></i><b>(75)</b>
    // . . . other user code . . .

    // tag::import-tls-identity[]
    thisIdentity = TLSIdentity.ImportIdentity(
      _store,
      thisIdData, <i class="conum" data-value="76"></i><b>(76)</b>
      "123", // Password to access certificate data
      "couchbase-demo-cert",
      null); // Label to get cert in certificate map
        // NOTE: If a null label is supplied then the same
        // default directory for a Couchbase Lite database
        // is used for map.

    // end::import-tls-identity[]
    // end::listener-config-tls-id-caCert[]

    // tag::listener-config-tls-id-anon[]
    // Use an Anonymous Self-Signed Cert
    thisConfig.TlsIdentity = null; <i class="conum" data-value="77"></i><b>(77)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-tls-id-set[]
    // Set the TLS Identity
    thisConfig.TlsIdentity = thisIdentity; <i class="conum" data-value="78"></i><b>(78)</b>

    // end::listener-config-tls-id-set[]
    // end::listener-config-tls-id-full[]

    // tag::listener-config-client-auth-root[]
    // Configure the client authenticator
    // to validate using ROOT CA

    // Get the valid cert chain, in this instance from
    // PKCS12 data containing private key, public key
    // and certificates <i class="conum" data-value="79"></i><b>(79)</b>
    var clientData = File.ReadAllBytes("c:client.p12");
    var ourCaData = File.ReadAllBytes("c:client-ca.der");

    // Get the root certs from the data
    var thisRootCert = new X509Certificate2(ourCaData); <i class="conum" data-value="80"></i><b>(80)</b>

    // Configure the authenticator to use the root certs
    var thisAuth = new ListenerCertificateAuthenticator(new X509Certificate2Collection(thisRootCert));

    thisConfig.Authenticator = thisAuth; <i class="conum" data-value="81"></i><b>(81)</b>

    // Initialize the listener using the config
    _listener = new URLEndpointListener(thisConfig);

    // end::listener-config-client-auth-root[]
    // tag::listener-config-client-auth-lambda[]
    // Configure the client authenticator
    // to validate using application logic

    // Get the valid cert chain, in this instance from
    // PKCS12 data containing private key, public key
    // and certificates <i class="conum" data-value="82"></i><b>(82)</b>
    clientData = File.ReadAllBytes("c:client.p12");
    ourCaData = File.ReadAllBytes("c:client-ca.der");

    // Get the root certs from the data
    var thisRootCert = new X509Certificate2(ourCaData);

    // Configure the authenticator to pass the root certs
    // To a user supplied code block for authentication
    var thisAuth =
      new ListenerCertificateAuthenticator(
        new X509Certificate2Collection(thisRootCert) =&gt; {
          // . . . user supplied code block
          // . . . returns boolean value (true=authenticated)
        }); <i class="conum" data-value="83"></i><b>(83)</b>

    thisConfig.Authenticator = thisAuth; <i class="conum" data-value="84"></i><b>(84)</b>

    // end::listener-config-client-auth-lambda[]



// END Additional






// Listener Callouts

// tag::listener-callouts-full[]

  // tag::listener-start-callouts[]
  &lt;.&gt; Initialize the listener instance using the configuration settings.
  &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.
  // end::listener-start-callouts[]


  // tag::listener-status-check-callouts[]

  &lt;.&gt; `connectionCount` -- the total number of connections served by the listener
  &lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
  //
  // end::listener-status-check-callouts[]

// tag::listener-config-tls-id-caCert-callouts[]
  &lt;.&gt; Ensure TLS is enabled.
  &lt;.&gt; The identity will be stored in the secure storage using the given label
  &lt;.&gt; PKCS12 data containing private key, public key, and certificates
  &lt;.&gt; The key pair as stored in the byte array
  &lt;.&gt; The password required to access the certificate data
  &lt;.&gt; The key label assigned to the cert in certificate map and used for retrieval
  &lt;.&gt; If null, the same default directory for a Couchbase Lite database is used for map
  &lt;.&gt; Use the TLSIdentity `thisIdentity.`

// end::listener-config-tls-id-caCert-callouts[]

  // tag::listener-config-tls-id-SelfSigned-callouts[]
  &lt;.&gt; Ensure TLS is enabled.
  &lt;.&gt; The identity will be stored in the secure storage using the given label
  &lt;.&gt; When creating a certificate, the common name attribute is required to create a CSR. If the common name is not present in the certificate an exception is thrown.
  &lt;.&gt; If the expiration date is not specified, the expiration date of the certificate is 365 days after creation
  &lt;.&gt; The key label to get cert in certificate map
  &lt;.&gt; If null, the same default directory for a Couchbase Lite database is used for map
  &lt;.&gt; Use the TLSIdentity `thisIdentity.`

  // end::listener-config-tls-id-SelfSigned-callouts[]

// end::listener-callouts-full[]








// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  // Work in progress. Code snippet to be provided.

  // end::old-listener-config-client-auth-root[]


  // prev content of listener-config-client-auth-self-signed (for ios)
  thisConfig.authenticator = ListenerCertificateAuthenticator.init {
    (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedUsers.contains(["name": certCommonName! as String])) {
      return true
    }
    return false
  }
  // tag::spare-listener-config-client-auth-self-signed[]
  // Work in progress. Code snippet to be provided.

  // end::spare-listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}
// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
thisConfig.port = tls ? wssPort : wsPort
thisConfig.disableTLS = !tls
thisConfig.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
// end::p2p-ws-api-urlendpointlistener-constructor[]


// ACTIVE PEER STUFF
// Replication code
//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

public class Examples {
  private static final String TAG = "EXAMPLE ACTIVE PEER";
  private static final String thisDBNAME = "local-database";
  private final Context context;
  // private Database database;
  // private Replicator replicator;

  public Examples(Context context) { this.context = context; }

  String user = "syncuser";
  String password = "sync9455";
  SecCertificate cert=null;
  String passivePeerEndpoint = "10.1.1.12:8920";
  String passivePeerPort = "8920";
  String passiveDbName = "userdb";
  Database thisDB;
  Replicator thisReplicator;
  ListenerToken replicatorListener;

  //@Test
  public void testActPeerSync() throws CouchbaseLiteException, URISyntaxException {
// tag::p2p-act-rep-func[]
    // . . . preceding code. for example . . .
    private static ListenerToken _thisListenerToken;
    var Database thisDB;
    // . . . other code . . .
    // tag::p2p-act-rep-initialize[]
    // initialize the replicator configuration

    var thisUrl = new URLEndpoint("wss://listener.com:4984/otherDB"); <i class="conum" data-value="85"></i><b>(85)</b>
    var config = new ReplicatorConfiguration(thisDB, thisUrl);

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config-type[]

    // Set replicator type
    thisConfig.ReplicatorType = ReplicatorType.PushAndPull;

    // end::p2p-act-rep-config-type[]
    // tag::autopurge-override[]
    // Set autopurge option
    // here we override its default
    thisConfig.EnableAutoPurge = false; <i class="conum" data-value="86"></i><b>(86)</b>

    // end::autopurge-override[]
    // tag::p2p-act-rep-config-cont[]
    // Configure Sync Mode
    thisConfig.Continuous = true; // default value

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Security -- only accept self-signed certs
    thisConfig.AcceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="87"></i><b>(87)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Security <i class="conum" data-value="88"></i><b>(88)</b>
    // tag::p2p-act-rep-auth[]
    // Configure basic auth using user credentials
    thisConfig.Authenticator = new BasicAuthenticator("Our Username", "Our Password");

    // end::p2p-act-rep-auth[]
    // tag::p2p-act-rep-config-conflict-full[]
    // tag::p2p-act-rep-config-conflict-builtin[]
    /* Optionally set a conflict resolver call back */ <i class="conum" data-value="89"></i><b>(89)</b>
    // Use built-in resolver
    thisConfig.ConflictResolver = new LocalWinConflictResolver();  //

    // end::p2p-act-rep-config-conflict-builtin[]
    // tag::p2p-act-rep-config-conflict-custom[]
    // optionally use custom resolver
    thisConfig.ConflictResolver = new ConflictResolver(
      (conflict) =&gt; {
        /* define resolver function */
      }
    ); //

    // end::p2p-act-rep-config-conflict-custom[]
    // end::p2p-act-rep-config-conflict-full[]
    // tag::p2p-act-rep-start-full[]
    // Initialize and start a replicator
    // Initialize replicator with configuration data
    var thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="90"></i><b>(90)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    //Optionally add a change listener <i class="conum" data-value="91"></i><b>(91)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    _thisListenerToken =
      thisReplicator.AddChangeListener((sender, args) =&gt;
        {
          if (args.Status.Activity == ReplicatorActivityLevel.Stopped) {
              Console.WriteLine("Replication stopped");
          }
        });

    // end::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-start[]
    // Start replicator
    thisReplicator.Start(); <i class="conum" data-value="92"></i><b>(92)</b>

    // end::p2p-act-rep-start[]
// end::p2p-act-rep-start-full[]
// end::p2p-act-rep-func[]         ***** End p2p-act-rep-func
}

// Additional snippets

    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA certs
    thisConfig.AcceptOnlySelfSignedServerCertificate = false; <i class="conum" data-value="93"></i><b>(93)</b>

    // end::p2p-act-rep-config-cacert[]
    // tag::p2p-act-rep-config-pinnedcert[]

    // Return the remote pinned cert (the listener's cert)
    byte returnedCert = new byte(thisConfig.getPinnedCertificate()); // Get listener cert if pinned
    // end::p2p-act-rep-config-pinnedcert[]
    // Configure Client Security <i class="conum" data-value="94"></i><b>(94)</b>
    // tag::p2p-act-rep-auth[]
    // Configure basic auth using user credentials
    thisConfig.Authenticator = new BasicAuthenticator("Our Username", "Our Password");

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]

    // tag::p2p-act-rep-config-cacert-pinned[]
    // Only CA Certs accepted
    thisConfig.AcceptOnlySelfSignedServerCertificate =
      false; <i class="conum" data-value="95"></i><b>(95)</b>

    var thisCert =
      new X509Certificate2(caData); <i class="conum" data-value="96"></i><b>(96)</b>

    thisConfig.PinnedServerCertificate =
      thisCert; <i class="conum" data-value="97"></i><b>(97)</b>

    // end::p2p-act-rep-config-cacert-pinned[]












    // Code to refactor
    Log.i(TAG, "The Replicator is currently " + thisReplicator.Status().getActivityLevel());

    Log.i(TAG, "The Replicator has processed " + t);

    if (thisReplicator.Status().getActivityLevel() == Replicator.ActivityLevel.BUSY) {
          Log.i(TAG, "Replication Processing");
          Log.i(TAG, "It has completed " + thisReplicator.Status().getProgess().getTotal() + " changes");
      }
    // tag::p2p-act-rep-status[]
    _thisReplicator.Stop();
    while (_thisReplicator.Status.Activity != ReplicatorActivityLevel.Stopped) {
        // Database cannot close until replicators are stopped
        Console.WriteLine($"Waiting for replicator to stop (currently {_thisReplicator.Status.Activity})...");
        Thread.Sleep(200);
    }
    _thisDatabase.Close();
    // end::p2p-act-rep-status[]

      // tag::p2p-act-rep-stop[]
      // Stop replication.
      thisReplicator.Stop(); <i class="conum" data-value="98"></i><b>(98)</b>
      // end::p2p-act-rep-stop[]


  }

{
  CouchbaseLite.init(context);
  Database thisDB = new Database("passivepeerdb");  <i class="conum" data-value="99"></i><b>(99)</b>
  // Initialize the listener config
  final URLEndpointListenerConfiguration thisConfig = new URLEndpointListenerConfiguration(database);
  thisConfig.Port(55990)             // &lt;.&gt; Default- port is selected
  thisConfig.DisableTls(false)       // &lt;.&gt; Optional. Defaults to false. You get TLS encryption out-of-box
  thisConfig.EnableDeltaSync(true)   // &lt;.&gt; Optional. Defaults to false.

  // Configure the client authenticator (if using basic auth)
  ListenerPasswordAuthenticator auth = new ListenerPasswordAuthenticator { "Our Username", "Our Password"}; <i class="conum" data-value="100"></i><b>(100)</b>
  thisConfig.Authenticator(auth); <i class="conum" data-value="101"></i><b>(101)</b>

  // Initialize the listener
  final URLEndpointListener listener = new URLEndpointListener( thisConfig ); <i class="conum" data-value="102"></i><b>(102)</b>

  // Start the listener
  listener.Start(); <i class="conum" data-value="103"></i><b>(103)</b>
    }


// tag::createTlsIdentity[]

Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
           TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
           TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
           TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
           TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
       )

TLSIdentity thisIdentity = new TLSIdentity.createIdentity(true, X509_ATTRIBUTES, null, "test-alias");

// end::createTlsIdentity[]


// tag::p2p-tlsid-store-in-keychain[]
. . . work in progress - GetHashCode snippet to be provided
// end::p2p-tlsid-store-in-keychain[]

// tag::deleteTlsIdentity[]
// tag::p2p-tlsid-delete-id-from-keychain[]
TLSIdentity.DeleteIdentity(_store, "alias-to-delete", null);

// end::p2p-tlsid-delete-id-from-keychain[]
// end::deleteTlsIdentity[]

// tag::retrieveTlsIdentity[]
// OPTIONALLY:: Retrieve a stored TLS identity using its alias/label

TLSIdentity thisIdentity = new TLSIdentity.getIdentity("CBL-Demo-Server-Cert")
// end::retrieveTlsIdentity[]


    // Configure the client authenticator (if using Basic Authentication)
    // String validUser = new String("validUsername"); // an example username
    // String validPassword = new String("validPasswordValue"); // an example password

    // ListenerPasswordAuthenticator thisAuth = new ListenerPasswordAuthenticator( <i class="conum" data-value="104"></i><b>(104)</b>
    //   validUser, validPassword -&gt; validUser == "validUsername" &amp;&amp; validPassword == "validPasswordValue" );

    // if (thisAuth) {
    //   thisConfig.Authenticator(auth);
    // }
    // else {
    //   // . . . authentication failed take appropriate exception action
    //   return
    // };




    // tag::old-p2p-act-rep-add-change-listener[]
    ListenerToken thisListener = new thisReplicator.addChangeListener(change -&gt; { <i class="conum" data-value="105"></i><b>(105)</b>
      if (change.Status().getError() != null) {
        Log.i(TAG, "Error code ::  " + change.Status().getError().getCode());
      }
    });

    // end::old-p2p-act-rep-add-change-listener[]



// g u b b i n s
// tag::duff-p2p-tlsid-tlsidentity-with-label[]


    // Configure TLS Cert CA auth using key-stored cert id alias 'doc-sync-server'

    // TLSIdentity thisIdentity = new TLSIdentity.getIdentity("doc-sync-server"); // Get existing TLS ID from sec storage

    // ClientCertificateAuthenticator thisAuth = new ClientCertificateAuthenticator(thisIdentity);

    // thisConfig.Authenticator(thisAuth);



    // USE KEYCHAIN IDENTITY IF EXISTS
    // Check if Id exists in keychain. If so use that Id

    // STILL NEED TO REFACTOR

    do {
      if let thisIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
          print("An identity with label : doco-sync-server already exists in keychain")
          return thisIdentity
          }
    } catch
    {return nil}
    thisAuthenticator.ClientCertificateAuthenticator(identity: thisIdentity )
    thisConfig.thisAuthenticator

    // end::duff-p2p-tlsid-tlsidentity-with-label[]


// tag::old-deleteTlsIdentity[]

String thisAlias = "alias-to-delete";
KeyStore thisKeystore = KeyStore.getInstance("PKCS12"); <i class="conum" data-value="106"></i><b>(106)</b>
thisKeyStore.load= null;
if (thisAlias != null) {
   thisKeystore.deleteEntry(thisAlias);  <i class="conum" data-value="107"></i><b>(107)</b>
}

// end::old-deleteTlsIdentity[]


// cert auth
let rootCertData = SecCertificateCopyData(cert) as Data
let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
// Listener:
thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

SecCertificate thisCert = new SecCertificate(); // populated as nec.

Data rootCertData = new Data(SecCertificateCopyData(thisCert));

let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
// Listener:
thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])
// cert auth


// C A L L O U T S

// tag::p2p-act-rep-config-cacert-pinned-callouts[]
&lt;.&gt; Configure to accept only CA certs
&lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
&lt;.&gt; Set the certificate to be compared with that provided by the server
// end::p2p-act-rep-config-cacert-pinned-callouts[]

// tag::??p2p-tlsid-tlsidentity-with-label-callouts[]
&lt;.&gt; PKCS12 data containing private key, public key, and certificates
&lt;.&gt; This is the default value and means that TLS is enabled
// end::??p2p-tlsid-tlsidentity-with-label-callouts[]

// tag::p2p-tlsid-tlsidentity-with-label-callouts[]
&lt;.&gt; Refuse self-signed certificates
&lt;.&gt; Get the identity
&lt;.&gt; Set the Client Certificate Authenticator to require signed certificates with this identity

// end::p2p-tlsid-tlsidentity-with-label-callouts[]


    // tag::old-listener-config-client-root-ca[]
    // Configure the client authenticator
    // to validate using ROOT CA <i class="conum" data-value="108"></i><b>(108)</b>
    byte[] thisCaData; // byte array for CA data
    using (var thisReader = new BinaryReader(stream)) {
      thisCaData = thisReader.ReadBytes(int stream.Length);
    }; // Get cert data

    var thisRootCert = new X509Certificate(thisCaData); //

    thisConfig.Authenticator = new  ListenerCertificateAuthenticator(
      new X509Certificate2Collection(thisRootCert)
    );

    // end::old-listener-config-client-root-ca[]



        // tag::p2p-tlsid-tlsidentity-with-label-per-sam[]
    var db = new Database("other-database");
    _Database = db;
    X509Store _store = new X509Store(StoreName.My);
    TLSIdentity thisIdentity;

    // tag::client-cert-authenticator-root-certs[]

    // Configure the expected server-supplied
    // credentials -- only accept CA Certs
    thisConfig.AcceptOnlySelfSignedServerCertificate = false; <i class="conum" data-value="109"></i><b>(109)</b>

    // Client identity
    thisIdentity =
      TLSIdentity.ImportIdentity(_store,
        clientData,
        "123",
        "CBL-Client-Cert",
        null); <i class="conum" data-value="110"></i><b>(110)</b>

    thisConfig.Authenticator =
      new ClientCertificateAuthenticator(thisIdentity); <i class="conum" data-value="111"></i><b>(111)</b>

    // end::client-cert-authenticator-root-certs[]





    byte[] thisCaData, thisClientData;
    thisClientData = File.ReadAllBytes("C:\\client.p12"); <i class="conum" data-value="112"></i><b>(112)</b>
    thisCaData = File.ReadAllBytes("C:\\client-ca.der");

    // Root certs
    var thisRootCert = new X509Certificate2(thisCaData);
    var thisAuth =
      new ListenerCertificateAuthenticator(
        new X509Certificate2Collection(thisRootCert));

    // Create URL Endpoint Listener
    var thisConfig = new URLEndpointListenerConfiguration(_Database);
    thisConfig.DisableTLS = false; <i class="conum" data-value="113"></i><b>(113)</b>
    thisConfig.Authenticator = thisAuth;
    _listener = new URLEndpointListener(thisConfig);
    _listener.Start();

    // Client identity
    thisIdentity = TLSIdentity.ImportIdentity(_store,
        thisClientData,
        "123",
        "CBL-Client-Cert",
        null);

    // Replicator -- Client
    var database = new Database("client-database");
    var builder = new UriBuilder(
        "wss",
        "localhost",
        _listener.Port,
        $"/{_listener.thisConfig.Database.Name}"
    );

    var url = builder.Uri;
    var target = new URLEndpoint(url);
    var thisConfig = new ReplicatorConfiguration(database, target);
    thisConfig.ReplicatorType = ReplicatorType.PushAndPull;
    thisConfig.Continuous = false;
    thisConfig.Authenticator = new ClientCertificateAuthenticator(thisIdentity);
    thisConfig.AcceptOnlySelfSignedServerCertificate = true;
    thisConfig.PinnedServerCertificate = _listener.TlsIdentity.Certs[0];
    using (var replicator = new Replicator(thisConfig)) {
        replicator.Start();
    }





    // Stop listener after replicator is stopped
    _listener.Stop();

    // end::p2p-tlsid-tlsidentity-with-label-per-sam[]


        // tag::p2p-tlsid-tlsidentity-with-label[]
    // Client identity
    thisIdentity =
      TLSIdentity.ImportIdentity(_store,
        clientData,
        "123",
        "CBL-Client-Cert",
        null); <i class="conum" data-value="114"></i><b>(114)</b>

    thisConfig.Authenticator =
      new ClientCertificateAuthenticator(thisIdentity); <i class="conum" data-value="115"></i><b>(115)</b>

    // end::p2p-tlsid-tlsidentity-with-label[]


  // For replications

  // BEGIN -- snippets --
  //    Purpose -- code samples for use in replication topic

  // tag::sgw-repl-pull[]
  public class MyClass
  {
      public Database Database { get; set; }
      public Replicator Replicator { get; set; } <i class="conum" data-value="116"></i><b>(116)</b>

      public void StartReplication()
      {
  }

          var url = new Uri("wss://localhost:4984/db"); <i class="conum" data-value="117"></i><b>(117)</b>
          var target = new URLEndpoint(url);
          var config = new ReplicatorConfiguration(Database, target)
          {
              ReplicatorType = ReplicatorType.Pull
          };

          Replicator = new Replicator(config);
          Replicator.Start();
      }
      // end::sgw-repl-pull[]

      // tag::sgw-repl-pull-callouts[]
      // &lt;.&gt; A replication is an asynchronous operation.
      // To keep a reference to the `replicator` object, you can set it as an instance property.
      // &lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
      // You should now use `ws:`, or `wss:` for SSL/TLS connections.
      // end::sgw-repl-pull-callouts[]

      public void InitReplication()
      {
        // tag::sgw-act-rep-initialize[]
        // initialize the replicator configuration

        var thisUrl = new URLEndpoint("wss://l10.0.2.2:4984/anotherDB"); <i class="conum" data-value="118"></i><b>(118)</b>
        var config = new ReplicatorConfiguration(thisDB, thisUrl);

        // end::sgw-act-rep-initialize[]
      }
  }
 }



  public class supporting_datatypes
  {
    public void datatype_usage()
    {

        // tag::datatype_usage[]
        // tag::datatype_usage_createdb[]
        // Get the database (and create it if it doesn’t exist).
        var database = new Database("hoteldb");

        // end::datatype_usage_createdb[]
        // tag::datatype_usage_createdoc[]
        // Create your new document

        // Add the dictionary to a document's properties and save the document
        var doc = new MutableDocument("hoteldoc");

        // end::datatype_usage_createdoc[]
        // tag::datatype_usage_mutdict[]
        // Create and populate mutable dictionary
        var address = new MutableDictionaryObject();
        address.SetString("street", "1 Main st.");
        address.SetString("city", "San Francisco");
        address.SetString("state", "CA");
        address.SetString("country", "USA");
        address.SetString("code", "90210");

        // end::datatype_usage_mutdict[]
        // tag::datatype_usage_mutarray[]
        // Create and populate mutable array
        var phones = MutableArrayObject();
        phones.AddString("650-000-0000");
        phones.AddString("650-000-0001");

        // end::datatype_usage_mutarray[]
        // tag::datatype_usage_populate[]
        // Initialize and populate the document

        // Add document type to document properties <i class="conum" data-value="119"></i><b>(119)</b>
        doc.SetString("type", "hotel");

        // Add hotel name string to document properties <i class="conum" data-value="120"></i><b>(120)</b>
        doc.SetString("name", "Hotel Java Mo");

        // Add float to document properties <i class="conum" data-value="121"></i><b>(121)</b>
        doc.SetFloat("room_rate", 121.75);

        // Add dictionary to document's properties <i class="conum" data-value="122"></i><b>(122)</b>
        doc.SetDictionary("address", address);

        // Add array to document's properties <i class="conum" data-value="123"></i><b>(123)</b>
        doc.SetArray("phones", phones);

        // end::datatype_usage_populate[]
        // tag::datatype_usage_persist[]
        // Save the document changes <i class="conum" data-value="124"></i><b>(124)</b>
        database.Save(doc);

        // end::datatype_usage_persist[]
        // tag::datatype_usage_closedb[]
        // Close the database <i class="conum" data-value="125"></i><b>(125)</b>
        database.Close();

        // end::datatype_usage_closedb[]

        // end::datatype_usage[]

     }



      public void datatype_dictionary()
      {
          var database = new Database(name: "mydb");

          // tag::datatype_dictionary[]
          // NOTE: No error handling, for brevity (see getting started)
          var document = database.GetDocument("doc1");

          // Getting a dictionary from the document's properties
          var dict = document.GetDictionary("address");

          // Access a value with a key from the dictionary
          var street = dict.GetString("street");

          // Iterate dictionary
          foreach (var key in dict.Keys)
          {
              Console.WriteLine($"Key {key} = {dict.GetValue(key)}");
          }

          // Create a mutable copy
          var mutDict = dict.ToMutable();
          // end::datatype_dictionary[]
      }

      public void datatype_mutable_dictionary()
      {

          var database = new Database("mydb");

          // tag::datatype_mutable_dictionary[]
          // NOTE: No error handling, for brevity (see getting started)

          // Create a new mutable dictionary and populate some keys/values
          var mutable_dict = new MutableDictionaryObject();
          mutable_dict.SetString("street", "1 Main st.");
          mutable_dict.SetString("city", "San Francisco");

          // Add the dictionary to a document's properties and save the document
          var doc = new MutableDocument("doc1");
          doc.SetDictionary("address", mutable_dict);
          database.Save(doc);

          // end::datatype_mutable_dictionary[]
      }


      public void datatype_array()
      {
          var database = new Database("mydb");

          // tag::datatype_array[]
          // NOTE: No error handling, for brevity (see getting started)

          var document = database.GetDocument("doc1");

          // Getting a phones array from the document's properties
          var array = document.GetArray("phones");

          // Get element count
          var count = array.Count();

          // Access an array element by index
          if (count &gt;= 0) { var phone = array[1]; }

          // Iterate dictionary
          for (int i = 0; i &lt; count; i++)
          {
              Console.WriteLine($"Item {i.ToString()} = {array[i]}");
          }

          // Create a mutable copy
          var mutable_array = array.ToMutable();
          // end::datatype_array[]


      }

        public void datatype_mutable_array()
      {
          var database = new Database("mydb");

          // tag::datatype_mutable_array[]
          // NOTE: No error handling, for brevity (see getting started)

          // Create a new mutable array and populate data into the array
          var mutable_array = new MutableArrayObject();
          mutable_array.AddString("650-000-0000");
          mutable_array.AddString("650-000-0001");

          // Set the array to document's properties and save the document
          var doc = new MutableDocument("doc1");
          doc.SetArray("phones", mutable_array);
          database.Save(doc);
          // end::datatype_mutable_array[]
      }

  } // end  class supporting_datatypes</code></pre>
</div>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use keychain identity in config</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#" data-source-url="https://github.com/couchbase/docs-couchbase-lite/blob/undefined/modules/csharp/examples/code_snippets/Program.cs">//
// Program.cs
//
// Copyright (c) 2017 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;

using Couchbase.Lite;
using Couchbase.Lite.Enterprise.Query;
using Couchbase.Lite.Logging;
using Couchbase.Lite.P2P;
using Couchbase.Lite.Query;
using Couchbase.Lite.Sync;
using Newtonsoft.Json;

using SkiaSharp;

namespace api_walkthrough
{
    class Program
    {
        private static Database _Database;
        private static Replicator _Replicator;
        private static URLEndpointListener _listener;
        private static ListenerToken _ListenerToken;
        private static bool _NeedsExtraDocs;

        #region Private Methods

        private static void GettingStarted()
        {
            // tag::getting-started[]

            // using System;
            // using Couchbase.Lite;
            // using Couchbase.Lite.Query;
            // using Couchbase.Lite.Sync;

            // Get the database (and create it if it doesn't exist)
            var database = new Database("mydb");
            // Create a new document (i.e. a record) in the database
            string id = null;
            using (var mutableDoc = new MutableDocument())
            {
                mutableDoc.SetFloat("version", 2.0f)
                    .SetString("type", "SDK");

                // Save it to the database
                database.Save(mutableDoc);
                id = mutableDoc.Id;
            }

            // Update a document
            using (var doc = database.GetDocument(id))
            using (var mutableDoc = doc.ToMutable())
            {
                mutableDoc.SetString("language", "C#");
                database.Save(mutableDoc);

                using (var docAgain = database.GetDocument(id))
                {
                    Console.WriteLine($"Document ID :: {docAgain.Id}");
                    Console.WriteLine($"Learning {docAgain.GetString("language")}");
                }
            }

            // Create a query to fetch documents of type SDK
            // i.e. SELECT * FROM database WHERE type = "SDK"
            using (var query = QueryBuilder.Select(SelectResult.All())
                .From(DataSource.Database(database))
                .Where(Expression.Property("type").EqualTo(Expression.String("SDK"))))
            {
                // Run the query
                var result = query.Execute();
                Console.WriteLine($"Number of rows :: {result.AllResults().Count}");
            }

            // Create replicator to push and pull changes to and from the cloud
            var targetEndpoint = new URLEndpoint(new Uri("ws://localhost:4984/getting-started-db"));
            var replConfig = new ReplicatorConfiguration(database, targetEndpoint);

            // Add authentication
            replConfig.Authenticator = new BasicAuthenticator("john", "pass");

            // Create replicator (make sure to add an instance or static variable
            // named _Replicator)
            var _Replicator = new Replicator(replConfig);
            _Replicator.AddChangeListener((sender, args) =&gt;
            {
                if (args.Status.Error != null)
                {
                    Console.WriteLine($"Error :: {args.Status.Error}");
                }
            });

            _Replicator.Start();

            // Later, stop and dispose the replicator *before* closing/disposing the
        }


// end::getting-started[]

        private static void TestReplicatorConflictResolver()
        {
            // tag::replication-conflict-resolver[]
            var target = new URLEndpoint(new Uri("ws://localhost:4984/mydatabase"));
            var replConfig = new ReplicatorConfiguration(database, target);
            replConfig.ConflictResolver = new LocalWinConflictResolver();

            var replicator = new Replicator(replConfig);
            replicator.Start();
            // end::replication-conflict-resolver[]
        }

        private static void TestSaveWithConflictHandler()
        {
            // tag::update-document-with-conflict-handler[]
            using (var document = database.GetDocument("xyz"))
            using (var mutableDocument = document.ToMutable()) {
                mutableDocument.SetString("name", "apples");
                database.Save(mutableDocument, (updated, current) =&gt;
                {
                    var currentDict = current.ToDictionary();
                    var newDict = updated.ToDictionary();
                    var result = newDict.Concat(currentDict)
                        .GroupBy(kv =&gt; kv.Key)
                        .ToDictionary(g =&gt; g.Key, g =&gt; g.First().Value);
                    updated.SetData(result);
                    return true;
                });
            }
            // end::update-document-with-conflict-handler[]
        }

        private static bool IsValidCredential(string name, SecureString password) { return true;  } // helper
        private static void TestInitListener()
        {
            var db = new Database("other-database");
            _Database = db;

            // tag::init-urllistener[]
            var config = new URLEndpointListenerConfiguration(_Database);
            config.TlsIdentity = null; // Use with anonymous self-signed cert
            config.Authenticator = new ListenerPasswordAuthenticator((sender, username, password) =&gt;
            {
                if(IsValidCredential(username, password)) {
                    return true;
                }

                return false;
            });

            _listener = new URLEndpointListener(config);
            // end::init-urllistener[]
        }

        private static void TestListenerStart()
        {
            // tag::start-urllistener[]
            // CouchbaseLiteException will be thrown when the listener cannot be started. The most common error
            // would be that the configured port has already been used.
            _listener.Start();
            // end::start-urllistener[]
        }

        private static void TestListenerStop()
        {
            // tag::stop-urllistener[]
            _listener.Stop();
            // end::stop-urllistener[]
        }

        private static void TestCreateSelfSignedCert()
        {
            TLSIdentity identity;
            X509Store _store =
             new X509Store(StoreName.My);
              // The identity will be stored in the secure
              // storage using the given label.
            DateTimeOffset fiveMinToExpireCert = DateTimeOffset.UtcNow.AddMinutes(5);

            // tag::create-self-signed-cert[]
            // tag::listener-config-tls-id-SelfSigned[]
            identity = TLSIdentity.CreateIdentity(true, /* isServer */
                new Dictionary&lt;string, string&gt;() { { Certificate.CommonNameAttribute, "Couchbase Inc" } },
                    // The common name attribute is required
                    // when creating a CSR. If it is not presented
                    // in the cert, an exception is thrown.
                fiveMinToExpireCert,
                    // If the expiration date is not specified,
                    // the certs expiration will be 365 days
                _store,
                "CBL-Server-Cert",
                null);  // The key label to get cert in certificate map.
                        // If null, the same default directory
                        // for a Couchbase Lite db is used for map.

            // end::listener-config-tls-id-SelfSigned[]
            // end::create-self-signed-cert[]
        }

        private static void TestImportTLSIdentity()
        {
            TLSIdentity identity;
            X509Store _store = new X509Store(StoreName.My); // The identity will be stored in the secure storage using the given label
            byte[] data = File.ReadAllBytes("C:\\client.p12"); // PKCS12 data containing private key, public key, and certificates

            // tag::import-tls-identity[]
            // tag::listener-config-tls-id-caCert[]
            identity = TLSIdentity.ImportIdentity(_store,
                data,
                "123", // The password that is needed to access the certificate data
                "CBL-Client-Cert",
                null);  // The key label to get cert in certificate map.
                        // If null, the same default directory
                        // for a Couchbase Lite db is used for map.
            // end::listener-config-tls-id-caCert[]
            // end::import-tls-identity[]
        }

          private static void TestClientCertAuthenticatorRootCerts()
        {
            var db = new Database("other-database");
            _Database = db;

            X509Store _store = new X509Store(StoreName.My);
            TLSIdentity identity;

            // tag::client-cert-authenticator-root-certs[]
            byte[] caData, clientData;
            clientData = File.ReadAllBytes("C:\\client.p12"); // PKCS12 data containing private key, public key, and certificates
            caData = File.ReadAllBytes("C:\\client-ca.der");

            // Root certs
            var rootCert = new X509Certificate2(caData);
            var auth = new ListenerCertificateAuthenticator(new X509Certificate2Collection(rootCert));

            // Create URL Endpoint Listener
            var listenerConfig = new URLEndpointListenerConfiguration(_Database);
            listenerConfig.DisableTLS = false; //The default value is false which means that the TLS will be enabled by default.
            listenerConfig.Authenticator = auth;
            _listener = new URLEndpointListener(listenerConfig);
            _listener.Start();

            // Client identity
            identity = TLSIdentity.ImportIdentity(_store,
                clientData,
                "123",
                "CBL-Client-Cert",
                null);

            // Replicator -- Client
            var database = new Database("client-database");
            var builder = new UriBuilder(
                "wss",
                "localhost",
                _listener.Port,
                $"/{_listener.Config.Database.Name}"
            );

            var url = builder.Uri;
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.ReplicatorType = ReplicatorType.PushAndPull;
            config.Continuous = false;
            config.Authenticator = new ClientCertificateAuthenticator(identity);
            config.AcceptOnlySelfSignedServerCertificate = true;
            config.PinnedServerCertificate = _listener.TlsIdentity.Certs[0];
            using (var replicator = new Replicator(config)) {
                replicator.Start();
            }

            // Stop listener after replicator is stopped
            _listener.Stop();
            // end::client-cert-authenticator-root-cert
        }

        private static void TestClientCertAuthenticator()
        {
            var db = new Database("other-database");
            _Database = db;

            X509Store _store = new X509Store(StoreName.My);
            TLSIdentity identity;

            // tag::client-cert-authenticator[]

            // Create Listener Certificate Authenticator
            var auth = new ListenerCertificateAuthenticator((sender, cert) =&gt;
            {
                if (cert.Count != 1) {
                    return false;
                }

                return cert[0].SubjectName.Name?.Replace("CN=", "") == "couchbase";
            });

            // Create URL Endpoint Listener
            var listenerConfig = new URLEndpointListenerConfiguration(_Database);
            listenerConfig.DisableTLS = false; //The default value is false which means that the TLS will be enabled by default.
            listenerConfig.Authenticator = auth;
            _listener = new URLEndpointListener(listenerConfig);
            _listener.Start();

            // User Identity
            identity = TLSIdentity.CreateIdentity(false,
                new Dictionary&lt;string, string&gt;() { { Certificate.CommonNameAttribute, "couchbase" } },
                null,
                _store,
                ClientCertLabel,
                null);

            // Replicator -- Client
            var database = new Database("client-database");
            var builder = new UriBuilder(
                "wss",
                "localhost",
                _listener.Port,
                $"/{_listener.Config.Database.Name}"
            );

            var url = builder.Uri;
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.ReplicatorType = ReplicatorType.PushAndPull;
            config.Continuous = false;
            config.Authenticator = new ClientCertificateAuthenticator(identity);
            config.AcceptOnlySelfSignedServerCertificate = false;
            config.PinnedServerCertificate = _listener.TlsIdentity.Certs[0];
            using (var replicator = new Replicator(config)) {
                replicator.Start();
            }

            // Stop listener after replicator is stopped
            _listener.Stop();
            // end::client-cert-authenticator[]
        }

        private static void UseEncryption()
        {
            // Enterprise edition only

            // tag::database-encryption[]
            // Create a new, or open an existing database with encryption enabled
            var config = new DatabaseConfiguration
            {
                // Or, derive a key yourself and pass a byte array of the proper size
                EncryptionKey = new EncryptionKey("password")
            };

            using (var db = new Database("seekrit", config)) {
                // Change the encryption key (or add encryption if the DB is unencrypted)
                db.ChangeEncryptionKey(new EncryptionKey("betterpassw0rd"));

                // Remove encryption
                db.ChangeEncryptionKey(null);
            }
            // end::database-encryption[]
        }

        private static void ResetReplicatorCheckpoint()
        {
            var database = _Database;
            var url = new Uri("ws://localhost:4984/db");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            using (var replicator = new Replicator(config)) {
              // tag::replication-reset-checkpoint[]
              // replicator is a Replicator instance
              if (resetCheckpointRequired_Example) {
                  replicator.Start(true); <i class="conum" data-value="1"></i><b>(1)</b>
              else
                replicator.Start(false);
              }
              // end::replication-reset-checkpoint[]




                // end::replication-reset-checkpoint[]
            }
        }

        private static void Read1xAttachment()
        {
            var db = _Database;
            using (var document = new MutableDocument()) {
                // tag::1x-attachment[]
                var attachments = document.GetDictionary("_attachments");
                var avatar = attachments.GetBlob("avatar");
                var content = avatar?.Content;
                // end::1x-attachment[]
            }
        }

        private static void CreateNewDatabase()
        {
            // tag::new-database[]
            var db = new Database("my-database");
            // end::new-database[]

            _Database = db;
        }

        private static void CloseDatabase()
        {
          // tag::close-database[]
          database.Close()

          // end::close-database[]
        }

        private static void ChangeLogging()
        {
            // tag::logging[]
            Database.SetLogLevel(LogDomain.Replicator, LogLevel.Verbose);
            Database.SetLogLevel(LogDomain.Query, LogLevel.Verbose);
            // end::logging[]
        }

        private static void LoadPrebuilt()
        {
            // tag::prebuilt-database[]
            // Note: Getting the path to a database is platform-specific.  For .NET Core / .NET Framework this
            // can be a simple filesystem path.  For UWP, you will need to get the path from your assets.  For
            // iOS you need to get the path from the main bundle.  For Android you need to extract it from your
            // assets to a temporary directory and then pass that path.
            var path = Path.Combine(Environment.CurrentDirectory, "travel-sample.cblite2" + Path.DirectorySeparatorChar);
            if (!Database.Exists("travel-sample", null)) {
                _NeedsExtraDocs = true;
                Database.Copy(path, "travel-sample", null);
            }
            // end::prebuilt-database[]

            _Database.Close();
            _Database = new Database("travel-sample");
        }

        private static void QueryDeletedDocuments()
        {
            // tag::query-deleted-documents[]
            // Query documents that have been deleted
            var query = QueryBuilder
                .Select(SelectResult.Expression(Meta.ID))
                .From(DataSource.Database(db))
                .Where(Meta.IsDeleted);
            // end::query-deleted-documents[]
        }

        private static void CreateDocument()
        {
            var db = _Database;
            // tag::initializer[]
            using (var newTask = new MutableDocument("xyz")) {
                newTask.SetString("type", "task")
                    .SetString("owner", "todo")
                    .SetDate("createdAt", DateTimeOffset.UtcNow);

                db.Save(newTask);
            }
            // end::initializer[]
        }

        private static void UpdateDocument()
        {
            var db = _Database;
            // tag::update-document[]
            using(var document = db.GetDocument("xyz"))
            using (var mutableDocument = document.ToMutable()) {
                mutableDocument.SetString("name", "apples");
                db.Save(mutableDocument);
            }
            // end::update-document[]
        }

        private static void UseTypedAccessors()
        {
            using (var newTask = new MutableDocument()) {
                // tag::date-getter[]
                newTask.SetValue("createdAt", DateTimeOffset.UtcNow);
                var date = newTask.GetDate("createdAt");
                // end::date-getter[]

                Console.WriteLine(date);
            }
        }

        private static void DoBatchOperation()
        {
            var db = _Database;
            // tag::batch[]
            db.InBatch(() =&gt;
            {
                for (var i = 0; i &lt; 10; i++) {
                    using (var doc = new MutableDocument()) {
                        doc.SetString("type", "user");
                        doc.SetString("name", $"user {i}");
                        doc.SetBoolean("admin", false);
                        db.Save(doc);
                        Console.WriteLine($"Saved user document {doc.GetString("name")}");
                    }
                }
            });
            // end::batch[]
        }

        private static void DatabaseChangeListener()
        {
            var db = _Database;

            // tag::document-listener[]
            db.AddDocumentChangeListener("user.john", (sender, args) =&gt;
            {
                using (var doc = Db.GetDocument(args.DocumentID)) {
                    Console.WriteLine($"Status :: {doc.GetString("verified_account")}");
                }
            });
            // end::document-listener[]
        }

        private static void DocumentExpiration()
        {
            var db = _Database;

            // tag::document-expiration[]
            // Purge the document one day from now
            var ttl = DateTimeOffset.UtcNow.AddDays(1);
            db.SetDocumentExpiration("doc123", ttl);

            // Reset expiration
            db.SetDocumentExpiration("doc1", null);

            // Query documents that will be expired in less than five minutes
            var fiveMinutesFromNow = DateTimeOffset.UtcNow.AddMinutes(5).ToUnixTimeMilliseconds();
            var query = QueryBuilder
                .Select(SelectResult.Expression(Meta.ID))
                .From(DataSource.Database(db))
                .Where(Meta.Expiration.LessThan(Expression.Double(fiveMinutesFromNow)));
            // end::document-expiration[]
        }

        private static void UseBlob()
        {
            var db = _Database;
            using (var newTask = new MutableDocument()) {
                // tag::blob[]
                // Note: Reading the data is implementation dependent, as with prebuilt databases
                var image = File.ReadAllBytes("avatar.jpg"); <i class="conum" data-value="2"></i><b>(2)</b>
                var blob = new Blob("image/jpeg", image); <i class="conum" data-value="3"></i><b>(3)</b>
                 newTask.SetBlob("avatar", blob); <i class="conum" data-value="4"></i><b>(4)</b>
                db.Save(newTask);
                // end::blob[]

                var taskBlob = newTask.GetBlob("avatar");
                using (var bitmap = SKBitmap.Decode(taskBlob.ContentStream)) {
                    Console.WriteLine($"Bitmap dimensions: {bitmap.Width} x {bitmap.Height} ({bitmap.BytesPerPixel} bytes per pixel)");
                }
            }
        }

        public void CreateIndex()
        {
            // tag::query-index[]
            var db = _database;
            string[] indexProperties = new string[] {"type", "name" };
            var config = new ValueIndexConfiguration(indexProperties);
            db.CreateIndex("TypeNameIndex", config);
            // end::query-index[]
        }

        public void CreateIndex_Querybuilder()
        {
            // tag::query-index_Querybuilder[]
            // For value types, this is optional but provides performance enhancements
            var db = _database;
            var index = IndexBuilder.ValueIndex(
                ValueIndexItem.Expression(Expression.Property("type")),
                ValueIndexItem.Expression(Expression.Property("name"))); <i class="conum" data-value="5"></i><b>(5)</b>
            db.CreateIndex("TypeNameIndex", index);
            // end::query-index_Querybuilder[]
        }
        private static void SelectMeta()
        {
            Console.WriteLine("Select Meta");
            var db = _Database;

            // tag::query-select-meta[]
            // tag::query-select-props[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("type"),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Document ID :: {result.GetString("id")}");
                    Console.WriteLine($"Document Name :: {result.GetString("name")}");
                }
            }
            // end::query-select-props[]
            // end::query-select-meta[]
        }

        private static void SelectAll()
        {
            var db = _Database;

            // tag::query-select-all[]
            using (var query = QueryBuilder.Select(SelectResult.All())
                .From(DataSource.Database(db))) {
                // All user properties will be available here
            }
            // end::query-select-all[]

            // tag::live-query[]
            var query = QueryBuilder
                .Select(SelectResult.All())
                .From(DataSource.Database(db)); <i class="conum" data-value="6"></i><b>(6)</b>

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            var token = query.AddChangeListener((sender, args) =&gt; <i class="conum" data-value="7"></i><b>(7)</b>
            {
                var allResult = args.Results.AllResults();
                foreach (var result in allResult) {
                    Console.WriteLine(result.Keys);
                    /* Update UI */
                }
            });

            // end::live-query[]

            // tag::stop-live-query[]
            query.RemoveChangeListener(token);
            query.Dispose();
            // end::stop-live-query[]
        }

        private static void SelectWhere()
        {
            Console.WriteLine("Where");
            var db = _Database;

            // tag::query-where[]
            using (var query = QueryBuilder.Select(SelectResult.All())
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("hotel")))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    var dict = result.GetDictionary(db.Name);
                    Console.WriteLine($"Document Name :: {dict?.GetString("name")}");
                }
            }
            // end::query-where[]
        }

        private static void UseCollectionContains()
        {
            Console.WriteLine("Collection Operator CONTAINS");
            var db = _Database;

            // tag::query-collection-operator-contains[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"),
                    SelectResult.Property("public_likes"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("hotel"))
                    .And(ArrayFunction.Contains(Expression.Property("public_likes"),
                        Expression.String("Armani Langworth"))))) {
                foreach (var result in query.Execute()) {
                    var publicLikes = result.GetArray("public_likes");
                    var jsonString = JsonConvert.SerializeObject(publicLikes);
                    Console.WriteLine($"Public Likes :: {jsonString}");
                }
            }
            // end::query-collection-operator-contains[]
        }

        private static void UseCollectionIn()
        {
            Console.WriteLine("Collection Operator IN");
            var db = _Database;

            // tag::query-collection-operator-in[]
            var values = new IExpression[]
                { Expression.Property("first"), Expression.Property("last"), Expression.Property("username") };

            using (var query = QueryBuilder.Select(
                    SelectResult.All())
                .From(DataSource.Database(db))
                .Where(Expression.String("Armani").In(values))) {
                foreach (var result in query.Execute()) {
                    var body = result.GetDictionary(0);
                    var jsonString = JsonConvert.SerializeObject(body);
                    Console.WriteLine($"In results :: {jsonString}");
                }
            }
            // end::query-collection-operator-in[]
        }

        private static void SelectLike()
        {
            Console.WriteLine("Like");
            var db = _Database;

            // tag::query-like-operator[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Function.Lower(Expression.Property("name")).Like(Expression.String("Royal Engineers Museum"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-like-operator[]
        }

        private static void SelectWildcardLike()
        {
            Console.WriteLine("Wildcard Like");
            var db = _Database;

            // tag::query-like-operator-wildcard-match[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Function.Lower(Expression.Property("name")).Like(Expression.String("Eng%e%"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-like-operator-wildcard-match[]
        }

        private static void SelectWildcardCharacterLike()
        {
            Console.WriteLine("Wildchard Characters");
            var db = _Database;

            // tag::query-like-operator-wildcard-character-match[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Expression.Property("name").Like(Expression.String("Royal Eng____rs Museum"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-like-operator-wildcard-character-match[]
        }

        private static void SelectRegex()
        {
            Console.WriteLine("Regex");
            var db = _Database;

            // tag::query-regex-operator[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("name"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("landmark"))
                    .And(Expression.Property("name").Regex(Expression.String("\\bEng.*e\\b"))))
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-regex-operator[]
        }

        private static void SelectJoin()
        {
            Console.WriteLine("Join");
            var db = _Database;

            // tag::query-join[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Expression.Property("name").From("airline")),
                    SelectResult.Expression(Expression.Property("callsign").From("airline")),
                    SelectResult.Expression(Expression.Property("destinationairport").From("route")),
                    SelectResult.Expression(Expression.Property("stops").From("route")),
                    SelectResult.Expression(Expression.Property("airline").From("route")))
                .From(DataSource.Database(db).As("airline"))
                .Join(Join.InnerJoin(DataSource.Database(db).As("route"))
                    .On(Meta.ID.From("airline").EqualTo(Expression.Property("airlineid").From("route"))))
                .Where(Expression.Property("type").From("route").EqualTo(Expression.String("route"))
                    .And(Expression.Property("type").From("airline").EqualTo(Expression.String("airline")))
                    .And(Expression.Property("sourceairport").From("route").EqualTo(Expression.String("RIX"))))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Name Property :: {result.GetString("name")}");
                }
            }
            // end::query-join[]
        }

        private static void GroupBy()
        {
            Console.WriteLine("GroupBy");
            var db = _Database;

            // tag::query-groupby[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Function.Count(Expression.All())),
                    SelectResult.Property("country"),
                    SelectResult.Property("tz"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("airport"))
                    .And(Expression.Property("geo.alt").GreaterThanOrEqualTo(Expression.Int(300))))
                .GroupBy(Expression.Property("country"), Expression.Property("tz"))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine(
                        $"There are {result.GetInt("$1")} airports in the {result.GetString("tz")} timezone located in {result.GetString("country")} and above 300 ft");
                }
            }
            // end::query-groupby[]
        }

        private static void OrderBy()
        {
            Console.WriteLine("OrderBy");
            var db = _Database;

            // tag::query-orderby[]
            using (var query = QueryBuilder.Select(
                    SelectResult.Expression(Meta.ID),
                    SelectResult.Property("title"))
                .From(DataSource.Database(db))
                .Where(Expression.Property("type").EqualTo(Expression.String("hotel")))
                .OrderBy(Ordering.Property("title").Ascending())
                .Limit(Expression.Int(10))) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Title :: {result.GetString("title")}");
                }
            }
            // end::query-orderby[]
        }

      // ### EXPLAIN statement
      private static void TestExplainStatement()
      // For Documentation
      {
        var db = _Database;
          // tag::query-explain-all[]
        var query =
          QueryBuilder
            .Select(SelectResult.All())
            .From(DataSource.Database(db))
            .Where(Expression.Property("type").EqualTo(Expression.String("hotel")))
            .GroupBy(Expression.Property("country"))
            .OrderBy(Ordering.Property("title").Ascending()) <i class="conum" data-value="8"></i><b>(8)</b>

          Console.WriteLine(query.Explain()); <i class="conum" data-value="9"></i><b>(9)</b>

          // end::query-explain-all[]
          // tag::query-explain-like[]
var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Database(db))
    .Where(Expression.Property("type").Like(Expression.String("%hotel%"))
      .And(Function.Lower(Expression.Property("name")).Like(Expression.String("%royal%")))); <i class="conum" data-value="10"></i><b>(10)</b>
  Console.WriteLine(query.Explain());

          // end::query-explain-like[]
          // tag::query-explain-nopfx[]
var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Database(db))
    .Where(Expression.Property("type").Like(Expression.String("hotel%"))
      .And(Function.Lower(Expression.Property("name")).Like(Expression.String("%royal%")))); <i class="conum" data-value="11"></i><b>(11)</b>

  Console.WriteLine(query.Explain());

          // end::query-explain-nopfx[]
          // tag::query-explain-function[]
var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Database(db))
    .Where(Function.Lower(Expression.Property("type")).EqualTo(Expression.String("hotel"))); <i class="conum" data-value="12"></i><b>(12)</b>

  Console.WriteLine(query.Explain());

          // end::query-explain-function[]
          // tag::query-explain-nofunction[]
        var query =
          QueryBuilder
            .Select(SelectResult.All())
            .From(DataSource.Database(db))
            .Where(Expression.Property("type")).EqualTo(Expression.String("hotel")); <i class="conum" data-value="13"></i><b>(13)</b>

          Console.WriteLine(query.Explain());

          // end::query-explain-nofunction[]
      }

      // end query-explain


        public void CreateFullTextIndex()
        {
            // tag::fts-index[]
            string[] indexProperties = new string[] { "overview", "name" };
            var config = new FullTextIndexConfiguration(indexProperties);
            db.CreateIndex("overviewFTSIndex", config);
            // end::fts-index[]
        }

        public void FullTextSearch()
        {
            Console.WriteLine("Full text search");
            // tag::fts-query[]

            var db = _database;
            var ftsQuery = db.CreateQuery("SELECT * FROM _ WHERE MATCH(overviewFTSIndex, 'Michigan') ORDER BY RANK(overviewFTSIndex)");
            foreach (var result in ftsQuery.Execute())
            {
                Console.WriteLine($"Document id {result.GetString(0)}");
            }
            }
            // end::fts-query[]
        }


        private static void CreateFullTextIndex_Querybuilder()
        {
            // tag::fts-index_Querybuilder[]
            var db = _Database;

            // end::fts-index_Querybuilder[]
            if (_NeedsExtraDocs) {
                var tasks = new[] { "buy groceries", "play chess", "book travels", "buy museum tickets" };
                foreach (var task in tasks) {
                    using (var doc = new MutableDocument()) {
                        doc.SetString("type", "task");
                        doc.SetString("name", task);
                        db.Save(doc);
                    }
                }
            }

            // tag::fts-index_Querybuilder[]

            var index = IndexBuilder.FullTextIndex(FullTextIndexItem.Property("overview")).IgnoreAccents(false);
            db.CreateIndex("overviewFTSIndex", index);
            // end::fts-index_Querybuilder[]
        }

        private static void FullTextSearch_Querybuilder()
        {
            Console.WriteLine("Full text search");
            var db = _Database;

            // tag::fts-query_Querybuilder[]
            var whereClause = FullTextFunction.Match("overviewFTSIndex", "'michigan'");

            using (var query = QueryBuilder.Select(SelectResult.Expression(Meta.ID))
                .From(DataSource.Database(db))
                .Where(whereClause)) {
                foreach (var result in query.Execute()) {
                    Console.WriteLine($"Document id {result.GetString(0)}");
                }
            }
            // end::fts-query_Querybuilder[]
        }
        private static void StartReplication()
        {
            var db = _Database;

            /*
             * This requires Sync Gateway running with the following config, or equivalent:
             *
             * {
             *     "log":["*"],
             *     "databases": {
             *         "db": {
             *             "server":"walrus:",
             *             "users": {
             *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
             *             }
             *         }
             *     }
             * }
             */

            // tag::replication[]
            // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)
            var url = new Uri("ws://localhost:4984/db");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(db, target)
            {
                ReplicatorType = ReplicatorType.Pull
            };

            var replicator = new Replicator(config);
            replicator.Start();
            // end::replication[]

            _Replicator = replicator;
        }

        private static void VerboseReplicatorLogging()
        {
            // tag::replication-logging[]
            // deprecated
            Database.SetLogLevel(LogDomain.Replicator, LogLevel.Verbose);
            Database.SetLogLevel(LogDomain.Network, LogLevel.Verbose);
            // end::replication-logging[]
        }

        private static void ConsoleLogging()
        {
            // tag::console-logging[]
            Database.Log.Console.Domains = LogDomain.All; <i class="conum" data-value="14"></i><b>(14)</b>
            Database.Log.Console.LogLevel = LogLevel.Verbose; <i class="conum" data-value="15"></i><b>(15)</b>

            // end::console-logging[]

            // tag::console-logging-db[]
            Database.Log.Console.Domains = LogDomain.Database;

            // end::console-logging-db[]
        }

        private static void FileLogging()
        {
            // tag::file-logging[]
            var tempFolder = Path.Combine(Service.GetInstance&lt;IDefaultDirectoryResolver&gt;().DefaultDirectory(), "cbllog");
            var config = new LogFileConfiguration(tempFolder) <i class="conum" data-value="16"></i><b>(16)</b>
            {
                MaxRotateCount = 5, <i class="conum" data-value="17"></i><b>(17)</b>
                MaxSize = 10240, <i class="conum" data-value="18"></i><b>(18)</b>
                UsePlainText = false  <i class="conum" data-value="19"></i><b>(19)</b>
            };
            Database.Log.File.Config = config; // Apply configuration
            Database.Log.File.Level = LogLevel.Info; <i class="conum" data-value="20"></i><b>(20)</b>

            // end::file-logging[]
        }

        private static void EnableCustomLogging()
        {
            // tag::set-custom-logging[]
            Database.Log.Custom = new LogTestLogger(); <i class="conum" data-value="21"></i><b>(21)</b>
            or
            Database.Log.Custom = new LogTestLogger { Level = LogLevel.Warning };

            // end::set-custom-logging[]
        }

        private static void WriteConsoleLog()
        {
            // tag::write-console-logmsg[]
            Database.Log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
            // end::write-console-logmsg[]
        }
        private static void WriteCustomLog()
        {
            // tag::write-custom-logmsg[]
            Database.Log.Custom?.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
            // end::write-custom-logmsg[]
        }


        private static void WriteFileLog()
        {
            // tag::write-file-logmsg[]
            Database.Log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
            // end::write-file-logmsg[]
        }

        private static void EnableBasicAuth()
        {
            var database = _Database;

            // tag::basic-authentication[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.Authenticator = new BasicAuthenticator("john", "pass");

            var replicator = new Replicator(config);
            replicator.Start();
            // end::basic-authentication[]
        }

        private static void EnableSessionAuth()
        {
            var database = _Database;

            // tag::session-authentication[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);
            var config = new ReplicatorConfiguration(database, target);
            config.Authenticator = new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447");

            var replicator = new Replicator(config);
            replicator.Start();
            // end::session-authentication[]
        }

        private static void SetupReplicatorListener()
        {
            var replicator = _Replicator;

            // tag::replication-status[]
            replicator.AddChangeListener((sender, args) =&gt;
            {
                if (args.Status.Activity == ReplicatorActivityLevel.Stopped) {
                    Console.WriteLine("Replication stopped");
                }
            });
            // end::replication-status[]
        }




    //  BEGIN PendingDocuments IB -- 11/Feb/21 --
    private static void ReplicatorPendingDocuments()
    {
        // tag::replication-pendingdocuments[]
        var url = new Uri("ws://localhost:4984/mydatabase");
        var target = new URLEndpoint(url);
        var database = new Database("myDB");
        var config = new ReplicatorConfiguration(database, target);
        config.ReplicatorType  = ReplicatorType.Push;

        // tag::replication-push-pendingdocumentids[]
        var replicator = new Replicator(config);

        var mydocids =
          new HashSet &lt;string&gt; (replicator.GetPendingDocumentIDs()); <i class="conum" data-value="22"></i><b>(22)</b>

        // end::replication-push-pendingdocumentids[]

        if (mydocids.Count &gt; 0)
        {
            Console.WriteLine($"There are {mydocids.Count} documents pending");
            replicator.AddChangeListener((sender, change) =&gt;
            {
                Console.WriteLine($"Replicator activity level is " +
                                  change.Status.Activity.ToString());
                // iterate and report-on previously
                // retrieved pending docids 'list'
                foreach (var thisId in mydocids)
                    // tag::replication-push-isdocumentpending[]
                    if (!replicator.IsDocumentPending(thisId)) <i class="conum" data-value="23"></i><b>(23)</b>
                    {
                        Console.WriteLine($"Doc ID {thisId} now pushed");
                    };
                // end::replication-push-isdocumentpending[]
            });

            replicator.Start();
        }
    // end::replication-pendingdocuments[]
    }


//  END PendingDocuments IB -- 11/Feb/21 --



		private static void ReplicatorDocumentEvent()
        {
            var replicator = _Replicator;

            // tag::add-document-replication-listener[]
            var token = replicator.AddDocumentReplicationListener((sender, args) =&gt;
            {
                var direction = args.IsPush ? "Push" : "Pull";
                Console.WriteLine($"Replication type :: {direction}");
                foreach (var document in args.Documents) {
                    if (document.Error == null) {
                        Console.WriteLine($"Doc ID :: {document.Id}");
                        if (document.Flags.HasFlag(DocumentFlags.Deleted)) {
                            Console.WriteLine("Successfully replicated a deleted document");
                        }
                    } else {
                        // There was an error
                    }
                }
            });

            replicator.Start();
            // end::add-document-replication-listener[]

            // tag::remove-document-replication-listener[]
            replicator.RemoveChangeListener(token);
            // end::remove-document-replication-listener[]
        }

        private static void SetupReplicatorErrorListener()
        {
            // This can be done in the SetupReplicatorListener method
            // But it is separate so that we can have two documentation entries

            var replicator = _Replicator;

            // tag::replication-error-handling[]
            replicator.AddChangeListener((sender, args) =&gt;
            {
                if (args.Status.Error != null) {
                    Console.WriteLine($"Error :: {args.Status.Error}");
                }
            });
            // end::replication-error-handling[]
        }

        private static void DatabaseReplica()
        {
            var db = _Database;
            using (var database2 = new Database("backup")) {
                // EE feature: This code will not compile on the community edition
                // tag::database-replica[]
                var targetDatabase = new DatabaseEndpoint(database2);
                var config = new ReplicatorConfiguration(db, targetDatabase)
                {
                    ReplicatorType = ReplicatorType.Push
                };

                var replicator = new Replicator(config);
                replicator.Start();
                // end::database-replica[]

                _Replicator?.Stop();
                _Replicator = replicator;
            }
        }

        private static void PinCertificate()
        {
            // Note: No certificate is included here, so this code is for show only
            var url = new Uri("wss://localhost:4984/db");
            var target = new URLEndpoint(url);
            var db = _Database;

            // tag::certificate-pinning[]
            // Note: `GetCertificate` is a fake method. This would be the platform-specific method
            // to find and load the certificate as an instance of `X509Certificate2`.
            // For .NET Core / .NET Framework this can be loaded from the filesystem path.
            // For UWP, from the assets directory.
            // For iOS, from the main bundle.
            // For Android, from the assets directory.
            var certificate = GetCertificate("cert.cer");
            var config = new ReplicatorConfiguration(db, target)
            {
                PinnedServerCertificate = certificate
            };
            // end::certificate-pinning[]
        }

        private static void ReplicationCustomHeaders()
        {
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            // tag::replication-custom-header[]
            var config = new ReplicatorConfiguration(database, target)
            {
                Headers = new Dictionary&lt;string, string&gt;
                {
                    ["CustomHeaderName"] = "Value"
                }
            };
            // end::replication-custom-header[]
        }

        private static void PushWithFilter(Database database)
        {
            // tag::replication-push-filter[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            var config = new ReplicatorConfiguration(database, target);
            config.PushFilter = (document, flags) =&gt; <i class="conum" data-value="1"></i><b>(1)</b>
            {
                if (flags.HasFlag(DocumentFlags.Deleted)) {
                    return false;
                }

                return true;
            };

            // Dispose() later
            var replicator = new Replicator(config);
            replicator.Start();
            // end::replication-push-filter[]
        }

        private static void PullWithFilter(Database database)
        {
            // tag::replication-pull-filter[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            var config = new ReplicatorConfiguration(database, target);
            config.PullFilter = (document, flags) =&gt; <i class="conum" data-value="1"></i><b>(1)</b>
            {
                if (document.GetString("type") == "draft") {
                    return false;
                }

                return true;
            };

            // Dispose() later
            var replicator = new Replicator(config);
            replicator.Start();
            // end::replication-pull-filter[]
        }

        public void TestCustomRetryConfig()
        {
        // tag::replication-retry-config[]
            var url = new Uri("ws://localhost:4984/mydatabase");
            var target = new URLEndpoint(url);

            var config = new ReplicatorConfiguration(database, target);

        //  other config as required . . .

        // tag::replication-set-heartbeat[]
            config.Heartbeat = TimeSpan.FromSeconds(120); //  <i class="conum" data-value="24"></i><b>(24)</b>
        // end::replication-set-heartbeat[]
        // tag::replication-set-maxattempts[]
            config.Maxattempts = 20; //  <i class="conum" data-value="25"></i><b>(25)</b>
        // end::replication-set-maxattempts[]
        // tag::replication-set-maxattemptwaittime[]
            config.MaxAttemptWaitTime = TimeSpan.FromSeconds(600); //  <i class="conum" data-value="26"></i><b>(26)</b>
        // end::replication-set-maxattemptwaittime[]

        //  other config as required . . .

            var repl = new Replicator(config);

        // end::replication-retry-config[]
        }


        private static void UsePredictiveModel()
        {
            using (var db = new Database("mydb")) {
                // tag::register-model[]
                var model = new ImageClassifierModel();
                Database.Prediction.RegisterModel("ImageClassifier", model);
                // end::register-model[]

                // tag::predictive-query-value-index[]
                var index = IndexBuilder.ValueIndex(ValueIndexItem.Property("label"));
                db.CreateIndex("value-index-image-classifier", index);
                // end::predictive-query-value-index[]

                // tag::unregister-model[]
                Database.Prediction.UnregisterModel("ImageClassifier");
                // end::unregister-model[]
            }
        }

        private static void UsePredictiveIndex()
        {
            using (var db = new Database("mydb")) {
                // tag::predictive-query-predictive-index[]
                var input = Expression.Dictionary(new Dictionary&lt;string, object&gt;
                {
                    ["photo"] = Expression.Property("photo")
                });

                var index = IndexBuilder.PredictiveIndex("ImageClassifier", input);
                db.CreateIndex("predictive-index-image-classifier", index);
                // end::predictive-query-predictive-index[]
            }
        }

        private static void DoPredictiveQuery()
        {
            using (var db = new Database("mydb")) {
                // tag::predictive-query[]
                var input = Expression.Dictionary(new Dictionary&lt;string, object&gt;
                {
                    ["photo"] = Expression.Property("photo")
                });
                var prediction = PredictiveModel.predict("ImageClassifier", input); <i class="conum" data-value="1"></i><b>(1)</b>

                using (var q = QueryBuilder.Select(SelectResult.All())
                    .From(DataSource.Database(db))
                    .Where(prediction.Property("label").EqualTo(Expression.String("car"))
                        .And(prediction.Property("probability").GreaterThanOrEqualTo(Expression.Double(0.8))))) {
                    var result = q.Execute();
                    Console.WriteLine($"Number of rows: {result.Count()}");
                }
                // end::predictive-query[]
            }
        }

        static void Main(string[] args)
        {
            // This only needs to be done once for whatever platform the executable is running
            // (UWP, iOS, Android, or desktop)
            Couchbase.Lite.Support.NetDesktop.Activate();

            CreateNewDatabase();
            CreateDocument();
            UpdateDocument();
            UseTypedAccessors();
            DoBatchOperation();
            UseBlob();
            SelectMeta();

            LoadPrebuilt();
            CreateIndex();
            SelectWhere();
            UseCollectionContains();
            SelectLike();
            SelectWildcardLike();
            SelectWildcardCharacterLike();
            SelectRegex();
            SelectJoin();
            GroupBy();
            OrderBy();

            CreateFullTextIndex();
            FullTextSearch();
            StartReplication();
            SetupReplicatorListener();

            _Replicator.Stop();
            while (_Replicator.Status.Activity != ReplicatorActivityLevel.Stopped) {
                // Database cannot close until replicators are stopped
                Console.WriteLine($"Waiting for replicator to stop (currently {_Replicator.Status.Activity})...");
                Thread.Sleep(200);
            }

            _Database.Close();
        }

        #endregion
    }

    /* ----------------------------------------------------------- */
    /* ---------------------  ACTIVE SIDE  ----------------------- */
    /* ---------------  stubs for documentation  ----------------- */
    /* ----------------------------------------------------------- */

    class ActivePeer : IMessageEndpointDelegate
    {
        ActivePeer()
        {
            var id = "";

            // tag::message-endpoint[]
            var database = new Database("dbname");

            // The delegate must implement the `IMessageEndpointDelegate` protocol.
            var messageEndpointTarget = new MessageEndpoint(uid: "UID:123", target: "",
                protocolType: ProtocolType.MessageStream, delegateObject: this);
            // end::message-endpoint[]

            // tag::message-endpoint-replicator[]
            var config = new ReplicatorConfiguration(database, messageEndpointTarget);

            // Create the replicator object
            var replicator = new Replicator(config);
            // Start the replicator
            replicator.Start();
            // end::message-endpoint-replicator[]
        }

        // tag::create-connection[]
        /* implementation of MessageEndpointDelegate */
        public IMessageEndpointConnection CreateConnection(MessageEndpoint endpoint)
        {
            var connection = new ActivePeerConnection(); /* implements MessageEndpointConnection */
            return connection;
        }
        // end::create-connection[]
    }

    class ActivePeerConnection : IMessageEndpointConnection
    {
        private IReplicatorConnection _replicatorConnection;

        public void Disconnect()
        {
            // tag::active-replicator-close[]
            _replicatorConnection?.Close(null);
            // end::active-replicator-close[]
        }

        public void Receive(byte[] data)
        {
            // tag::active-peer-receive[]
            var message = Message.FromBytes(data);
            _replicatorConnection?.Receive(message);
            // end::active-peer-receive[]
        }

        // tag::active-peer-close[]
        /* implementation of MessageEndpointConnection */
        public async Task Close(Exception error)
        {
            // await socket.Close, etc (or do nothing if already closed)
            // throw MessagingException if something goes wrong (though
            // since it is "close" nothing special will happen)
        }
        // end::active-peer-close[]

        // tag::active-peer-open[]
        /* implementation of MessageEndpointConnection */
        public async Task Open(IReplicatorConnection connection)
        {
            _replicatorConnection = connection;
            // await socket.Open(), etc
            // throw MessagingException if something goes wrong
        }
        // end::active-peer-open[]

        // tag::active-peer-send[]
        /* implementation of MessageEndpointConnection */
        public async Task Send(Message message)
        {
            var data = message.ToByteArray();
            // await Socket.Send(), etc
            // throw MessagingException if something goes wrong
        }
        // end::active-peer-send[]
    }

    /* ----------------------------------------------------------- */
    /* ---------------------  PASSIVE SIDE  ---------------------- */
    /* ---------------  stubs for documentation  ----------------- */
    /* ----------------------------------------------------------- */
    class PassivePeerConnection : IMessageEndpointConnection
    {
        private MessageEndpointListener _messageEndpointListener;
        private IReplicatorConnection _replicatorConnection;

        public void StartListener()
        {
            // tag::listener[]
            var database = new Database("mydb");
            var config = new MessageEndpointListenerConfiguration(database, ProtocolType.MessageStream);
            _messageEndpointListener = new MessageEndpointListener(config);
            // end::listener[]
        }

        public void StopListener()
        {
            // tag::passive-stop-listener[]
            _messageEndpointListener?.CloseAll();
            // end::passive-stop-listener[]
        }

        public void AcceptConnection()
        {
            // tag::advertizer-accept[]
            var connection = new PassivePeerConnection(); /* implements MessageEndpointConnection */
            _messageEndpointListener?.Accept(connection);
            // end::advertizer-accept[]
        }

        public void Disconnect()
        {
            // tag::passive-replicator-close[]
            _replicatorConnection?.Close(null);
            // end::passive-replicator-close[]
        }

        public void Receive(byte[] data)
        {
            // tag::passive-peer-receive[]
            var message = Message.FromBytes(data);
            _replicatorConnection?.Receive(message);
            // end::passive-peer-receive[]
        }

        // tag::passive-peer-close[]
        /* implementation of MessageEndpointConnection */
        public async Task Close(Exception error)
        {
            // await socket.Close, etc (or do nothing if already closed)
            // throw MessagingException if something goes wrong (though
            // since it is "close" nothing special will happen)
        }
        // end::passive-peer-close[]

        // tag::passive-peer-open[]
        /* implementation of MessageEndpointConnection */
        public Task Open(IReplicatorConnection connection)
        {
            _replicatorConnection = connection;
            // socket should already be open on the passive side
            return Task.FromResult(true);
        }
        // end::passive-peer-open[]

        // tag::passive-peer-send[]
        /* implementation of MessageEndpointConnection */
        public async Task Send(Message message)
        {
            var data = message.ToByteArray();
            // await Socket.Send(), etc
            // throw MessagingException if something goes wrong
        }
        // end::passive-peer-send[]
    }

    // tag::predictive-model[]
    // tensorFlowModel is a fake implementation
    // this would be the implementation of the ml model you have chosen
    class TensorFlowModel
    {
        public static IDictionary&lt;string, object&gt; PredictImage(byte[] data)
        {
            // Do calculations, etc
            return null;
        }
    }

    class ImageClassifierModel : IPredictiveModel
    {
        public DictionaryObject Predict(DictionaryObject input)
        {
            var blob = input.GetBlob("photo");
            if (blob == null) {
                return null;
            }

            var imageData = blob.Content;
            // tensorFlowModel is a fake implementation
            // this would be the implementation of the ml model you have chosen
            var modelOutput = TensorFlowModel.PredictImage(imageData);
            return new MutableDictionaryObject(modelOutput); <i class="conum" data-value="1"></i><b>(1)</b>
        }
    }
    // end::predictive-model[]

    // tag::custom-logging[]
    private class LogTestLogger : ILogger
    {
        public LogLevel Level { get; set; }

        public void Reset()
        {
            _lines.Clear();
        }

        public void Log(LogLevel level, LogDomain domain, string message)
        {
            // handle the message, for example piping it to
            // a third party framework
        }
    }
    // end::custom-logging[]

    // tag::local-win-conflict-resolver[]
    class LocalWinConflictResolver : IConflictResolver
    {
        Document Resolve(Conflict conflict)
        {
            return conflict.LocalDocument;
        }
    }
    // end::local-win-conflict-resolver[]

    // tag::remote-win-conflict-resolver[]
    class RemoteWinConflictResolver : IConflictResolver
    {
        public Document Resolve(Conflict conflict)
        {
            return conflict.RemoteDocument;
        }
    }
    // end::remote-win-conflict-resolver[]

    // tag::merge-conflict-resolver[]
    class MergeConflictResolver : IConflictResolver
    {
        public Document Resolve(Conflict conflict)
        {
            var localDict = conflict.LocalDocument.ToDictionary();
            var remoteDict = conflict.RemoteDocument.ToDictionary();
            var result = localDict.Concat(remoteDict)
               .GroupBy(kv =&gt; kv.Key)
               .ToDictionary(g =&gt; g.Key, g =&gt; g.First().Value);
            return new MutableDocument(conflict.DocumentID, result);
        }
    }
    // end::merge-conflict-resolver[]
}

// N1QL QUERY

  public List&lt;Result&gt; docsonly_N1QLQueryString(Database argDB)
  {
      DatabaseConfiguration dbCfg = new DatabaseConfiguration();

      Database thisDb = new Database(dbName, dbCfg);

      // For Documentation -- N1QL Query
      // tag::query-syntax-n1ql[]
      var thisQuery =
          thisDb.CreateQuery("SELECT META().id AS thisId FROM _ WHERE type = \"hotel\""); <i class="conum" data-value="27"></i><b>(27)</b>

      return thisQuery.Execute().AllResults();

      // end::query-syntax-n1ql[]
  }


  public  List&lt;Result&gt; docsonly_N1QLQueryStringParams(Database argDB)
  {
      DatabaseConfiguration dbCfg = new DatabaseConfiguration();

      Database thisDb = new Database(dbName, dbCfg);

      // For Documentation -- N1QL Query
      // tag::query-syntax-n1ql-params[]
      // Declared elsewhere: Database argDB

      var thisQuery =
          thisDb.CreateQuery("SELECT META().id AS thisId FROM _ WHERE type = $type"); <i class="conum" data-value="28"></i><b>(28)</b>

      var n1qlParams = new Parameters();
      n1qlParams.SetString("type", "hotel"); <i class="conum" data-value="29"></i><b>(29)</b>
      thisQuery.Parameters = n1qlParams;

      return thisQuery.Execute().AllResults();

      // end::query-syntax-n1ql-params[]
  }


// QUERY RESULT SET HANDLING EXAMPLES

    public static void testQuerySyntaxAll()
    {
        // For Documentation
        var dbName = "travel-sample";

        string thisDocsId;
        string thisDocsName;
        string thisDocsType;
        string thisDocsCity;
        Dictionary&lt;string,object&gt; hotel = new Dictionary&lt;string,object&gt;();

        // tag::query-syntax-all[]
        var this_Db = new Database("hotels") ;

        var query = QueryBuilder
              .Select(SelectResult.All())
              .From(DataSource.Database(this_Db));

        // end::query-syntax-all[]

        // tag::query-access-all[]
        var results = query.Execute().AllResults();

        if (results?.Count &gt; 0)
        {
            List&lt;Dictionary&lt;string,object&gt;&gt; hotels = new List&lt;Dictionary&lt;string,object&gt;&gt;();
            foreach (var result in results)
            {
                // get the result into our dictionary object
                var thisDocsProps = result.GetDictionary(dbName); <i class="conum" data-value="30"></i><b>(30)</b>

                if (thisDocsProps != null)
                {
                    thisDocsId = thisDocsProps.GetString("id"); <i class="conum" data-value="31"></i><b>(31)</b>
                    thisDocsName = thisDocsProps.GetString("name");
                    thisDocsCity = thisDocsProps.GetString("city");
                    thisDocsType = thisDocsProps.GetString("type");
                    hotel = thisDocsProps.ToDictionary();
                    hotels.Add(hotel);
                }

            }
        }
        // end::query-access-all[]

    // tag::query-access-json[]

    foreach (var result in query.Execute().AsEnumerable()) {

        // get the result into a JSON String
                var thisDocsJSONString = result.ToJSON();<i class="conum" data-value="32"></i><b>(32)</b>

        // Get a native dictionary object using the JSON string
        var dictFromJSONstring =
              JsonConvert.
                DeserializeObject&lt;Dictionary&lt;string, object&gt;&gt;
                  (thisDocsJSONString); <i class="conum" data-value="33"></i><b>(33)</b>

        // use the created dictionary
        if (dictFromJSONstring != null)
        {
            thisDocsId = dictFromJSONstring["id"].ToString();
            thisDocsName = dictFromJSONstring["name"].ToString();
            thisDocsCity = dictFromJSONstring["city"].ToString();
            thisDocsType = dictFromJSONstring["type"].ToString();
        }

        //Get a custom object using the JSON string
        Hotel this_hotel =
            JsonConvert.DeserializeObject&lt;Hotel&gt;(thisDocsJSONString); <i class="conum" data-value="34"></i><b>(34)</b>

        // Store this hotel object in a list of hotels
        hotels.Add(
            this_hotel.Id.ToString(),
                this_hotel);

    } // end foreach result
    // end::query-access-json[]
  }


    private static void testQuerySyntaxProps()
    {
        // For Documentation
        var dbName = "travel-sample";
        // var this_Db = new Database(dbName);

        string thisDocsName;
        string thisDocsType;
        string thisDocsCity;
        // tag::query-syntax-props[]
        var this_Db = new Database("hotels") ;

        Dictionary&lt;string, object&gt; hotel = new Dictionary&lt;string, object&gt;();

        List&lt;Dictionary&lt;string, object&gt;&gt; hotels = new List&lt;Dictionary&lt;string, object&gt;&gt;();

        var query = QueryBuilder.Select(
                SelectResult.Property("type"),
                SelectResult.Property("name"),
                SelectResult.Property("city")).From(DataSource.Database(this_Db));
        // end::query-syntax-props[]

        // tag::query-access-props[]
        var results = query.Execute().AllResults();
        foreach (var result in results)
        {

            // get the returned array of k-v pairs into a dictionary
            hotel = result.ToDictionary();

            // add hotel dictionary to list of hotel dictionaries
            hotels.Add(hotel);

            // use the properties of the returned array of k-v pairs directly
            thisDocsType = result.GetString("type");
            thisDocsName = result.GetString("name");
            thisDocsCity = result.GetString("city");

        }

    // end::query-access-props[]
    } // test-query-access-props



    private static void testQuerySyntaxCount()
    {
        // For Documentation
        var dbName = "travel-sample";
        // var this_Db = new Database(dbName);

        Dictionary&lt;string, object&gt; hotel = new Dictionary&lt;string, object&gt;();
        List&lt;Dictionary&lt;string, object&gt;&gt; hotels = new List&lt;Dictionary&lt;string, object&gt;&gt;();

        // tag::query-syntax-count-only[]
        var this_Db = new Database("hotels") ;

        var query =
          QueryBuilder
            .Select(SelectResult.Expression(Function.Count(Expression.All())).As("mycount")) <i class="conum" data-value="35"></i><b>(35)</b>
            .From(DataSource.Database(this_Db));

        // end::query-syntax-count-only[]


        // tag::query-access-count-only[]

        var results = query.Execute().AllResults();

        foreach (var result in results)
        {

            var numberOfDocs = result.GetInt("mycount"); <i class="conum" data-value="36"></i><b>(36)</b>

        }

        // end::query-access-count-only[]
    }




    private static void ibQueryForID()
    {

        // For Documentation
        var dbName = "travel-sample";
        // var this_Db = new Database(dbName);

        Dictionary&lt;string, object&gt; hotel = new Dictionary&lt;string, object&gt;();
        List&lt;Dictionary&lt;string, object&gt;&gt; hotels = new List&lt;Dictionary&lt;string, object&gt;&gt;();


        // tag::query-syntax-id[]
        var this_Db = new Database("hotels") ;

        var query = QueryBuilder
                .Select(SelectResult.Expression(Meta.ID).As("this_ID"))
                .From(DataSource.Database(this_Db));

        // end::query-syntax-id[]


        // tag::query-access-id[]
        var results = query.Execute().AllResults();
        foreach (var result in results)
        {

            var thisDocsID = result.GetString("this_ID"); <i class="conum" data-value="37"></i><b>(37)</b>
            var doc = this_Db.GetDocument(thisDocsID);
        }

        // end::query-access-id[]
    }


// tag::query-syntax-pagination-all[]
    private static void testQueryPagination()
    {
      // For Documentation
      var dbName = "travel-sample";
      // var this_Db = new Database(dbName);

    // tag::query-syntax-pagination[]
      var this_Db = new Database("hotels") ;

      var thisLimit = 20;
      var thisOffset = 0;

      // get a count of the number of docs matching the query
      var countQuery =
          QueryBuilder
              .Select(SelectResult.Expression(Function.Count(Expression.All())).As("mycount"))
              .From(DataSource.Database(this_Db));
      var numberOfDocs =
          countQuery.Execute().AllResults().ElementAt(0).GetInt("mycount");

      if (numberOfDocs &lt; thisLimit) {
          thisLimit = numberOfDocs;
      }

      while (thisOffset &lt; numberOfDocs)
      {
          var listQuery =
              QueryBuilder
                  .Select(SelectResult.All())
                  .From(DataSource.Database(this_Db))
                  .Limit(Expression.Int(thisLimit), Expression.Int(thisOffset)); <i class="conum" data-value="38"></i><b>(38)</b>

          foreach (var result in listQuery.Execute().AllResults())
          {
              // Display and or process query results batch

          }

          thisOffset = thisOffset + thisLimit;

      } // end while

// end::query-syntax-pagination[]
// end::query-syntax-pagination-all[]
    }

    // JSONAPIMETHODS



        public void JsonApiDocument()
        {

            // tag::tojson-document[]
            Database this_DB = new Database("travel-sample");
            Database newDb = new Database("ournewdb");

            // Get a document
            var thisDoc = this_Db.GetDocument("hotel_10025");

            // Get document data as JSON String
            var thisDocAsJsonString = thisDoc?.ToJSON(); <i class="conum" data-value="39"></i><b>(39)</b>

            // Get Json Object from the Json String
            JObject myJsonObj = JObject.Parse(thisDocAsJsonString);

            // Get Native Object (anhotel) from JSON String
            List&lt;Hotel&gt; thehotels = new List&lt;Hotel&gt;();

            Hotel anhotel = new Hotel();
            anhotel = JsonConvert.DeserializeObject&lt;Hotel&gt;(thisDocAsJsonString);
            thehotels.Add(anhotel);

            // Update the retrieved native object
            anhotel.Name = "A Copy of " + anhotel.Name;
            anhotel.Id = "2001";

            // Convert the updated object back to a JSON string
            var newJsonString = JsonConvert.SerializeObject(anhotel);

            // Update new document with JSOn String
            MutableDocument newhotel =
                new MutableDocument(anhotel.Id, newJsonString); <i class="conum" data-value="40"></i><b>(40)</b>

            foreach (string key in newhotel.ToDictionary().Keys)
            {
                System.Console.WriteLine("Data -- {0} = {1}",
                    key, newhotel.GetValue(key));
            }

            newDb.Save(newhotel);

            var thatDoc = newDb.GetDocument("2001").ToJSON(); <i class="conum" data-value="41"></i><b>(41)</b>
            System.Console.Write(thatDoc);

            // end::tojson-document[]


        //    // tag::tojson-document-output[]
        //    JSON String = { "description":"Very good and central","id":"1000","country":"France","name":"Hotel Ted","type":"hotel","city":"Paris"}
        //             type = hotel
        //             id = 1000
        //             country = France
        //             city = Paris
        //             description = Very good and central
        //             name = Hotel Ted
        //        // end::tojson-document-output[]
        //         */

        } // End JSONAPIDocument


    public void JsonApiArray()
        {
            // Init for docs
            //var this_Db = DataStore.getDbHandle();
            var ourdbname = "ournewdb";

            if (Database.Exists(ourdbname, "/"))
            {
                Database.Delete(ourdbname, "/");
            }

        // tag::tojson-array[]

            Database dbNew = new Database(ourdbname);

            // JSON String -- an Array (3 elements. including embedded arrays)
            var thisJSONstring = "[{'id':'1000','type':'hotel','name':'Hotel Ted','city':'Paris','country':'France','description':'Undefined description for Hotel Ted'},{'id':'1001','type':'hotel','name':'Hotel Fred','city':'London','country':'England','description':'Undefined description for Hotel Fred'},                        {'id':'1002','type':'hotel','name':'Hotel Ned','city':'Balmain','country':'Australia','description':'Undefined description for Hotel Ned','features':['Cable TV','Toaster','Microwave']}]".Replace("'", "\"");

            // Get JSON Array from JSON String
            JArray myJsonObj = JArray.Parse(thisJSONstring);

            // Create mutable array using JSON String Array
            var myArray = new MutableArrayObject();
            myArray.SetJSON(thisJSONstring);  <i class="conum" data-value="42"></i><b>(42)</b>


            // Create a new documenty for each array element
            for (int i = 0; i &lt; myArray.Count; i++)
            {
                var dict = myArray.GetDictionary(i);
                var docid = myArray[i].Dictionary.GetString("id");
                var newdoc = new MutableDocument(docid, dict.ToDictionary()); <i class="conum" data-value="43"></i><b>(43)</b>
                dbNew.Save(newdoc);
            }

            // Get one of the created docs and iterate through one of the embedded arrays
            var extendedDoc = dbNew.GetDocument("1002");
            var features = extendedDoc.GetArray("features");
            <i class="conum" data-value="44"></i><b>(44)</b>
            foreach (string feature in features) {
                System.Console.Write(feature);
                //process array item as required
            }
            var featuresJSON = extendedDoc.GetArray("features").ToJSON(); <i class="conum" data-value="45"></i><b>(45)</b>

            // end::tojson-array[]
        }


        public void JsonApiDictionary()
        {

            var ourdbname = "ournewdb";

            if (Database.Exists(ourdbname, "/"))
            {
                Database.Delete(ourdbname, "/");
            }
            Database dbNew = new Database(ourdbname);

            // tag::tojson-dictionary[]

            // Get dictionary from JSONstring
            var aJSONstring = "{'id':'1002','type':'hotel','name':'Hotel Ned','city':'Balmain','country':'Australia','description':'Undefined description for Hotel Ned','features':['Cable TV','Toaster','Microwave']}".Replace("'", "\"");
            var myDict = new MutableDictionaryObject(json: aJSONstring); <i class="conum" data-value="46"></i><b>(46)</b>

            // use dictionary to get name value
            var name = myDict.GetString("name");


            // Iterate through keys
            foreach (string key in myDict.Keys)
            {
                System.Console.WriteLine("Data -- {0} = {1}", key, myDict.GetValue(key).ToString());

            }
            // end::tojson-dictionary[]

            /*
            // tag::tojson-dictionary-output[]

                mono-stdout: Data -- id = 1002
                mono-stdout: Data -- type = hotel
                mono-stdout: Data -- name = Hotel Ned
                mono-stdout: Data -- city = Balmain
                mono-stdout: Data -- country = Australia
                mono-stdout: Data -- description = Undefined description for Hotel Ned
                mono-stdout: Data -- features = Couchbase.Lite.MutableArrayObject

            // end::tojson-dictionary-output[]
            */
        } /* end of func */


         public void JsonApiBlob()
        {
            // Init
            var ourpath = DataStore.getUserFolder();
            var ourdbname = "ournewdb";
            var userName = "ian";
            //ourpath = Path.Combine(ourpath,userName);

            if (Database.Exists(ourdbname, ourpath))
            {
                Database.Delete(ourdbname, ourpath);
            }
            var dbCfg = new DatabaseConfiguration();
            dbCfg.Directory=ourpath;
            Database dbNew = new Database(ourdbname,dbCfg);

            // tag::tojson-blob[]

            // Initialize base document for blob from a JSON string
            var docId = "1002";
            var aJSONstring = "{'ref':'hotel_1002','type':'hotel','name':'Hotel Ned'," +
                "'city':'Balmain','country':'Australia'," +
                "'description':'Undefined description for Hotel Ned'," +
                "'features':['Cable TV','Toaster','Microwave']}".Replace("'", "\"");
            var myDoc = new MutableDocument(docId, aJSONstring); <i class="conum" data-value="47"></i><b>(47)</b>


            // Get the content (an image), create blob and add to doc)
            var defaultDirectory =
                Path.Combine(Service.GetInstance&lt;IDefaultDirectoryResolver&gt;()
                            .DefaultDirectory(),
                                userName);
            var myImagePath = Path.Combine(defaultDirectory, "avatarimage.jpg");
            var myImageUri = new Uri(myImagePath.ToString());
            var myBlob = new Blob("image/jpg", myImageUri); <i class="conum" data-value="48"></i><b>(48)</b>
            myDoc.SetBlob("avatar", myBlob); <i class="conum" data-value="49"></i><b>(49)</b>


            // This example generates a 'blob not saved' exception
            try { Console.WriteLine("myBlob (unsaved) as JSON = {0}", myBlob.ToJSON());}
                catch (Exception e)
                    {Console.WriteLine("Exception = {0}", e.Message);}

            dbNew.Save(myDoc);

            // Alternatively -- depending on use case
            dbNew.SaveBlob(new Blob("image/jpg", myImageUri)); <i class="conum" data-value="50"></i><b>(50)</b>


            // Retrieve saved doc, get blob as JSON andheck its still a 'blob'
            var sameDoc = dbNew.GetDocument(docId);
            var reconstitutedBlob = new MutableDictionaryObject().
                SetDictionary("blobCOPY", new MutableDictionaryObject(sameDoc.GetBlob("avatar").ToJSON())); <i class="conum" data-value="51"></i><b>(51)</b>

            if (Blob.IsBlob(
                    reconstitutedBlob.GetDictionary("blobCOPY").ToDictionary()))  <i class="conum" data-value="52"></i><b>(52)</b>
            {
               //... process accordingly
               Console.WriteLine("Its a Blob!!");
            }

            // end::tojson-blob[]
            var datavalue = "";
            foreach (string key in myDoc.Keys)
            {
                if (key == "features")
                {
                    datavalue = "features are: ";
                    foreach (string item in myDoc.GetArray(key))
                    {
                        datavalue = datavalue + ", " + item;
                    }
                }
                else if (key == "avatar")
                {
                    datavalue = sameDoc.GetBlob(key).ToJSON();
                }
                else
                {
                    datavalue = sameDoc.GetValue(key).ToString();
                }

                System.Console.WriteLine(" Data -- {0} = {1}", key, datavalue);
            }

            // System.Console.WriteLine(" reconstitutedBlob = {0}", reconstitutedBlob.GetDictionary("blobCOPY").ToJSON());



            //}

            /*
            // tag::tojson-blob-output[]


                Exception = Missing Digest Due To Blob Is Not Saved To Database yet.

                Data -- id = 1002
                Data -- type = hotel
                Data -- name = Hotel Ned
                Data -- city = Balmain
                Data -- country = Australia
                Data -- description = Undefined description for Hotel Ned
                Data -- features = features are: , Cable TV, Toaster, Microwave
                Data -- avatar = {"digest":"sha1-sdCxeOeP3IZV4FEvVVlvtulpWA8=","length":2975,"content_type":"image/jpg","@type":"blob"}

                blobAsJSONstring = {"digest":"sha1-sdCxeOeP3IZV4FEvVVlvtulpWA8=","length":2975,"content_type":"image/jpg","@type":"blob"}

            // end::tojson-blob-output[]
            */
        } /* end of func */




  } // end of class



// p2p sync items


// tag::listener-simple[]
var thisConfig = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="53"></i><b>(53)</b>

thisConfig.Authenticator =
  new ListenerPasswordAuthenticator(
    (sender, username, password) =&gt;
      {
      return username.equals("valid.user")  &amp;&amp; (password == validPassword);
      }
  ); <i class="conum" data-value="54"></i><b>(54)</b>

_thisListener = new URLEndpointListener(thisConfig); <i class="conum" data-value="55"></i><b>(55)</b>

_thisListener.Start(); <i class="conum" data-value="56"></i><b>(56)</b>

// end::listener-simple[]



// tag::replicator-simple[]
var theListenerEndpoint = new URLEndpoint("wss://listener.com:4984/otherDB"); <i class="conum" data-value="57"></i><b>(57)</b>

var thisConfig = new ReplicatorConfiguration(thisDB, theListenerEndpoint); <i class="conum" data-value="58"></i><b>(58)</b>

thisConfig.AcceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="59"></i><b>(59)</b>

thisConfig.Authenticator =
  new BasicAuthenticator("valid.user", "valid.password.string"); <i class="conum" data-value="60"></i><b>(60)</b>

var thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="61"></i><b>(61)</b>

thisReplicator.Start(); <i class="conum" data-value="62"></i><b>(62)</b>

// end::replicator-simple[]







// PASSIVE PEER STUFF
// Stuff I adapted
//
//
// p2pSync-websockets.cs
//
// Copyright (c) 2017 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;

using Couchbase.Lite;
using Couchbase.Lite.Enterprise.Query;
using Couchbase.Lite.Logging;
using Couchbase.Lite.P2P;
using Couchbase.Lite.Query;
using Couchbase.Lite.Sync;
using Newtonsoft.Json;

using SkiaSharp;
namespace api_walkthrough
{
  class Program
  {
  private static Database _Database;
  private static Replicator _Replicator;
  private static ListenerToken _thisListenerToken;
  private static bool _NeedsExtraDocs;

  #region Private Methods
  private static void GettingStarted()
  {
    // tag::listener-initialize[]

    // tag::listener-config-db[]
    // Initialize the listener config
    var thisConfig = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="63"></i><b>(63)</b>

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.Port = 55990; <i class="conum" data-value="64"></i><b>(64)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    thisConfig.NetworkInterface = "10.1.1.10"; <i class="conum" data-value="65"></i><b>(65)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.EnableDeltaSync = true; <i class="conum" data-value="66"></i><b>(66)</b>

    // end::listener-config-delta-sync[]
    // tag::listener-config-tls-full[]
    // tag::listener-config-tls-enable[]
    thisConfig.DisableTLS = false; <i class="conum" data-value="67"></i><b>(67)</b>

    // end::listener-config-tls-enable[]
    // tag::listener-config-tls-id-anon[]
    // Use an Anonymous Self-Signed Cert
    thisConfig.TlsIdentity = null; <i class="conum" data-value="68"></i><b>(68)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure the client authenticator
    // Here we are using Basic Authentication) <i class="conum" data-value="69"></i><b>(69)</b>
    SecureString validPassword =  new SecureString(); /* example only */
    // Get SecureString input for validPassword
    var validUser = "valid.username";
    thisConfig.Authenticator = new ListenerPasswordAuthenticator(
      (sender, validUser, validPassword) =&gt;
        {
          return username.equals(validUser)  &amp;&amp; password == validPassword);
        }
      );

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // Initialize the listener
    _thisListener = new URLEndpointListener(thisConfig); <i class="conum" data-value="70"></i><b>(70)</b>

    // Start the listener
    thisListener.Start(); <i class="conum" data-value="71"></i><b>(71)</b>

    // end::listener-start[]
    // end::listener-initialize[]
  }

  // tag::old-listener-config-tls-disable[]
  thisConfig.disableTLS = true;
  // end::old-listener-config-tls-disable[]

  // tag::listener-config-tls-id-nil-2[]

  // Use “anonymous” cert. These are self signed certs created by the system
  thisConfig.TlsIdentity = null;
  // end::listener-config-tls-id-nil-2[]


  // tag::old-listener-config-delta-sync[]
  thisConfig.EnableDeltaSync = true;
  // end::old-listener-config-delta-sync[]


  // tag::listener-status-check[]
  int connectionCount = thisListener.Status.ConnectionCount; <i class="conum" data-value="72"></i><b>(72)</b>
  int activeConnectionCount = thisListener.Status.ActiveConnectionCount;  <i class="conum" data-value="73"></i><b>(73)</b>

  // end::listener-status-check[]


  // tag::listener-stop[]
  thisListener.Stop();

  // end::listener-stop[]

// Additional snippets


// tag::listener-get-network-interfaces[]
foreach(NetworkInterface ni in NetworkInterface.GetAllNetworkInterfaces())
{
  if(ni.NetworkInterfaceType == NetworkInterfaceType.Wireless80211 ||
      ni.NetworkInterfaceType == NetworkInterfaceType.Ethernet)
  {
    // do something with the interface(s)
  }
}

// end::listener-get-network-interfaces[]


// tag::listener-get-url-list[]
var thisConfig = new URLEndpointListenerConfiguration(thisDB);
_thisListener = new URLEndpointListener(thisConfig);

_thisListener.Start();

 Console.WriteLine("URLS are {0} ", thisListener.Urls;

// end::listener-get-url-list[]

    // tag::listener-config-tls-disable[]
    thisConfig.DisableTLS = true; <i class="conum" data-value="74"></i><b>(74)</b>

    // end::listener-config-tls-disable[]

    // tag::listener-local-db[]
    // . . . preceding application logic . . .
    // Get the database (and create it if it doesn't exist)
    var thisDB = new Database("mydb");

    // end::listener-local-db[]

    // tag::listener-config-tls-id-full[]
    // tag::listener-config-tls-id-caCert[]
    // Use CA Cert
    // Create a TLSIdentity from an imported key-pair
    // . . . previously declared variables include ...
    TLSIdentity thisIdentity;
    X509Store _store =
      new X509Store(StoreName.My); // create and label x509 store

    // Get keys and certificates from PKCS12 data
    byte[] thisIdData =
      File.ReadAllBytes("c:client.p12"); <i class="conum" data-value="75"></i><b>(75)</b>
    // . . . other user code . . .

    // tag::import-tls-identity[]
    thisIdentity = TLSIdentity.ImportIdentity(
      _store,
      thisIdData, <i class="conum" data-value="76"></i><b>(76)</b>
      "123", // Password to access certificate data
      "couchbase-demo-cert",
      null); // Label to get cert in certificate map
        // NOTE: If a null label is supplied then the same
        // default directory for a Couchbase Lite database
        // is used for map.

    // end::import-tls-identity[]
    // end::listener-config-tls-id-caCert[]

    // tag::listener-config-tls-id-anon[]
    // Use an Anonymous Self-Signed Cert
    thisConfig.TlsIdentity = null; <i class="conum" data-value="77"></i><b>(77)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-tls-id-set[]
    // Set the TLS Identity
    thisConfig.TlsIdentity = thisIdentity; <i class="conum" data-value="78"></i><b>(78)</b>

    // end::listener-config-tls-id-set[]
    // end::listener-config-tls-id-full[]

    // tag::listener-config-client-auth-root[]
    // Configure the client authenticator
    // to validate using ROOT CA

    // Get the valid cert chain, in this instance from
    // PKCS12 data containing private key, public key
    // and certificates <i class="conum" data-value="79"></i><b>(79)</b>
    var clientData = File.ReadAllBytes("c:client.p12");
    var ourCaData = File.ReadAllBytes("c:client-ca.der");

    // Get the root certs from the data
    var thisRootCert = new X509Certificate2(ourCaData); <i class="conum" data-value="80"></i><b>(80)</b>

    // Configure the authenticator to use the root certs
    var thisAuth = new ListenerCertificateAuthenticator(new X509Certificate2Collection(thisRootCert));

    thisConfig.Authenticator = thisAuth; <i class="conum" data-value="81"></i><b>(81)</b>

    // Initialize the listener using the config
    _listener = new URLEndpointListener(thisConfig);

    // end::listener-config-client-auth-root[]
    // tag::listener-config-client-auth-lambda[]
    // Configure the client authenticator
    // to validate using application logic

    // Get the valid cert chain, in this instance from
    // PKCS12 data containing private key, public key
    // and certificates <i class="conum" data-value="82"></i><b>(82)</b>
    clientData = File.ReadAllBytes("c:client.p12");
    ourCaData = File.ReadAllBytes("c:client-ca.der");

    // Get the root certs from the data
    var thisRootCert = new X509Certificate2(ourCaData);

    // Configure the authenticator to pass the root certs
    // To a user supplied code block for authentication
    var thisAuth =
      new ListenerCertificateAuthenticator(
        new X509Certificate2Collection(thisRootCert) =&gt; {
          // . . . user supplied code block
          // . . . returns boolean value (true=authenticated)
        }); <i class="conum" data-value="83"></i><b>(83)</b>

    thisConfig.Authenticator = thisAuth; <i class="conum" data-value="84"></i><b>(84)</b>

    // end::listener-config-client-auth-lambda[]



// END Additional






// Listener Callouts

// tag::listener-callouts-full[]

  // tag::listener-start-callouts[]
  &lt;.&gt; Initialize the listener instance using the configuration settings.
  &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.
  // end::listener-start-callouts[]


  // tag::listener-status-check-callouts[]

  &lt;.&gt; `connectionCount` -- the total number of connections served by the listener
  &lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
  //
  // end::listener-status-check-callouts[]

// tag::listener-config-tls-id-caCert-callouts[]
  &lt;.&gt; Ensure TLS is enabled.
  &lt;.&gt; The identity will be stored in the secure storage using the given label
  &lt;.&gt; PKCS12 data containing private key, public key, and certificates
  &lt;.&gt; The key pair as stored in the byte array
  &lt;.&gt; The password required to access the certificate data
  &lt;.&gt; The key label assigned to the cert in certificate map and used for retrieval
  &lt;.&gt; If null, the same default directory for a Couchbase Lite database is used for map
  &lt;.&gt; Use the TLSIdentity `thisIdentity.`

// end::listener-config-tls-id-caCert-callouts[]

  // tag::listener-config-tls-id-SelfSigned-callouts[]
  &lt;.&gt; Ensure TLS is enabled.
  &lt;.&gt; The identity will be stored in the secure storage using the given label
  &lt;.&gt; When creating a certificate, the common name attribute is required to create a CSR. If the common name is not present in the certificate an exception is thrown.
  &lt;.&gt; If the expiration date is not specified, the expiration date of the certificate is 365 days after creation
  &lt;.&gt; The key label to get cert in certificate map
  &lt;.&gt; If null, the same default directory for a Couchbase Lite database is used for map
  &lt;.&gt; Use the TLSIdentity `thisIdentity.`

  // end::listener-config-tls-id-SelfSigned-callouts[]

// end::listener-callouts-full[]








// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  // Work in progress. Code snippet to be provided.

  // end::old-listener-config-client-auth-root[]


  // prev content of listener-config-client-auth-self-signed (for ios)
  thisConfig.authenticator = ListenerCertificateAuthenticator.init {
    (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedUsers.contains(["name": certCommonName! as String])) {
      return true
    }
    return false
  }
  // tag::spare-listener-config-client-auth-self-signed[]
  // Work in progress. Code snippet to be provided.

  // end::spare-listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}
// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
thisConfig.port = tls ? wssPort : wsPort
thisConfig.disableTLS = !tls
thisConfig.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
// end::p2p-ws-api-urlendpointlistener-constructor[]


// ACTIVE PEER STUFF
// Replication code
//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

public class Examples {
  private static final String TAG = "EXAMPLE ACTIVE PEER";
  private static final String thisDBNAME = "local-database";
  private final Context context;
  // private Database database;
  // private Replicator replicator;

  public Examples(Context context) { this.context = context; }

  String user = "syncuser";
  String password = "sync9455";
  SecCertificate cert=null;
  String passivePeerEndpoint = "10.1.1.12:8920";
  String passivePeerPort = "8920";
  String passiveDbName = "userdb";
  Database thisDB;
  Replicator thisReplicator;
  ListenerToken replicatorListener;

  //@Test
  public void testActPeerSync() throws CouchbaseLiteException, URISyntaxException {
// tag::p2p-act-rep-func[]
    // . . . preceding code. for example . . .
    private static ListenerToken _thisListenerToken;
    var Database thisDB;
    // . . . other code . . .
    // tag::p2p-act-rep-initialize[]
    // initialize the replicator configuration

    var thisUrl = new URLEndpoint("wss://listener.com:4984/otherDB"); <i class="conum" data-value="85"></i><b>(85)</b>
    var config = new ReplicatorConfiguration(thisDB, thisUrl);

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config-type[]

    // Set replicator type
    thisConfig.ReplicatorType = ReplicatorType.PushAndPull;

    // end::p2p-act-rep-config-type[]
    // tag::autopurge-override[]
    // Set autopurge option
    // here we override its default
    thisConfig.EnableAutoPurge = false; <i class="conum" data-value="86"></i><b>(86)</b>

    // end::autopurge-override[]
    // tag::p2p-act-rep-config-cont[]
    // Configure Sync Mode
    thisConfig.Continuous = true; // default value

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Security -- only accept self-signed certs
    thisConfig.AcceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="87"></i><b>(87)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Security <i class="conum" data-value="88"></i><b>(88)</b>
    // tag::p2p-act-rep-auth[]
    // Configure basic auth using user credentials
    thisConfig.Authenticator = new BasicAuthenticator("Our Username", "Our Password");

    // end::p2p-act-rep-auth[]
    // tag::p2p-act-rep-config-conflict-full[]
    // tag::p2p-act-rep-config-conflict-builtin[]
    /* Optionally set a conflict resolver call back */ <i class="conum" data-value="89"></i><b>(89)</b>
    // Use built-in resolver
    thisConfig.ConflictResolver = new LocalWinConflictResolver();  //

    // end::p2p-act-rep-config-conflict-builtin[]
    // tag::p2p-act-rep-config-conflict-custom[]
    // optionally use custom resolver
    thisConfig.ConflictResolver = new ConflictResolver(
      (conflict) =&gt; {
        /* define resolver function */
      }
    ); //

    // end::p2p-act-rep-config-conflict-custom[]
    // end::p2p-act-rep-config-conflict-full[]
    // tag::p2p-act-rep-start-full[]
    // Initialize and start a replicator
    // Initialize replicator with configuration data
    var thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="90"></i><b>(90)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    //Optionally add a change listener <i class="conum" data-value="91"></i><b>(91)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    _thisListenerToken =
      thisReplicator.AddChangeListener((sender, args) =&gt;
        {
          if (args.Status.Activity == ReplicatorActivityLevel.Stopped) {
              Console.WriteLine("Replication stopped");
          }
        });

    // end::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-start[]
    // Start replicator
    thisReplicator.Start(); <i class="conum" data-value="92"></i><b>(92)</b>

    // end::p2p-act-rep-start[]
// end::p2p-act-rep-start-full[]
// end::p2p-act-rep-func[]         ***** End p2p-act-rep-func
}

// Additional snippets

    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA certs
    thisConfig.AcceptOnlySelfSignedServerCertificate = false; <i class="conum" data-value="93"></i><b>(93)</b>

    // end::p2p-act-rep-config-cacert[]
    // tag::p2p-act-rep-config-pinnedcert[]

    // Return the remote pinned cert (the listener's cert)
    byte returnedCert = new byte(thisConfig.getPinnedCertificate()); // Get listener cert if pinned
    // end::p2p-act-rep-config-pinnedcert[]
    // Configure Client Security <i class="conum" data-value="94"></i><b>(94)</b>
    // tag::p2p-act-rep-auth[]
    // Configure basic auth using user credentials
    thisConfig.Authenticator = new BasicAuthenticator("Our Username", "Our Password");

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]

    // tag::p2p-act-rep-config-cacert-pinned[]
    // Only CA Certs accepted
    thisConfig.AcceptOnlySelfSignedServerCertificate =
      false; <i class="conum" data-value="95"></i><b>(95)</b>

    var thisCert =
      new X509Certificate2(caData); <i class="conum" data-value="96"></i><b>(96)</b>

    thisConfig.PinnedServerCertificate =
      thisCert; <i class="conum" data-value="97"></i><b>(97)</b>

    // end::p2p-act-rep-config-cacert-pinned[]












    // Code to refactor
    Log.i(TAG, "The Replicator is currently " + thisReplicator.Status().getActivityLevel());

    Log.i(TAG, "The Replicator has processed " + t);

    if (thisReplicator.Status().getActivityLevel() == Replicator.ActivityLevel.BUSY) {
          Log.i(TAG, "Replication Processing");
          Log.i(TAG, "It has completed " + thisReplicator.Status().getProgess().getTotal() + " changes");
      }
    // tag::p2p-act-rep-status[]
    _thisReplicator.Stop();
    while (_thisReplicator.Status.Activity != ReplicatorActivityLevel.Stopped) {
        // Database cannot close until replicators are stopped
        Console.WriteLine($"Waiting for replicator to stop (currently {_thisReplicator.Status.Activity})...");
        Thread.Sleep(200);
    }
    _thisDatabase.Close();
    // end::p2p-act-rep-status[]

      // tag::p2p-act-rep-stop[]
      // Stop replication.
      thisReplicator.Stop(); <i class="conum" data-value="98"></i><b>(98)</b>
      // end::p2p-act-rep-stop[]


  }

{
  CouchbaseLite.init(context);
  Database thisDB = new Database("passivepeerdb");  <i class="conum" data-value="99"></i><b>(99)</b>
  // Initialize the listener config
  final URLEndpointListenerConfiguration thisConfig = new URLEndpointListenerConfiguration(database);
  thisConfig.Port(55990)             // &lt;.&gt; Default- port is selected
  thisConfig.DisableTls(false)       // &lt;.&gt; Optional. Defaults to false. You get TLS encryption out-of-box
  thisConfig.EnableDeltaSync(true)   // &lt;.&gt; Optional. Defaults to false.

  // Configure the client authenticator (if using basic auth)
  ListenerPasswordAuthenticator auth = new ListenerPasswordAuthenticator { "Our Username", "Our Password"}; <i class="conum" data-value="100"></i><b>(100)</b>
  thisConfig.Authenticator(auth); <i class="conum" data-value="101"></i><b>(101)</b>

  // Initialize the listener
  final URLEndpointListener listener = new URLEndpointListener( thisConfig ); <i class="conum" data-value="102"></i><b>(102)</b>

  // Start the listener
  listener.Start(); <i class="conum" data-value="103"></i><b>(103)</b>
    }


// tag::createTlsIdentity[]

Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
           TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
           TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
           TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
           TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
       )

TLSIdentity thisIdentity = new TLSIdentity.createIdentity(true, X509_ATTRIBUTES, null, "test-alias");

// end::createTlsIdentity[]


// tag::p2p-tlsid-store-in-keychain[]
. . . work in progress - GetHashCode snippet to be provided
// end::p2p-tlsid-store-in-keychain[]

// tag::deleteTlsIdentity[]
// tag::p2p-tlsid-delete-id-from-keychain[]
TLSIdentity.DeleteIdentity(_store, "alias-to-delete", null);

// end::p2p-tlsid-delete-id-from-keychain[]
// end::deleteTlsIdentity[]

// tag::retrieveTlsIdentity[]
// OPTIONALLY:: Retrieve a stored TLS identity using its alias/label

TLSIdentity thisIdentity = new TLSIdentity.getIdentity("CBL-Demo-Server-Cert")
// end::retrieveTlsIdentity[]


    // Configure the client authenticator (if using Basic Authentication)
    // String validUser = new String("validUsername"); // an example username
    // String validPassword = new String("validPasswordValue"); // an example password

    // ListenerPasswordAuthenticator thisAuth = new ListenerPasswordAuthenticator( <i class="conum" data-value="104"></i><b>(104)</b>
    //   validUser, validPassword -&gt; validUser == "validUsername" &amp;&amp; validPassword == "validPasswordValue" );

    // if (thisAuth) {
    //   thisConfig.Authenticator(auth);
    // }
    // else {
    //   // . . . authentication failed take appropriate exception action
    //   return
    // };




    // tag::old-p2p-act-rep-add-change-listener[]
    ListenerToken thisListener = new thisReplicator.addChangeListener(change -&gt; { <i class="conum" data-value="105"></i><b>(105)</b>
      if (change.Status().getError() != null) {
        Log.i(TAG, "Error code ::  " + change.Status().getError().getCode());
      }
    });

    // end::old-p2p-act-rep-add-change-listener[]



// g u b b i n s
// tag::duff-p2p-tlsid-tlsidentity-with-label[]


    // Configure TLS Cert CA auth using key-stored cert id alias 'doc-sync-server'

    // TLSIdentity thisIdentity = new TLSIdentity.getIdentity("doc-sync-server"); // Get existing TLS ID from sec storage

    // ClientCertificateAuthenticator thisAuth = new ClientCertificateAuthenticator(thisIdentity);

    // thisConfig.Authenticator(thisAuth);



    // USE KEYCHAIN IDENTITY IF EXISTS
    // Check if Id exists in keychain. If so use that Id

    // STILL NEED TO REFACTOR

    do {
      if let thisIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
          print("An identity with label : doco-sync-server already exists in keychain")
          return thisIdentity
          }
    } catch
    {return nil}
    thisAuthenticator.ClientCertificateAuthenticator(identity: thisIdentity )
    thisConfig.thisAuthenticator

    // end::duff-p2p-tlsid-tlsidentity-with-label[]


// tag::old-deleteTlsIdentity[]

String thisAlias = "alias-to-delete";
KeyStore thisKeystore = KeyStore.getInstance("PKCS12"); <i class="conum" data-value="106"></i><b>(106)</b>
thisKeyStore.load= null;
if (thisAlias != null) {
   thisKeystore.deleteEntry(thisAlias);  <i class="conum" data-value="107"></i><b>(107)</b>
}

// end::old-deleteTlsIdentity[]


// cert auth
let rootCertData = SecCertificateCopyData(cert) as Data
let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
// Listener:
thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

SecCertificate thisCert = new SecCertificate(); // populated as nec.

Data rootCertData = new Data(SecCertificateCopyData(thisCert));

let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
// Listener:
thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])
// cert auth


// C A L L O U T S

// tag::p2p-act-rep-config-cacert-pinned-callouts[]
&lt;.&gt; Configure to accept only CA certs
&lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
&lt;.&gt; Set the certificate to be compared with that provided by the server
// end::p2p-act-rep-config-cacert-pinned-callouts[]

// tag::??p2p-tlsid-tlsidentity-with-label-callouts[]
&lt;.&gt; PKCS12 data containing private key, public key, and certificates
&lt;.&gt; This is the default value and means that TLS is enabled
// end::??p2p-tlsid-tlsidentity-with-label-callouts[]

// tag::p2p-tlsid-tlsidentity-with-label-callouts[]
&lt;.&gt; Refuse self-signed certificates
&lt;.&gt; Get the identity
&lt;.&gt; Set the Client Certificate Authenticator to require signed certificates with this identity

// end::p2p-tlsid-tlsidentity-with-label-callouts[]


    // tag::old-listener-config-client-root-ca[]
    // Configure the client authenticator
    // to validate using ROOT CA <i class="conum" data-value="108"></i><b>(108)</b>
    byte[] thisCaData; // byte array for CA data
    using (var thisReader = new BinaryReader(stream)) {
      thisCaData = thisReader.ReadBytes(int stream.Length);
    }; // Get cert data

    var thisRootCert = new X509Certificate(thisCaData); //

    thisConfig.Authenticator = new  ListenerCertificateAuthenticator(
      new X509Certificate2Collection(thisRootCert)
    );

    // end::old-listener-config-client-root-ca[]



        // tag::p2p-tlsid-tlsidentity-with-label-per-sam[]
    var db = new Database("other-database");
    _Database = db;
    X509Store _store = new X509Store(StoreName.My);
    TLSIdentity thisIdentity;

    // tag::client-cert-authenticator-root-certs[]

    // Configure the expected server-supplied
    // credentials -- only accept CA Certs
    thisConfig.AcceptOnlySelfSignedServerCertificate = false; <i class="conum" data-value="109"></i><b>(109)</b>

    // Client identity
    thisIdentity =
      TLSIdentity.ImportIdentity(_store,
        clientData,
        "123",
        "CBL-Client-Cert",
        null); <i class="conum" data-value="110"></i><b>(110)</b>

    thisConfig.Authenticator =
      new ClientCertificateAuthenticator(thisIdentity); <i class="conum" data-value="111"></i><b>(111)</b>

    // end::client-cert-authenticator-root-certs[]





    byte[] thisCaData, thisClientData;
    thisClientData = File.ReadAllBytes("C:\\client.p12"); <i class="conum" data-value="112"></i><b>(112)</b>
    thisCaData = File.ReadAllBytes("C:\\client-ca.der");

    // Root certs
    var thisRootCert = new X509Certificate2(thisCaData);
    var thisAuth =
      new ListenerCertificateAuthenticator(
        new X509Certificate2Collection(thisRootCert));

    // Create URL Endpoint Listener
    var thisConfig = new URLEndpointListenerConfiguration(_Database);
    thisConfig.DisableTLS = false; <i class="conum" data-value="113"></i><b>(113)</b>
    thisConfig.Authenticator = thisAuth;
    _listener = new URLEndpointListener(thisConfig);
    _listener.Start();

    // Client identity
    thisIdentity = TLSIdentity.ImportIdentity(_store,
        thisClientData,
        "123",
        "CBL-Client-Cert",
        null);

    // Replicator -- Client
    var database = new Database("client-database");
    var builder = new UriBuilder(
        "wss",
        "localhost",
        _listener.Port,
        $"/{_listener.thisConfig.Database.Name}"
    );

    var url = builder.Uri;
    var target = new URLEndpoint(url);
    var thisConfig = new ReplicatorConfiguration(database, target);
    thisConfig.ReplicatorType = ReplicatorType.PushAndPull;
    thisConfig.Continuous = false;
    thisConfig.Authenticator = new ClientCertificateAuthenticator(thisIdentity);
    thisConfig.AcceptOnlySelfSignedServerCertificate = true;
    thisConfig.PinnedServerCertificate = _listener.TlsIdentity.Certs[0];
    using (var replicator = new Replicator(thisConfig)) {
        replicator.Start();
    }





    // Stop listener after replicator is stopped
    _listener.Stop();

    // end::p2p-tlsid-tlsidentity-with-label-per-sam[]


        // tag::p2p-tlsid-tlsidentity-with-label[]
    // Client identity
    thisIdentity =
      TLSIdentity.ImportIdentity(_store,
        clientData,
        "123",
        "CBL-Client-Cert",
        null); <i class="conum" data-value="114"></i><b>(114)</b>

    thisConfig.Authenticator =
      new ClientCertificateAuthenticator(thisIdentity); <i class="conum" data-value="115"></i><b>(115)</b>

    // end::p2p-tlsid-tlsidentity-with-label[]


  // For replications

  // BEGIN -- snippets --
  //    Purpose -- code samples for use in replication topic

  // tag::sgw-repl-pull[]
  public class MyClass
  {
      public Database Database { get; set; }
      public Replicator Replicator { get; set; } <i class="conum" data-value="116"></i><b>(116)</b>

      public void StartReplication()
      {
  }

          var url = new Uri("wss://localhost:4984/db"); <i class="conum" data-value="117"></i><b>(117)</b>
          var target = new URLEndpoint(url);
          var config = new ReplicatorConfiguration(Database, target)
          {
              ReplicatorType = ReplicatorType.Pull
          };

          Replicator = new Replicator(config);
          Replicator.Start();
      }
      // end::sgw-repl-pull[]

      // tag::sgw-repl-pull-callouts[]
      // &lt;.&gt; A replication is an asynchronous operation.
      // To keep a reference to the `replicator` object, you can set it as an instance property.
      // &lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
      // You should now use `ws:`, or `wss:` for SSL/TLS connections.
      // end::sgw-repl-pull-callouts[]

      public void InitReplication()
      {
        // tag::sgw-act-rep-initialize[]
        // initialize the replicator configuration

        var thisUrl = new URLEndpoint("wss://l10.0.2.2:4984/anotherDB"); <i class="conum" data-value="118"></i><b>(118)</b>
        var config = new ReplicatorConfiguration(thisDB, thisUrl);

        // end::sgw-act-rep-initialize[]
      }
  }
 }



  public class supporting_datatypes
  {
    public void datatype_usage()
    {

        // tag::datatype_usage[]
        // tag::datatype_usage_createdb[]
        // Get the database (and create it if it doesn’t exist).
        var database = new Database("hoteldb");

        // end::datatype_usage_createdb[]
        // tag::datatype_usage_createdoc[]
        // Create your new document

        // Add the dictionary to a document's properties and save the document
        var doc = new MutableDocument("hoteldoc");

        // end::datatype_usage_createdoc[]
        // tag::datatype_usage_mutdict[]
        // Create and populate mutable dictionary
        var address = new MutableDictionaryObject();
        address.SetString("street", "1 Main st.");
        address.SetString("city", "San Francisco");
        address.SetString("state", "CA");
        address.SetString("country", "USA");
        address.SetString("code", "90210");

        // end::datatype_usage_mutdict[]
        // tag::datatype_usage_mutarray[]
        // Create and populate mutable array
        var phones = MutableArrayObject();
        phones.AddString("650-000-0000");
        phones.AddString("650-000-0001");

        // end::datatype_usage_mutarray[]
        // tag::datatype_usage_populate[]
        // Initialize and populate the document

        // Add document type to document properties <i class="conum" data-value="119"></i><b>(119)</b>
        doc.SetString("type", "hotel");

        // Add hotel name string to document properties <i class="conum" data-value="120"></i><b>(120)</b>
        doc.SetString("name", "Hotel Java Mo");

        // Add float to document properties <i class="conum" data-value="121"></i><b>(121)</b>
        doc.SetFloat("room_rate", 121.75);

        // Add dictionary to document's properties <i class="conum" data-value="122"></i><b>(122)</b>
        doc.SetDictionary("address", address);

        // Add array to document's properties <i class="conum" data-value="123"></i><b>(123)</b>
        doc.SetArray("phones", phones);

        // end::datatype_usage_populate[]
        // tag::datatype_usage_persist[]
        // Save the document changes <i class="conum" data-value="124"></i><b>(124)</b>
        database.Save(doc);

        // end::datatype_usage_persist[]
        // tag::datatype_usage_closedb[]
        // Close the database <i class="conum" data-value="125"></i><b>(125)</b>
        database.Close();

        // end::datatype_usage_closedb[]

        // end::datatype_usage[]

     }



      public void datatype_dictionary()
      {
          var database = new Database(name: "mydb");

          // tag::datatype_dictionary[]
          // NOTE: No error handling, for brevity (see getting started)
          var document = database.GetDocument("doc1");

          // Getting a dictionary from the document's properties
          var dict = document.GetDictionary("address");

          // Access a value with a key from the dictionary
          var street = dict.GetString("street");

          // Iterate dictionary
          foreach (var key in dict.Keys)
          {
              Console.WriteLine($"Key {key} = {dict.GetValue(key)}");
          }

          // Create a mutable copy
          var mutDict = dict.ToMutable();
          // end::datatype_dictionary[]
      }

      public void datatype_mutable_dictionary()
      {

          var database = new Database("mydb");

          // tag::datatype_mutable_dictionary[]
          // NOTE: No error handling, for brevity (see getting started)

          // Create a new mutable dictionary and populate some keys/values
          var mutable_dict = new MutableDictionaryObject();
          mutable_dict.SetString("street", "1 Main st.");
          mutable_dict.SetString("city", "San Francisco");

          // Add the dictionary to a document's properties and save the document
          var doc = new MutableDocument("doc1");
          doc.SetDictionary("address", mutable_dict);
          database.Save(doc);

          // end::datatype_mutable_dictionary[]
      }


      public void datatype_array()
      {
          var database = new Database("mydb");

          // tag::datatype_array[]
          // NOTE: No error handling, for brevity (see getting started)

          var document = database.GetDocument("doc1");

          // Getting a phones array from the document's properties
          var array = document.GetArray("phones");

          // Get element count
          var count = array.Count();

          // Access an array element by index
          if (count &gt;= 0) { var phone = array[1]; }

          // Iterate dictionary
          for (int i = 0; i &lt; count; i++)
          {
              Console.WriteLine($"Item {i.ToString()} = {array[i]}");
          }

          // Create a mutable copy
          var mutable_array = array.ToMutable();
          // end::datatype_array[]


      }

        public void datatype_mutable_array()
      {
          var database = new Database("mydb");

          // tag::datatype_mutable_array[]
          // NOTE: No error handling, for brevity (see getting started)

          // Create a new mutable array and populate data into the array
          var mutable_array = new MutableArrayObject();
          mutable_array.AddString("650-000-0000");
          mutable_array.AddString("650-000-0001");

          // Set the array to document's properties and save the document
          var doc = new MutableDocument("doc1");
          doc.SetArray("phones", mutable_array);
          database.Save(doc);
          // end::datatype_mutable_array[]
      }

  } // end  class supporting_datatypes</code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="delete-tls-identity"><a class="anchor" href="#delete-tls-identity"></a>Delete TLS Identity</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#" data-source-url="https://github.com/couchbase/docs-couchbase-lite/blob/undefined/modules/csharp/examples/code_snippets/Program.cs">TLSIdentity.DeleteIdentity(_store, "alias-to-delete", null);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="related-content"><a class="anchor" href="#related-content"></a>Related Content</h2>
<div class="sectionbody">
<div class="card-row three-column-row">
<div class="sect5 column">
<h6 id=""><a class="anchor" href="#"></a></h6>
<div class="ulist">
<div class="title">How to</div>
<ul>
<li>
<p><a href="p2psync-websocket-using-passive.html" class="xref page">Passive Peer</a></p>
</li>
<li>
<p><a href="p2psync-websocket-using-active.html" class="xref page">Active Peer</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-2"><a class="anchor" href="#-2"></a></h6>
<div class="ulist">
<div class="title">Concepts</div>
<ul>
<li>
<p><a href="#csharp:landing-p2psync.adoc" class="xref unresolved">Peer-to-Peer Sync</a></p>
</li>
<li>
<p><a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-net">API References</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-3"><a class="anchor" href="#-3"></a></h6>
<div class="paragraph">
<div class="title">Community Resources &#8230;&#8203;</div>
<p><a href="https://forums.couchbase.com/c/mobile/14">Mobile Forum</a> |
<a href="https://blog.couchbase.com/">Blog</a> |
<a href="https://docs.couchbase.com/tutorials/">Tutorials</a></p>
</div>
<div class="paragraph">
<div class="title"></div>
<p><a href="#tutorials:cbl-p2p-sync-websockets:swift/cbl-p2p-sync-websockets.adoc" class="xref unresolved">Getting Started with Peer-to-Peer Synchronization</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="related-content-2"><a class="anchor" href="#related-content-2"></a>Related Content</h2>
<div class="sectionbody">
<div class="card-row three-column-row">
<div class="sect5 column">
<h6 id="-4"><a class="anchor" href="#-4"></a></h6>
<div class="ulist">
<div class="title">How to</div>
<ul>
<li>
<p><a href="p2psync-websocket-using-passive.html" class="xref page">Passive Peer</a></p>
</li>
<li>
<p><a href="p2psync-websocket-using-active.html" class="xref page">Active Peer</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-5"><a class="anchor" href="#-5"></a></h6>
<div class="ulist">
<div class="title">Concepts</div>
<ul>
<li>
<p><a href="#csharp:landing-p2psync.adoc" class="xref unresolved">Peer-to-Peer Sync</a></p>
</li>
<li>
<p><a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-net">API References</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-6"><a class="anchor" href="#-6"></a></h6>
<div class="paragraph">
<div class="title">Community Resources &#8230;&#8203;</div>
<p><a href="https://forums.couchbase.com/c/mobile/14">Mobile Forum</a> |
<a href="https://blog.couchbase.com/">Blog</a> |
<a href="https://docs.couchbase.com/tutorials/">Tutorials</a></p>
</div>
<div class="paragraph">
<div class="title"></div>
<p><a href="#tutorials:cbl-p2p-sync-websockets:swift/cbl-p2p-sync-websockets.adoc" class="xref unresolved">Getting Started with Peer-to-Peer Synchronization</a></p>
</div>
</div>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase">
          </a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <svg  width="14" height="14" viewBox="0 0 32.1 26.1"> <path id="twitter" class="cls-1" d="M32,7.1a11.836,11.836,0,0,1-3.8,1,6.462,6.462,0,0,0,2.9-3.6,12.606,12.606,0,0,1-4.2,1.6A6.492,6.492,0,0,0,22.1,4a6.594,6.594,0,0,0-6.6,6.6,7.719,7.719,0,0,0,.2,1.5A18.458,18.458,0,0,1,2.2,5.2a6.294,6.294,0,0,0-.9,3.3A6.765,6.765,0,0,0,4.2,14a6.109,6.109,0,0,1-3-.8v.1a6.543,6.543,0,0,0,5.3,6.4,4.678,4.678,0,0,1-1.7.2,4.869,4.869,0,0,1-1.2-.1,6.679,6.679,0,0,0,6.1,4.6,12.917,12.917,0,0,1-8.2,2.8,9.151,9.151,0,0,1-1.6-.1,18.438,18.438,0,0,0,10.1,3c12.1,0,18.7-10,18.7-18.7v-.8A13.336,13.336,0,0,0,32,7.2Z" transform="translate(0.1 -4)"/></svg>
            <a href="https://twitter.com/couchbase" class="icon">
              Twitter
            </a>
          </li>
          <li>
          <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="linkedin" class="cls-1" d="M29,0H3A3.076,3.076,0,0,0,0,3V29a3.009,3.009,0,0,0,3,3H29a2.946,2.946,0,0,0,3-3V3A3.009,3.009,0,0,0,29,0ZM12,26H8V12h4ZM10,10a2,2,0,1,1,2-2A2.006,2.006,0,0,1,10,10ZM26,26H22V18a2,2,0,0,0-4,0v8H14V12h4v2.5c.8-1.1,2.1-2.5,3.5-2.5A4.736,4.736,0,0,1,26,17Z"/></svg>
              <a href="https://www.linkedin.com/company/couchbase" class="icon">
             Linkedin
            </a>
          </li>
          <li>
            <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="facebook" class="cls-1" d="M29,0H3A2.652,2.652,0,0,0,0,3V29a2.652,2.652,0,0,0,3,3H16V18H12V14h4V12a6.452,6.452,0,0,1,6-6h4v4H22a2.151,2.151,0,0,0-2,2v2h6l-1,4H20V32h9a2.652,2.652,0,0,0,3-3V3A2.652,2.652,0,0,0,29,0Z"/></svg>
            <a href="https://www.facebook.com/Couchbase" class="icon">
            Facebook
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <div class="footer-terms-copyright">
          <span>© 2022 Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.</span>
      </div>
      <div class="footer-terms-links">
        <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
        <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
        <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
        <a href="https://www.couchbase.com/support-policy">Support Policy</a>
        <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
      </div>
    </div>
  </div>
</footer>
<script src="../../../_/js/site-navigation-data.js"></script>
<script id="page-navigation-group" type="application/json">
{"title":"Mobile","components":["couchbase-lite","sync-gateway"],"url":"/home/mobile.html","latestVersions":{"couchbase-lite":"3.0","sync-gateway":"3.0"}}
</script>
<template id="run-code-panel">
<div class="action-panel">
  <form class="action-panel-control" method="POST" action="https://couchbase.live/run" target="run-code-output">
    <input type="hidden" name="lang">
    <input type="hidden" name="code">
    <input type="hidden" name="from" value="docs">
    <div class="controls">
      <button class="control-button rerun" type="submit"><i class="fas fa-redo"></i></button>
      <span class="shell-name control-label">Output</span>
      <button class="control-button close"><i class="fas fa-times"></i> Close</button>
    </div>
  </form>
  <iframe class="run-code-output" name="run-code-output"></iframe>
</div>
</template>
<script id="site-script" src="../../../_/js/site.js"></script>
<script defer src="../../../_/js/vendor/fontawesome-icon-defs.js"></script>
<script defer src="../../../_/js/vendor/fontawesome.js" data-search-pseudo-elements="true"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
</body>
</html>
